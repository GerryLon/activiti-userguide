[[chapterApi]]

== The Activiti API

[[apiEngine]]


=== 流程引擎API与服务 The Process Engine API and services

引擎API是与Activiti交互的最常用手段。中心入口是++ProcessEngine++，像<<configuration,配置章节>>中介绍的一样，可以使用多种方式创建。使用ProcessEngine，可以获得包含工作流/BPM方法的多种服务。ProcessEngine与服务对象都是线程安全的，因此可以在整个服务器中保存一份引用。

image::images/api.services.png[align="center"]

[source,java,linenums]
----
ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();

RuntimeService runtimeService = processEngine.getRuntimeService();
RepositoryService repositoryService = processEngine.getRepositoryService();
TaskService taskService = processEngine.getTaskService();
ManagementService managementService = processEngine.getManagementService();
IdentityService identityService = processEngine.getIdentityService();
HistoryService historyService = processEngine.getHistoryService();
FormService formService = processEngine.getFormService();
----

++ProcessEngines.getDefaultProcessEngine()++在第一次被调用时将初始化并构建流程引擎，在之后的调用都会返回相同的流程引擎。流程引擎的创建通过++ProcessEngines.init()++实现，关闭由++ProcessEngines.destroy()++实现。


ProcessEngines会扫描所有++activiti.cfg.xml++与++activiti-context.xml++文件。对于所有的++activiti.cfg.xml++文件，流程引擎会以标准Activiti方式构建：++ProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(inputStream).buildProcessEngine()++。对于所有的++activiti-context.xml++文件，流程引擎会以Spring的方式构建：首先构建Spring应用上下文，然后从该上下文中获取流程引擎。

所有的服务都是无状态的。这意味着你可以很容易的在集群环境的多个节点上运行Activiti，使用同一个数据库，而不用担心上一次调用实际在哪台机器上执行。不论在哪里执行，对任何服务的任何调用都是幂等（idempotent）的。

**RepositoryService**很可能是使用Activiti引擎要用的第一个服务。这个服务提供了管理与控制++deployments++（部署）与++process definitions++（流程定义）的操作。在这里简单说明一下，流程定义是BPMN 2.0流程的Java等价副本，展现流程中每一步的结构与行为。++deployment++是Activiti引擎中的包装单元，一个部署中可以包含多个BPMN 2.0 xml文件，以及其他资源。开发者可以决定在一个部署中包含的内容，可以是单各流程的BPMN 2.0 xml文件，也可以包含多个流程及其相关资源（如'hr-processes'部署可以包含所有与人力资源流程相关的的东西）。++RepositoryService++可用于++deploy++（部署）这样的包。部署意味着将它上传至引擎，引擎将在储存至数据库之前检查与分析所有的流程。从这里开始，系统知道了这个部署，部署中包含的所有流程都可以启动。

此外，这个服务还可以：

* 查询引擎已知的部署与流程定义。、
* 挂起或激活部署中的某些流程，或整个部署。挂起意味着不能再对它进行操作，激活是其反操作。
* 读取各种资源，比如部署中保存的文件，或者引擎自动生成的流程图。
* 读取POJO版本的流程定义。使用它可以用Java而不是xml的方式检查流程。

++RepositoryService++提供的是静态信息（也就是不会改变，至少不会经常改变的信息），而**RuntimeService**就完全相反。它可以启动流程定义的新流程实例。前面介绍过，++process definition++（流程定义）定义了流程中不同步骤的结构与行为。流程实例则是流程定义的实际执行。同一时刻，一个流程定义通常有多个运行中的实例。++RuntimeService++也用于读取与存储++process variables++（流程变量）。流程变量是给定流程持有的数据，可以在流程的许多构造中使用（例如排他网关exclusive gateway 经常使用流程变量决定流程下一步要选择的路径）。++Runtimeservice++还可以用于查询流程实例与执行（execution）。执行代表了BPMN 2.0中的 +$$'token'$$+ 概念。通常执行是指向流程实例当前位置的指针。最后，++RuntimeService++还可以在流程实例等待外部触发时使用，以便流程可以继续运行。流程有许多++wait states++（暂停状态），++RuntimeService++服务提供了许多操作用于“通知”流程实例，告知已经接受到外部触发，流程实例可以继续运行。


对于像Activiti这样的BPM引擎来说，核心是需要人类用户实际操作的任务。所有任务相关的东西都组织在**TaskService**中，例如

* 查询分派给用户或组的任务
* 创建__standalone（独立运行）__任务。这是一种没有关联到流程实例的任务。
* 决定任务的执行用户（assignee），或者用户通过某种方式与任务关联。
* 认领（claim）与完成（complete）任务。认领是指某人决定成为任务的执行用户，也即他将会完成这个任务。完成任务是指“做这个任务要求的工作”，通常是填写某种表单。

**IdentityService**很简单。它用于管理（创建，更新，删除，查询……）组与用户。请重点注意，Activiti实际上在运行时并不做任何用户检查。例如任务可以分派给任何用户，而引擎并不会验证系统中是否存在该用户。这是因为Activiti有时要与LDAP、Active Directory等服务结合使用

**FormService**是可选服务。也就是说Activiti没有它也能很好地运行，而不必牺牲任何功能。这个服务引入了__start form（开始表单）__与__task form（任务表单）__的概念。 __开始表单__是在流程实例启动前显示的表单，而__任务表单__是用户完成任务时显示的表单。Activiti可以在BPMN 2.0流程定义中定义这些表单。表单服务通过简单的方式暴露这些数据。再次重申，表单不一定要嵌入流程定义，因此这个服务是可选的。

**HistoryService**暴露所有Activiti引擎手机的历史数据。当执行流程时，引擎会保存许多数据（可以配置），例如流程实例启动时间，谁在执行哪个任务，完成任务花费的事件，每个流程实例的执行路径，等等。这个服务主要暴露这些数据的查询能力。

**ManagementService**通常在用Activiti编写用户应用时不需要使用。它可以用于读取数据库表与表原始数据的信息。并且也提供了对作业（job）的查询与管理操作。Activiti中很多地方都使用作业，例如定时器（timer），异步操作（asynchronous continuation），延时挂起/激活（delayed suspension/activation）等等。后续会详细介绍这些内容。

For more detailed information on the service operations and the engine API, see link:$$http://activiti.org/javadocs/index.html$$[the javadocs].


=== 异常策略 Exception strategy

Activiti的异常基类是++org.activiti.engine.ActivitiException++，是未检查异常（unchecked exception）。在任何API操作时都会抛出这个异常，link:$$http://activiti.org/javadocs/index.html$$[javadoc]记录了每个方法可能发生的异常。例如，从++TaskService++中摘录：

[source,java,linenums]
----
/**
 * 当任务成功执行时调用。
 * @param taskId 需要完成的任务id，不能为null。
 * @throws ActivitiObjectNotFoundException 若给定id找不到任务。
 */
 void complete(String taskId);
----

在上例中，如果传递的id找不到任务，会抛出异常。并且，由于javadoc中**明确要求taskId不能为null，因此如果传递了++null++值，会抛出++ActivitiIllegalArgumentException++异常**。

尽管我们想避免过大的异常层次结构，我们还是添加了下述在特定情况下抛出的异常子类。所有流程执行与API调用中发生的错误，如果不符合下面列出的异常，会统一抛出++ActivitiExceptions++。

* ++ActivitiWrongDbException++: 当Activiti引擎检测到数据库表结构版本与引擎版本不匹配时抛出。
* ++ActivitiOptimisticLockingException++: 当对同一数据实体的并发访问，导致数据存储发生乐观锁时抛出。
* ++ActivitiClassLoadingException++: 当需要载入的类（如JavaDelegates, TaskListeners, ...）无法找到，或载入时发生错误时抛出。
* ++ActivitiObjectNotFoundException++: 当请求或要操作的对象不存在时抛出。
* ++ActivitiIllegalArgumentException++: 这个异常说明调用Activiti API时使用了不合法的参数。可能是引擎配置中的不合法值，或者是API调用传递的不合法参数，也可能是流程定义中的不合法值。
* ++ActivitiTaskAlreadyClaimedException++: 当调用++taskService.claim(...)++，而该任务已经被认领时抛出。


[[api.services]]


=== 使用Activiti services(Working with the Activiti services)


如前所述，与Activiti引擎交互的方式，是使用++org.activiti.engine.ProcessEngine++类实例暴露的服务。下面的示例假定你已经有可运行的Activiti环境，也就是说，你可以访问有效的++org.activiti.engine.ProcessEngine++。如果你只是简单地想尝试下面的代码，可以下载或克隆link:$$https://github.com/Activiti/activiti-unit-test-template$$[Activiti单元测试模板]，导入你的IDE，在++org.activiti.MyUnitTest++单元测试中增加一个++testUserguideCode()++方法。

这段小教程的最终目标是生成一个业务流程，模拟公司中简单的请假流程：

image::images/api.vacationRequest.png[align="center"]



[[api.services.deployment]]


==== Deploying the process

Everything that is related to 'static' data (such as process definitions) are accessed through the *RepositoryService*. Conceptually, every such static piece of data is content of the 'repository' of the Activiti engine.

Create a new xml file +VacationRequest.bpmn20.xml+ in the +src/test/resources/org/activiti/test+ resource folder (or anywhere else if you're not using the unit test template) with the following content. Note that this section won't explain the xml constructs being used in the example above. Please read <<bpmn20,the BPMN 2.0 chapter>> to become familiar with these constructs first if needed.

[source,xml,linenums]
----
<?xml version="1.0" encoding="UTF-8" ?>
<definitions id="definitions"
             targetNamespace="http://activiti.org/bpmn20"
             xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xmlns:activiti="http://activiti.org/bpmn">

  <process id="vacationRequest" name="Vacation request">

    <startEvent id="request" activiti:initiator="employeeName">
      <extensionElements>
        <activiti:formProperty id="numberOfDays" name="Number of days" type="long" value="1" required="true"/>
        <activiti:formProperty id="startDate" name="First day of holiday (dd-MM-yyy)" datePattern="dd-MM-yyyy hh:mm" type="date" required="true" />
        <activiti:formProperty id="vacationMotivation" name="Motivation" type="string" />
      </extensionElements>
    </startEvent>
    <sequenceFlow id="flow1" sourceRef="request" targetRef="handleRequest" />

    <userTask id="handleRequest" name="Handle vacation request" >
      <documentation>
        ${employeeName} would like to take ${numberOfDays} day(s) of vacation (Motivation: ${vacationMotivation}).
      </documentation>
      <extensionElements>
         <activiti:formProperty id="vacationApproved" name="Do you approve this vacation" type="enum" required="true">
          <activiti:value id="true" name="Approve" />
          <activiti:value id="false" name="Reject" />
        </activiti:formProperty>
        <activiti:formProperty id="managerMotivation" name="Motivation" type="string" />
      </extensionElements>
      <potentialOwner>
        <resourceAssignmentExpression>
          <formalExpression>management</formalExpression>
        </resourceAssignmentExpression>
      </potentialOwner>
    </userTask>
    <sequenceFlow id="flow2" sourceRef="handleRequest" targetRef="requestApprovedDecision" />

    <exclusiveGateway id="requestApprovedDecision" name="Request approved?" />
    <sequenceFlow id="flow3" sourceRef="requestApprovedDecision" targetRef="sendApprovalMail">
      <conditionExpression xsi:type="tFormalExpression">${vacationApproved == 'true'}</conditionExpression>
    </sequenceFlow>

    <task id="sendApprovalMail" name="Send confirmation e-mail" />
    <sequenceFlow id="flow4" sourceRef="sendApprovalMail" targetRef="theEnd1" />
    <endEvent id="theEnd1" />

    <sequenceFlow id="flow5" sourceRef="requestApprovedDecision" targetRef="adjustVacationRequestTask">
      <conditionExpression xsi:type="tFormalExpression">${vacationApproved == 'false'}</conditionExpression>
    </sequenceFlow>

    <userTask id="adjustVacationRequestTask" name="Adjust vacation request">
      <documentation>
        Your manager has disapproved your vacation request for ${numberOfDays} days.
        Reason: ${managerMotivation}
      </documentation>
      <extensionElements>
        <activiti:formProperty id="numberOfDays" name="Number of days" value="${numberOfDays}" type="long" required="true"/>
        <activiti:formProperty id="startDate" name="First day of holiday (dd-MM-yyy)" value="${startDate}" datePattern="dd-MM-yyyy hh:mm" type="date" required="true" />
        <activiti:formProperty id="vacationMotivation" name="Motivation" value="${vacationMotivation}" type="string" />
        <activiti:formProperty id="resendRequest" name="Resend vacation request to manager?" type="enum" required="true">
          <activiti:value id="true" name="Yes" />
          <activiti:value id="false" name="No" />
        </activiti:formProperty>
      </extensionElements>
      <humanPerformer>
        <resourceAssignmentExpression>
          <formalExpression>${employeeName}</formalExpression>
        </resourceAssignmentExpression>
      </humanPerformer>
    </userTask>
    <sequenceFlow id="flow6" sourceRef="adjustVacationRequestTask" targetRef="resendRequestDecision" />

    <exclusiveGateway id="resendRequestDecision" name="Resend request?" />
    <sequenceFlow id="flow7" sourceRef="resendRequestDecision" targetRef="handleRequest">
      <conditionExpression xsi:type="tFormalExpression">${resendRequest == 'true'}</conditionExpression>
    </sequenceFlow>

     <sequenceFlow id="flow8" sourceRef="resendRequestDecision" targetRef="theEnd2">
      <conditionExpression xsi:type="tFormalExpression">${resendRequest == 'false'}</conditionExpression>
    </sequenceFlow>
    <endEvent id="theEnd2" />

  </process>

</definitions>
----

To make this process known to the Activiti engine, we must 'deploy' it first. Deploying means that the engine will parse the BPMN 2.0 xml to something executable and a new database record will be added for each process definition included in the 'deployment'. This way, when the engine reboots, it will still know all of the 'deployed' processes:

[source,java,linenums]
----
ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();
RepositoryService repositoryService = processEngine.getRepositoryService();
repositoryService.createDeployment()
  .addClasspathResource("org/activiti/test/VacationRequest.bpmn20.xml")
  .deploy();

Log.info("Number of process definitions: " + repositoryService.createProcessDefinitionQuery().count());
----


Read more about deployment in the <<chDeployment,deployment chapter>>.


[[api.services.start.processinstance]]


==== Starting a process instance


After deploying the process definition to the Activiti engine, we can start new process instances from it. For each process definition, there are typically many process instances. The process definition is the 'blueprint', while a process instance is a runtime execution of it.

Everything related to the runtime state of processes can be found in the *RuntimeService*. There are various way to start a new process instance. In the following snippet, we use the key we defined in the process definition xml to start the process instance. We're also providing some process variables at process instance start, because the description of the first user task will use these in its expressions. Process variables are commonly used because they give meaning to the process instances for a certain process definition. Typically, the process variables are what make process instances differ from one another.

[source,java,linenums]
----
Map<String, Object> variables = new HashMap<String, Object>();
variables.put("employeeName", "Kermit");
variables.put("numberOfDays", new Integer(4));
variables.put("vacationMotivation", "I'm really tired!");

RuntimeService runtimeService = processEngine.getRuntimeService();
ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("vacationRequest", variables);

// Verify that we started a new process instance
Log.info("Number of process instances: " + runtimeService.createProcessInstanceQuery().count());

----


[[api.services.tasks]]


==== Completing tasks


When the process starts, the first step will be a user task. This is a step that must be performed by a user of the system. Typically, such a user will have an 'inbox of tasks' which lists all the tasks that need to be done by this user. Following code snippet shows how such a query might be performed:

[source,java,linenums]
----
// Fetch all tasks for the management group
TaskService taskService = processEngine.getTaskService();
List<Task> tasks = taskService.createTaskQuery().taskCandidateGroup("management").list();
for (Task task : tasks) {
  Log.info("Task available: " + task.getName());
}
----

To continue the process instance, we need to finish this task. For the Activiti engine, this means you need to +complete+ the task. Following snippet shows how this is done:

[source,java,linenums]
----
Task task = tasks.get(0);

Map<String, Object> taskVariables = new HashMap<String, Object>();
taskVariables.put("vacationApproved", "false");
taskVariables.put("managerMotivation", "We have a tight deadline!");
taskService.complete(task.getId(), taskVariables);
----


The process instance will now continue to the next step. In this example, the next step allows the employee to complete a form that adjusts their original vacation request. The employee can resubmit the vacation request which will cause the process to loop back to the start task.


[[api.services.suspend]]


==== Suspending and activating a process


It's possible to suspend a process definition. When a process definition is suspended, new process instance can't be created (an exception will be thrown). Suspending the process definition is done through the ++RepositoryService++:

[source,java,linenums]
----
repositoryService.suspendProcessDefinitionByKey("vacationRequest");
try {
  runtimeService.startProcessInstanceByKey("vacationRequest");
} catch (ActivitiException e) {
  e.printStackTrace();
}
----


To reactivate a process definition, simply call one of the +repositoryService.activateProcessDefinitionXXX+ methods.

It's also possible to suspend a process instance. When suspended, the process cannot
 be continued (e.g. completing a task throws an exception) and no jobs (such as timers) will executed. Suspending a process instance can be done by calling the +runtimeService.suspendProcessInstance+ method. Activating the process instance again is done by calling the +runtimeService.activateProcessInstanceXXX+ methods.

[[api.services]]


==== Further reading


We've barely scratched the surface in the previous sections regarding Activiti functionality. We will expand these sections further in the future with additional coverage of the Activiti API. Of course, as with any open source project, the best way to learn is to inspect the code and read the Javadocs!


[[queryAPI]]


=== Query API


There are two ways of querying data from the engine: The query API and native queries. The Query API allows to program completely typesafe queries with a fluent API. You can add various conditions to your queries (all of which are applied together as a logical AND) and precisely one ordering. The following code shows an example:

[source,java,linenums]
----
List<Task> tasks = taskService.createTaskQuery()
    .taskAssignee("kermit")
    .processVariableValueEquals("orderId", "0815")
    .orderByDueDate().asc()
    .list();
----

Sometimes you need more powerful queries, e.g. queries using an OR operator or restrictions you cannot express using the Query API. For these cases, we introduced native queries, which allow you to write your own SQL queries. The return type is defined by the Query object you use and the data is mapped into the correct objects, e.g. Task, ProcessInstance, Execution, etc.... Since the query will be fired at the database you have to use table and column names as they are defined in the database; this requires some knowledge about the internal data structure and it is recommended to use native queries with care. The table names can be retrieved via the API to keep the dependency as small as possible.

[source,java,linenums]
----
List<Task> tasks = taskService.createNativeTaskQuery()
  .sql("SELECT count(*) FROM " + managementService.getTableName(Task.class) + " T WHERE T.NAME_ = #{taskName}")
  .parameter("taskName", "gonzoTask")
  .list();

long count = taskService.createNativeTaskQuery()
  .sql("SELECT count(*) FROM " + managementService.getTableName(Task.class) + " T1, "
    + managementService.getTableName(VariableInstanceEntity.class) + " V1 WHERE V1.TASK_ID_ = T1.ID_")
  .count();
----

[[apiVariables]]

=== Variables

Every process instance needs and uses data to execute the steps it exists of. In Activiti, this data is called _variables_, which are stored in the database. Variables can be used in expressions (for example to select the correct outgoing sequence flow in an exclusive gateway), in java service tasks when calling external services (for example to provide the input or store the result of the service call), etc.

A process instance can have variables (called _process variables_), but also _executions_ (which are specific pointers to where the process is active) and user tasks can have variables. A process instance can have any number of variables. Each variable is stored in a row in the _ACT_RU_VARIABLE_ database table.

Any of the _startProcessInstanceXXX_ methods have an optional parameters to provide the variables when the process instance is created and started. For example, from the _RuntimeService_:

[source,java,linenums]
----
ProcessInstance startProcessInstanceByKey(String processDefinitionKey, Map<String, Object> variables);
----

Variables can be added during process execution. For example (_RuntimeService_):

[source,java,linenums]
----
void setVariable(String executionId, String variableName, Object value);
void setVariableLocal(String executionId, String variableName, Object value);
void setVariables(String executionId, Map<String, ? extends Object> variables);
void setVariablesLocal(String executionId, Map<String, ? extends Object> variables);
----

Note that variables can be set _local_ for a given execution (remember a process instance consists of a tree of executions). The variable will only be visible on that execution, and not higher in the tree of executions. This can be useful if data shouldn't be propagated to the process instance level, or the variable has a new value for a certain path in the process instance (for example when using parallel paths).

Variables can also be fetched again, as shown below. Note that similar methods exist on the _TaskService_. This means that tasks, like executions, can have local variables that are 'alive' just for the duration of the task.

[source,java,linenums]
----
Map<String, Object> getVariables(String executionId);
Map<String, Object> getVariablesLocal(String executionId);
Map<String, Object> getVariables(String executionId, Collection<String> variableNames);
Map<String, Object> getVariablesLocal(String executionId, Collection<String> variableNames);
Object getVariable(String executionId, String variableName);
<T> T getVariable(String executionId, String variableName, Class<T> variableClass);
----

Variables are often used in <<bpmnJavaServiceTask, Java delegates>>, <<apiExpressions, expressions>>, execution- or tasklisteners, scripts, etc. In those constructs, the current _execution_ or _task_ object is available and it can be used for variable setting and/or retrieval. The simplest methods are these:

[source,java,linenums]
----
execution.getVariables();
execution.getVariables(Collection<String> variableNames);
execution.getVariable(String variableName);

execution.setVariables(Map<String, object> variables);
execution.setVariable(String variableName, Object value);
----

Note that a variant with _local_ is also available for all of the above.

For historical (and backwards compatible reasons), when doing any of the calls above, behind the scenes actually *all* variables will be fetched from the database. This means that if you have 10 variables, and only get one through _getVariable("myVariable")_, behind the scenes the other 9 will be fetched and cached. This is not bad, as subsequent calls will not hit the database again.  For example, when your process definition has three sequential service tasks (and thus one database transaction), using one call to fetch all variables in the first service task might be better then fetching the variables needed in each service task separately. Note that this applies *both* for getting and setting variables.

Of course, when using a lot of variables or simply when you want tight control on the database query and traffic, this is not appropriate. Since Activiti 5.17, new methods have been introduced to give a tighter control on this, by adding in new methods that have an optional parameter that tells the engine whether or not behind the scenes all variables need to be fetched and cached:

[source,java,linenums]
----
Map<String, Object> getVariables(Collection<String> variableNames, boolean fetchAllVariables);
Object getVariable(String variableName, boolean fetchAllVariables);
void setVariable(String variableName, Object value, boolean fetchAllVariables);
----

When using _true_ for the parameter _fetchAllVariables_, the behaviour will be exactly as described above: when getting or setting a variable, all other variables will be fetched and cached.

However, when using _false_ as value, a specific query will be used and no other variables will be fetched nor cached. Only the value of the variable in question here will be cached for subsequent use.


[[apiExpressions]]


=== Expressions

Activiti uses UEL for expression-resolving. UEL stands for _Unified Expression Language_ and is part of the EE6 specification (see link:$$http://docs.oracle.com/javaee/6/tutorial/doc/gjddd.html$$[ the EE6 specification] for detailed information). To support all features of latest UEL spec on ALL environments, we use a modified version of JUEL.

Expressions can be used in for example <<bpmnJavaServiceTaskXML,Java Service tasks>>, <<executionListeners,Execution Listeners>>, <<taskListeners,Task Listeners>> and <<conditionalSequenceFlowXml,Conditional sequence flows>>. Although there are 2 types of expressions, value-expression and method-expression, Activiti abstracts  this so they can both be used where an +expression+ is needed.

* *Value expression*: resolves to a value. By default, all process variables are available to use. Also all spring-beans (if using Spring) are available to use in expressions. Some examples:

----
${myVar}
${myBean.myProperty}
----


* *Method expression*: invokes a method, with or without parameters. *When invoking a method without parameters, be sure to add empty parentheses after the method-name (as this distinguishes the expression from a value expression).* The passed parameters can be literal values or expressions that are resolved themselves. Examples:

----
${printer.print()}
${myBean.addNewOrder('orderName')}
${myBean.doSomething(myVar, execution)}
----

Note that these expressions support resolving primitives (incl. comparing them), beans, lists, arrays and maps.

On top of all process variables, there are a few default objects available to be used in expressions:

* ++execution++: The +DelegateExecution+ that holds additional information about the ongoing execution.
* ++task++: The +DelegateTask+ that holds additional information about the current Task. *Note: Only works in expressions evaluated from task listeners.*
* ++authenticatedUserId++: The id of the user that is currently authenticated. If no user is authenticated, the variable is not available.

For more concrete usage and examples, check out <<springExpressions,Expressions in Spring>>, <<bpmnJavaServiceTaskXML,Java Service tasks>>, <<executionListeners,Execution Listeners>>,  <<taskListeners,Task Listeners>> or <<conditionalSequenceFlowXml,Conditional sequence flows>>.


[[apiUnitTesting]]


=== Unit testing

Business processes are an integral part of software projects and they should be tested in the same way normal application logic is tested: with unit tests. Since Activiti is an embeddable Java engine, writing unit tests for business processes is as simple as writing regular unit tests.

Activiti supports both JUnit versions 3 and 4 styles of unit testing. In the JUnit 3 style, the +org.activiti.engine.test.ActivitiTestCase+ must be extended. This will make the ProcessEngine and the services available through protected member fields. In the +setup()+ of the test,  the processEngine will be initialized by default with the +activiti.cfg.xml+ resource on the classpath.  To specify a different configuration file, override the _getConfigurationResource()_ method. Process engines are cached statically over multiple unit tests when the configuration resource is the same.

By extending +ActivitiTestCase+, you can annotate test methods with +org.activiti.engine.test.Deployment+. Before the test is run, a resource file of the form +testClassName.testMethod.bpmn20.xml+ in the same package as the test class, will be deployed. At the end of the test, the deployment will be deleted, including all related process instances, tasks, etc. The +Deployment+ annotation also supports setting the resource location explicitly. See the class itself for more information.

Taking all that in account, a JUnit 3 style test looks as follows.

[source,java,linenums]
----
public class MyBusinessProcessTest extends ActivitiTestCase {

  @Deployment
  public void testSimpleProcess() {
    runtimeService.startProcessInstanceByKey("simpleProcess");

    Task task = taskService.createTaskQuery().singleResult();
    assertEquals("My Task", task.getName());

    taskService.complete(task.getId());
    assertEquals(0, runtimeService.createProcessInstanceQuery().count());
  }
}
----

To get the same functionality when using the JUnit 4 style of writing unit tests, the +org.activiti.engine.test.ActivitiRule+ Rule must be used. Through this rule, the process engine and services are available through getters. As with the +ActivitiTestCase+ (see above), including this +Rule+ will enable the use of the +org.activiti.engine.test.Deployment+ annotation (see above for an explanation of its use and configuration) and it will look for the default configuration file on the classpath. Process engines are statically cached over multiple unit tests when using the same configuration resource.

The following code snippet shows an example of using the JUnit 4 style of testing and the usage of the +ActivitiRule+.

[source,java,linenums]
----
public class MyBusinessProcessTest {

  @Rule
  public ActivitiRule activitiRule = new ActivitiRule();

  @Test
  @Deployment
  public void ruleUsageExample() {
    RuntimeService runtimeService = activitiRule.getRuntimeService();
    runtimeService.startProcessInstanceByKey("ruleUsage");

    TaskService taskService = activitiRule.getTaskService();
    Task task = taskService.createTaskQuery().singleResult();
    assertEquals("My Task", task.getName());

    taskService.complete(task.getId());
    assertEquals(0, runtimeService.createProcessInstanceQuery().count());
  }
}
----

[[apiDebuggingUnitTest]]


=== Debugging unit tests

When using the in-memory H2 database for unit tests, the following instructions allow to easily inspect the data in the Activiti database during a debugging session. The screenshots here are taken in Eclipse, but the mechanism should be similar for other IDEs.

Suppose we have put a _breakpoint_ somewhere in our unit test. In Eclipse this is done by double-clicking in the left border next to the code:

image::images/api.test.debug.breakpoint.png[align="center"]

If we now run the unit test in _debug_ mode (right-click in test class, select 'Run as' and then 'JUnit test'), the test execution halts at our breakpoint, where we can now inspect the variables of our test as shown in the right upper panel.

image::images/api.test.debug.view.png[align="center"]

To inspect the Activiti data, open up the _'Display'_ window (if this window isn't there, open Window->Show View->Other and select _Display_.) and type (code completion is available) +org.h2.tools.Server.createWebServer("-web").start()+

image::images/api.test.debug.start.h2.server.png[align="center"]

Select the line you've just typed and right-click on it. Now select 'Display' (or execute the shortcut instead of right-clicking)

image::images/api.test.debug.start.h2.server.2.png[align="center"]

Now open up a browser and go to link:$$http://localhost:8082$$[http://localhost:8082], and fill in the JDBC URL to the in-memory database (by default this is ++jdbc:h2:mem:activiti++), and hit the connect button.

image::images/api.test.debug.h2.login.png[align="center"]

You can now see the Activiti data and use it to understand how and why your unit test is executing your process in a certain way.

image::images/api.test.debug.h2.tables.png[align="center"]



[[apiProcessEngineInWebApp]]


=== The process engine in a web application

The +ProcessEngine+ is a thread-safe class and can easily be shared among multiple threads. In a web application, this means it is possible to create the process engine once when the container boots and shut down the engine when the container goes down.

The following code snippet shows how you can write a simple +ServletContextListener+ to initialize and destroy process engines in a plain Servlet environment:

[source,java,linenums]
----
public class ProcessEnginesServletContextListener implements ServletContextListener {

  public void contextInitialized(ServletContextEvent servletContextEvent) {
    ProcessEngines.init();
  }

  public void contextDestroyed(ServletContextEvent servletContextEvent) {
    ProcessEngines.destroy();
  }

}
----

The +contextInitialized+ method will delegate to +ProcessEngines.init()+. That will look for +activiti.cfg.xml+ resource files on the classpath, and create a +ProcessEngine+ for the given configurations (e.g. multiple jars with a configuration file). If you have multiple such resource files on the classpath, make sure they all have different names. When the process engine is needed, it can be fetched using

[source,java,linenums]
----
ProcessEngines.getDefaultProcessEngine()
----

or

[source,java,linenums]
----
ProcessEngines.getProcessEngine("myName");
----

Of course, it is also possible to use any of the variants of creating a process engine,
as described in the <<configuration,configuration section>>.


The +contextDestroyed+ method of the context-listener delegates to +ProcessEngines.destroy()+. That will properly close all initialized process engines.
