== 配置

[[configuration]]

=== 创建ProcessEngine


Activiti流程引擎通过名为++activiti.cfg.xml++的XML文件进行配置。请注意这种方式与<<springintegration,使用Spring创建流程引擎>>**不**一样。

获取++ProcessEngine++，最简单的方式是使用++org.activiti.engine.ProcessEngines++类：

[source,java,linenums]
----
ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine()
----

这样会从classpath寻找++activiti.cfg.xml++，并用这个文件中的配置构造引擎。下面的代码展示了一个配置的例子。后续章节会对配置参数进行详细介绍。

[source,xml,linenums]
----
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd">

  <bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration">

    <property name="jdbcUrl" value="jdbc:h2:mem:activiti;DB_CLOSE_DELAY=1000" />
    <property name="jdbcDriver" value="org.h2.Driver" />
    <property name="jdbcUsername" value="sa" />
    <property name="jdbcPassword" value="" />

    <property name="databaseSchemaUpdate" value="true" />

    <property name="jobExecutorActivate" value="false" />
    <property name="asyncExecutorEnabled" value="true" />
    <property name="asyncExecutorActivate" value="false" />

    <property name="mailServerHost" value="mail.my-corp.com" />
    <property name="mailServerPort" value="5025" />
  </bean>

</beans>
----

请注意这个配置XML文件实际上是一个Spring配置文件。**但这并不意味着Activiti只能用于Spring环境！**我们只是简单利用Spring内部的解析与依赖注入功能来构造引擎。

也可以通过编程方式使用配置文件，来构造ProcessEngineConfiguration对象。也可以使用不同的bean id(例如第3行)。

[source,java,linenums]
----
ProcessEngineConfiguration.createProcessEngineConfigurationFromResourceDefault();
ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(String resource);
ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(String resource, String beanName);
ProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(InputStream inputStream);
ProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(InputStream inputStream, String beanName);
----


也可以不使用配置文件，基于默认创建配置（参考<<configurationClasses,不同的支持类>>获得更多信息）。

[source,java,linenums]
----
ProcessEngineConfiguration.createStandaloneProcessEngineConfiguration();
ProcessEngineConfiguration.createStandaloneInMemProcessEngineConfiguration();
----

所有的++ProcessEngineConfiguration.createXXX()++方法都返回++ProcessEngineConfiguration++，并可以继续按需调整。调用++buildProcessEngine()++后，生成一个++ProcessEngine++：

[source,java,linenums]
----
ProcessEngine processEngine = ProcessEngineConfiguration.createStandaloneInMemProcessEngineConfiguration()
  .setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_FALSE)
  .setJdbcUrl("jdbc:h2:mem:my-own-db;DB_CLOSE_DELAY=1000")
  .setAsyncExecutorEnabled(true)
  .setAsyncExecutorActivate(false)
  .buildProcessEngine();
----



[[configurationRoot]]


=== ProcessEngineConfiguration bean


++activiti.cfg.xml++文件中必须包含一个id为$$'processEngineConfiguration'$$的bean。

[source,xml,linenums]
----
 <bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration">
----


这个bean被用于构建++ProcessEngine++。有多个类可以用于定义++processEngineConfiguration++。这些类用于不同的环境，并各自设置一些默认值。最佳实践是选择（最）匹配你环境的类，以便减少配置引擎需要的参数。下面列出目前可以使用的类（后续版本会提供更多）：[[configurationClasses]]

* *org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration*：流程引擎独立运行。Activiti自行处理事务。在默认情况下，数据库检查只在引擎启动时进行（如果Activiti表结构不存在或表结构版本不对，会抛出异常）。
* *org.activiti.engine.impl.cfg.StandaloneInMemProcessEngineConfiguration*：这是一个便于使用单元测试的类。Activiti自行处理事务。默认使用H2内存数据库。数据库会在引擎启动时创建，并在引擎关闭时删除。使用这个类时，很可能不需要更多的配置（除了使用任务执行器或邮件功能等时）。
* *org.activiti.spring.SpringProcessEngineConfiguration*：在流程引擎处于Spring环境时使用。查看<<springintegration,Spring集成章节>>获得更多信息。
* *org.activiti.engine.impl.cfg.JtaProcessEngineConfiguration*：用于引擎独立运行，并使用JTA事务的情况。


[[databaseConfiguration]]

=== 数据库配置


有两种方式配置Activiti引擎使用的数据库。第一种方式是定义数据库的JDBC参数：

* *jdbcUrl*: 数据库的JDBC URL。
* *jdbcDriver*: 特定数据库类型的驱动实现。
* *jdbcUsername*: 用于连接数据库的用户名。
* *jdbcPassword*: 用于连接数据库的密码。

通过提供的JDBC参数构造的数据源，使用默认的link:$$http://www.mybatis.org/$$[MyBatis]连接池设置。可用下列属性调整这个连接池（来自MyBatis文档）：

* *jdbcMaxActiveConnections*: 连接池能够容纳的最大活动连接数量。默认值为10.
* *jdbcMaxIdleConnections*: 连接池能够容纳的最大空闲连接数量。
* *jdbcMaxCheckoutTime*: 连接从连接池“取出”后，被强制返回前的最大时间间隔，单位为毫秒。默认值为20000（20秒）。
* *jdbcMaxWaitTime*: 这是一个底层设置，在连接池获取连接的时间异常长时，打印日志并尝试重新获取连接（避免连接池配置错误造成的永久沉默失败。默认值为20000（20秒）。

数据库配置示例：

[source,xml,linenums]
----
<property name="jdbcUrl" value="jdbc:h2:mem:activiti;DB_CLOSE_DELAY=1000" />
<property name="jdbcDriver" value="org.h2.Driver" />
<property name="jdbcUsername" value="sa" />
<property name="jdbcPassword" value="" />
----


也可以使用++javax.sql.DataSource++的实现（例如来自link:$$http://commons.apache.org/dbcp/$$[Apache Commons]的DBCP）：

[source,xml,linenums]
----
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" >
  <property name="driverClassName" value="com.mysql.jdbc.Driver" />
  <property name="url" value="jdbc:mysql://localhost:3306/activiti" />
  <property name="username" value="activiti" />
  <property name="password" value="activiti" />
  <property name="defaultAutoCommit" value="false" />
</bean>

<bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration">

    <property name="dataSource" ref="dataSource" />
    ...

----


请注意Activiti发布时不包括用于定义数据源的库。需要自行把库（例如来自DBCP）放在你的classpath中。

无论使用JDBC还是数据源方式配置，下列参数都可以使用：

* *databaseType*: 通常不需要专门设置这个参数，因为它可以从数据库连接信息中自动分析得出。只有在自动检测失败时才需要设置。可用值：{h2, mysql, oracle, postgres, mssql, db2}。**不使用默认的H2数据库时需要设置这个参数。**这个选项会决定创建、删除与查询时使用的脚本。查看<<supporteddatabases,“支持的数据库”章节>>了解我们支持哪些类型的数据库。
* *databaseSchemaUpdate*: 用于设置流程引擎启动关闭时使用的数据库表结构控制策略。
** +false+ (默认): 当引擎启动时，检查数据库表结构的版本是否匹配库文件版本。版本不匹配时抛出异常。
** ++true++: 构建引擎时，检查并在需要时更新表结构。表结构不存在则会创建。
** ++create-drop++: 引擎创建时创建表结构，并在引擎关闭时删除表结构。


[[jndiDatasourceConfig]]

=== JNDI数据源配置


默认情况下，Activiti的数据库配置保存在每个web应用WEB-INF/classes目录下的db.properties文件中。有时这样并不合适，因为这需要用户修改Activiti源码中的db.properties文件并重新编译war包，或者在部署后解开war包并修改db.properties文件。

通过使用JNDI（Java Naming and Directory Interface，Java命名和目录接口）获取数据库连接，连接完全由Servlet容器管理，配置也可以在war部署之外进行管理。同时也比db.properties提供了更多控制连接的参数。


[[jndi_usage]]

==== Usage


要将Activiti Explorer与Activiti Rest web应用从db.properties配置切换至JNDI数据源配置，请打开Spring主配置文件(activiti-webapp-explorer2/src/main/webapp/WEB-INF/activiti-standalone-context.xml与activiti-webapp-rest2/src/main/resources/activiti-context.xml)，并删除名为"dbProperties" 与"dataSource"的bean。然后增加下列bean：

[source,xml,linenums]
----
<bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean">
    <property name="jndiName" value="java:comp/env/jdbc/activitiDB"/>
</bean>

----

接下来我们需要新增context.xml文件，其中包含默认的H2配置。也可以用你自己的的JNDI配置覆盖它。对于Activiti Explorer，用下列文件替换activiti-webapp-explorer2/src/main/webapp/META-INF/context.xml：

[source,xml,linenums]
----
<Context antiJARLocking="true" path="/activiti-explorer2">
    <Resource auth="Container"
              name="jdbc/activitiDB"
              type="javax.sql.DataSource"
              scope="Shareable"
              description="JDBC DataSource"
              url="jdbc:h2:mem:activiti;DB_CLOSE_DELAY=1000"
              driverClassName="org.h2.Driver"
              username="sa"
              password=""
              defaultAutoCommit="false"
              initialSize="5"
              maxWait="5000"
              maxActive="120"
              maxIdle="5"/>
</Context>
----

对于Activiti REST web应用，新增activiti-webapp-rest2/src/main/webapp/META-INF/context.xml文件，包含下列配置：

[source,xml,linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
<Context antiJARLocking="true" path="/activiti-rest2">
    <Resource auth="Container"
              name="jdbc/activitiDB"
              type="javax.sql.DataSource"
              scope="Shareable"
              description="JDBC DataSource"
              url="jdbc:h2:mem:activiti;DB_CLOSE_DELAY=-1"
              driverClassName="org.h2.Driver"
              username="sa"
              password=""
              defaultAutoCommit="false"
              initialSize="5"
              maxWait="5000"
              maxActive="120"
              maxIdle="5"/>
</Context>
----

可选步骤，可以删除Activiti Explorer与Activiti REST web应用中无用的db.properties文件。


[[jndi_configuration]]

==== 配置


根据你使用的servlet容器应用不同，配置JNDI数据源的方式也不同。下面的介绍用于Tomcat，对于其他容器应用，请参考对应的文档。

Tomcat的JNDI资源配置在$CATALINA_BASE/conf/[enginename]/[hostname]/[warname].xml (对于Activiti Explorer通常会是$CATALINA_BASE/conf/Catalina/localhost/activiti-explorer.xml)。当应用第一次部署时，默认会从Activiti war包中复制context.xml。所以如果存在这个文件则需要替换。例如，如果需要将JNDI资源修改为应用连接MySQL而不是H2，按照下列修改文件：

[source,xml,linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
    <Context antiJARLocking="true" path="/activiti-explorer2">
        <Resource auth="Container"
            name="jdbc/activitiDB"
            type="javax.sql.DataSource"
            description="JDBC DataSource"
            url="jdbc:mysql://localhost:3306/activiti"
            driverClassName="com.mysql.jdbc.Driver"
            username="sa"
            password=""
            defaultAutoCommit="false"
            initialSize="5"
            maxWait="5000"
            maxActive="120"
            maxIdle="5"/>
        </Context>
----


[[supporteddatabases]]


=== 支持的数据库

下面列出Activiti指定的数据库类型（区分大小写！）。

[[databaseTypes]]
[options="header"]
|===============
|Activiti数据库类型|示例JDBC URL|备注
|h2|jdbc:h2:tcp://localhost/activiti|默认配置的数据库
|mysql|jdbc:mysql://localhost:3306/activiti?autoReconnect=true|已使用mysql-connector-java数据库驱动测试
|oracle|jdbc:oracle:thin:@localhost:1521:xe|
|postgres|jdbc:postgresql://localhost:5432/activiti|
|db2|jdbc:db2://localhost:50000/activiti|
|mssql|jdbc:sqlserver://localhost:1433;databaseName=activiti (jdbc.driver=com.microsoft.sqlserver.jdbc.SQLServerDriver) _OR_ jdbc:jtds:sqlserver://localhost:1433/activiti (jdbc.driver=net.sourceforge.jtds.jdbc.Driver)|已使用Microsoft JDBC Driver 4.0 (sqljdbc4.jar)与JTDS Driver测试
|===============


[[creatingDatabaseTable]]

=== 创建数据库表

在你的数据库中创建标的最简单方法是：

* 在classpath中增加activiti-engine jar
* 增加合适的数据库驱动
* 在classpath中增加Activiti配置文件(__activiti.cfg.xml__)，指向你的数据库(参考<<databaseConfiguration,数据库配置>>)
* 执行__DbSchemaCreate__类的main方法

然而，通常只有数据库管理员可以在数据库中执行DDL语句，在生产环境中这也是最明智的选择。DDL的SQL脚本可以在Activiti下载页面或Activiti发布目录中找到，位于++database++子目录。引擎jar (__activiti-engine-x.jar__)的__org/activiti/db/create__包中也有一份(__drop__目录存放删除脚本)。SQL文件的格式为：

----
activiti.{db}.{create|drop}.{type}.sql
----

__db__为<<supporteddatabases,支持的数据库>>，而__type__为

* *engine:* 引擎执行所需的表，必需。
* *identity:* 存储用户、组、用户与组关系的表。这些表是可选的，但在使用引擎自带的默认认证管理时需要使用。
* *history:* 存储历史与审计信息的表。当历史级别设置为__none__时不需要。请注意不使用这些表会导致部分使用历史数据的功能失效（如任务备注）。

**MySQL用户请注意：**低于5.6.4的MySQL版本不支持timestamps或包含毫秒精度的日期。更糟的是部分版本会在创建类似的列时抛出异常，而另一些版本则不会。当使用自动创建/升级时，引擎在执行时会自动修改DDL语句。当使用DDL文件方式建表时，可以使用通用版本，或使用文件名包含__mysql55__的特殊版本（用于5.6.4以下的任何版本）。特殊版本的文件中不会使用毫秒精度的列类型。

具体地说，对于MySQL的版本：

* *<5.6:* 不支持毫秒精度。可以使用DDL文件（使用包含__mysql55__的文件）。No millisecond precision available. DDL files available (look for files containing )。可以使用自动创建/升级。
* *5.6.0 - 5.6.3:* 不支持毫秒精度。**不**可以使用自动创建/升级。建议升级为较新版本的数据库。如果确实需要，可以使用包含__mysql55__的DDL文件。
* *5.6.4+:* 支持毫秒精度。可以使用DDL文件（默认的包含__mysql__的文件）。可以使用自动创建/升级。


请注意在Activiti表已经创建/升级后，更新MySQL数据库，则需要手工修改列类型！


[[database.tables.explained]]


=== Database table names explained

The database names of Activiti all start with *ACT_*. The second part is a two-character identification of the use case of the table. This use case will also roughly match the service API.

* *ACT_RE_**: 'RE' stands for +repository+. Tables with this prefix contain 'static' information such as process definitions and process resources (images, rules, etc.).
* *ACT_RU_**: 'RU' stands for +runtime+. These are the runtime tables that contain the runtime data of process instances, user tasks, variables, jobs, etc. Activiti only stores the runtime data during process instance execution, and removes the records when a process instance ends. This keeps the runtime tables small and fast.
* *ACT_ID_**: 'ID' stands for +identity+. These tables contain identity information, such as users, groups, etc.
* *ACT_HI_**: 'HI' stands for +history+. These are the tables that contain historic data, such as past process instances, variables, tasks, etc.
* *ACT_GE_**: +general+ data, which is used in various use cases.


[[databaseUpgrade]]


=== Database upgrade

Make sure you make a backup of your database (using your database backup capabilities) before you run an upgrade.


By default, a version check will be performed each time a process engine is created. This typically happens once at boot time of your application or of the Activiti webapps. If the Activiti library notices a difference between the library version and the version of the Activiti database tables, then an exception is thrown.


To upgrade, you have to start with putting the following configuration property in your activiti.cfg.xml configuration file:

[source,xml,linenums]
----
<beans >

  <bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration">
    <!-- ... -->
    <property name="databaseSchemaUpdate" value="true" />
    <!-- ... -->
  </bean>

</beans>
----

*Also, include a suitable database driver for your database to the classpath.* Upgrade the Activiti libraries in your application. Or start up a new version of Activiti and point it to a database that contains an older version.  With +databaseSchemaUpdate+ set to +true+, Activiti will automatically upgrade the DB schema to the newer version the first time when it notices that libraries and DB schema are out of sync.

*As an alternative you can also run the upgrade DDL statements.* It's also possible to run the upgrade database scripts, available on the Activiti downloads page.

[[jobExecutorConfiguration]]

=== Job Executor and Async Executor (since version 5.17.0)

Starting from version 5.17.0 Activiti provides an Async executor in addition to the Job Executor. The Async executor is a more performant and more database friendly way of executing asynchronous jobs in the Activiti Engine.
It's therefore recommended to switch to the Async executor. By default the old job executor is still used. More information can be found in the advanced section of the user guide.

Moreover, if running under Java EE 7, JSR-236 compliant +ManagedJobExecutor+ and +ManagedAsyncJobExecutor+ can be used for letting the container manage the threads. In order to enable them, the thread factory should be passed in the configuration as follows:

[source,xml,linenums]
----
<bean id="threadFactory" class="org.springframework.jndi.JndiObjectFactoryBean">
   <property name="jndiName" value="java:jboss/ee/concurrency/factory/default" />
</bean>

<bean id="customJobExecutor" class="org.activiti.engine.impl.jobexecutor.ManagedJobExecutor">
   <!-- ... -->
   <property name="threadFactory" ref="threadFactory" />
   <!-- ... -->
</bean>
----

Both managed implementations fall back to their default counterparts if the thread factory is not specified.

=== Job executor activation

The +JobExecutor+ is a component that manages a couple of threads to fire timers (and later also asynchronous messages). For unit testing scenarios, it is cumbersome to work with multiple threads. Therefore the API allows to query for (++ManagementService.createJobQuery++) and execute jobs (++ManagementService.executeJob++) through the API so that job execution can be controlled from within a unit test.  To avoid interference by the job executor, it can be turned off.

By default, the +JobExecutor+ is activated when the process engine boots. Specify

[source,xml,linenums]
----
<property name="jobExecutorActivate" value="false" />
----

when you don't want the +JobExecutor+ to be activated upon booting the process engine.

=== Async executor activation

The +AsyncExecutor+ is a component that manages a thread pool to fire timers and other asynchronous tasks.

By default, the +AsyncExecutor+ is not enabled and the JobExecutor is used due to legacy reasons. It's however recommended to use the new AsyncExecutor instead.
This can be done by defining two properties

[source,xml,linenums]
----
<property name="asyncExecutorEnabled" value="true" />
<property name="asyncExecutorActivate" value="true" />
----

The asyncExecutorEnabled property is to enable the Async executor instead of the old Job executor.
The second property asyncExecutorActivate instructs the Activiti Engine to startup the Async executor thread pool at startup. 

[[mailServerConfiguration]]


=== Mail server configuration

Configuring a mail server is optional. Activiti supports sending e-mails in business processes. To actually send an e-mail, a valid SMTP mail server configuration is required. See the <<bpmnEmailTaskServerConfiguration,e-mail task>> for the configuration options.


[[historyConfiguration]]


=== History configuration

Customizing the configuration of history storage is optional. This allows you to tweak settings that influence the <<history,history capabilities>> of the engine. See <<historyConfig,history configuration>> for more details.

[source,xml,linenums]
----
<property name="history" value="audit" />
----


[[exposingConfigurationBeans]]


=== Exposing configuration beans in expressions and scripts

By default, all beans that you specify in the +activiti.cfg.xml+ configuration or in your own Spring configuration file are available to expressions and in the scripts. If you want to limit the visibility of beans in your configuration file, you can configure a property called +beans+ in your process engine configuration. The beans property in +ProcessEngineConfiguration+ is a map. When you specify that property, only beans specified in that map will be visible to expressions and scripts.  The exposed beans will be exposed with the names as you specify in that map.


[[processDefinitionCacheConfiguration]]


=== Deployment cache configuration

All process definition are cached (after they're parsed) to avoid hitting the database every time a process definition is needed and because process definition data doesn't change. By default, there is no limit on this cache. To limit the process definition cache, add following property

[source,xml,linenums]
----
<property name="processDefinitionCacheLimit" value="10" />
----


Setting this property will swap the default hashmap cache with a LRU cache that has the provided hard limit. Of course, the 'best' value of this property depends on the total amount of process definitions stored and the number of process definitions actually used at runtime by all the runtime process instances.

You can also inject your own cache implementation. This must be a bean that implements the org.activiti.engine.impl.persistence.deploy.DeploymentCache interface:

[source,xml,linenums]
----
<property name="processDefinitionCache">
  <bean class="org.activiti.MyCache" />
</property>
----


There is a similar property called +knowledgeBaseCacheLimit+ and +knowledgeBaseCache+ for configuring the rules cache. This is only needed when you use the rules task in your processes.


[[loggingConfiguration]]


=== Logging

As of Activiti 5.12, SLF4J is used as logging framework, replacing the previous used java.util.logging. All logging (activiti, spring, mybatis, ...) is routed through SLF4J and allows for selecting the logging-implementation of your choice.

*By default no SFL4J-binding jar is present in the activiti-engine dependencies, this should be added in your project in order to use the logging framework of your choice.* If no implementation jar is added, SLF4J will use a NOP-logger, not logging anything at all, other than a warning that nothing will be logged. For more info on these bindings link:$$http://www.slf4j.org/codes.html#StaticLoggerBinder$$[http://www.slf4j.org/codes.html#StaticLoggerBinder].

With Maven, add for example a dependency like this (here using log4j), note that you still need to add a version:

[source,xml,linenums]
----
<dependency>
  <groupId>org.slf4j</groupId>
  <artifactId>slf4j-log4j12</artifactId>
</dependency>
----


The activiti-explorer and activiti-rest webapps are configured to use Log4j-binding. Log4j is also used when running the tests for all the activiti-* modules.


*Important note when using a container with commons-logging in the classpath:* In order to route the spring-logging through SLF4J, a bridge is used (see link:$$http://www.slf4j.org/legacy.html#jclOverSLF4J$$[http://www.slf4j.org/legacy.html#jclOverSLF4J]). If your container provides a commons-logging implementation, please follow directions on this page: link:$$http://www.slf4j.org/codes.html#release$$[http://www.slf4j.org/codes.html#release] to ensure stability.

Example when using Maven (version omitted):

[source,xml,linenums]
----
<dependency>
  <groupId>org.slf4j</groupId>
  <artifactId>jcl-over-slf4j</artifactId>
</dependency>
----


[[MDC]]


=== Mapped Diagnostic Contexts


As of version 5.13, Activiti supports Mapped Diagnostic Contexts feature of sl4j. These basic information are passed to the underlying logger along with what is going to be logged:

* processDefinition Id as mdcProcessDefinitionID
* processInstance Id as mdcProcessInstanceID
* execution Id as mdcExecutionId

None of these information are logged by default. The logger can be configured to show them in desired format, extra to the usual logged messages. For example in log4j the following sample layout definition  causes the logger to show the above mentioned information:

[source,properties,linenums]
----
 log4j.appender.consoleAppender.layout.ConversionPattern=ProcessDefinitionId=%X{mdcProcessDefinitionID} executionId=%X{mdcExecutionId} mdcProcessInstanceID=%X{mdcProcessInstanceID} mdcBusinessKey=%X{mdcBusinessKey} %m%n
----

This is useful where the systems are mission critical and logs should be seriously checked,  by means of a log analyzer for example.


[[eventDispatcher]]


=== Event handlers

An event mechanism has been introduced in Activiti 5.15. It allows you to get notified when various events occur within the engine. Take a look at <<eventDispatcherEventTypes,all supported event types>> for an overview of the events available.

It's possible to register a listener for certain types of events as opposed to getting notified when any type of event is dispatched. You can either add engine-wide event listeners <<eventDispatcherConfiguration,through the configuration>>, add engine-wide event listeners <<eventDispatcherConfigurationRuntime,at runtime using the API>> or add event-listeners to <<eventDispatcherConfigurationProcessDefinition,specific process definitions in the BPMN XML>>.


All events dispatched are a subtype of +org.activiti.engine.delegate.event.ActivitiEvent+. The event exposes (if available) the +type+, +executionId+, +processInstanceId+ and +processDefinitionId+. Certain events contain additional context related to the event that occurred, additional information about additional payload can be found in the list of <<eventDispatcherEventTypes,all supported event types>>.

[[eventDispatcherListener]]


==== Event listener implementation

The only requirement an event-listener has, is to implement +org.activiti.engine.delegate.event.ActivitiEventListener+. Below is an example implementation of a listener, which outputs all events received to the standard-out, with exception of events related to job-execution:

[source,java,linenums]
----
public class MyEventListener implements ActivitiEventListener {

  @Override
  public void onEvent(ActivitiEvent event) {
    switch (event.getType()) {

      case JOB_EXECUTION_SUCCESS:
        System.out.println("A job well done!");
        break;

      case JOB_EXECUTION_FAILURE:
        System.out.println("A job has failed...");
        break;

      default:
        System.out.println("Event received: " + event.getType());
    }
  }

  @Override
  public boolean isFailOnException() {
    // The logic in the onEvent method of this listener is not critical, exceptions
    // can be ignored if logging fails...
    return false;
  }
}
----


The +isFailOnException()+ method determines the behaviour in case the +onEvent(..)+ method throws an exception when an event is dispatched. In case +false+ is returned, the exception is ignored. When +true+ is returned, the exception is not ignored and bubbles up, effectively failing the current ongoing command. In case the event was part of an API-call (or any other transactional operation, e.g. job-execution), the transaction will be rolled back. In case the behaviour in the event-listener is not business-critical, it's recommended to return +false+.

There are a few base implementations provided by Activiti to facilitate common use cases of event-listeners. These can be used as base-class or as an example listener implementation:

* *org.activiti.engine.delegate.event.BaseEntityEventListener*: An event-listener base-class that can be used to listen for entity-related events for a specific type of entity or for all entities. It hides away the type-checking and offers 4 methods that should be overridden: +onCreate(..)+, +onUpdate(..)+ and +onDelete(..)+ when an entity is created, updated or deleted. For all other entity-related events, the ++onEntityEvent(..) ++is called.



[[eventDispatcherConfiguration]]


==== Configuration and setup

If an event-listener is configured in the process engine configuration, it will be active when the process engine starts and will remain active after subsequent reboots of the engine.

The property +eventListeners+ expects a list of +org.activiti.engine.delegate.event.ActivitiEventListener+ instances. As usual, you can either declare an inline bean definition or use a +ref+ to an existing bean instead. The snippet below adds an event-listener to the configuration that is notified when any event is dispatched, regardless of its type:

[source,xml,linenums]
----
<bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration">
    ...
    <property name="eventListeners">
      <list>
         <bean class="org.activiti.engine.example.MyEventListener" />
      </list>
    </property>
</bean>
----

To get notified when certain types of events get dispatched, use the +typedEventListeners+ property, which expects a map. The key of a map-entry is a comma-separated list of event-names (or a single event-name). The value of a map-entry is a list of +org.activiti.engine.delegate.event.ActivitiEventListener+ instances. The snippet below adds an event-listener to the configuration, that is notified when a job execution was successful or failed:

[source,xml,linenums]
----
<bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration">
    ...
    <property name="typedEventListeners">
      <map>
        <entry key="JOB_EXECUTION_SUCCESS,JOB_EXECUTION_FAILURE" >
          <list>
            <bean class="org.activiti.engine.example.MyJobEventListener" />
          </list>
        </entry>
      </map>
    </property>
</bean>
----


The order of dispatching events is determined on the order the listeners were added. First, all normal event-listeners are called (++eventListeners++ property) in the order they are defined in the ++list++. After that, all typed event listeners (++typedEventListeners++ properties) are called, if an event of the right type is dispatched.


[[eventDispatcherConfigurationRuntime]]

==== Adding listeners at runtime

It's possible to add and remove additional event-listeners to the engine by using the API (++RuntimeService++):

[source,java,linenums]
----

/**
 * Adds an event-listener which will be notified of ALL events by the dispatcher.
 * @param listenerToAdd the listener to add
 */
void addEventListener(ActivitiEventListener listenerToAdd);

/**
 * Adds an event-listener which will only be notified when an event occurs, which type is in the given types.
 * @param listenerToAdd the listener to add
 * @param types types of events the listener should be notified for
 */
void addEventListener(ActivitiEventListener listenerToAdd, ActivitiEventType... types);

/**
 * Removes the given listener from this dispatcher. The listener will no longer be notified,
 * regardless of the type(s) it was registered for in the first place.
 * @param listenerToRemove listener to remove
 */
 void removeEventListener(ActivitiEventListener listenerToRemove);
----

Please note that the listeners added at runtime *are not retained when the engine is rebooted.*


[[eventDispatcherConfigurationProcessDefinition]]


==== Adding listeners to process definitions

It's possible to add listeners to a specific process-definition. The listeners will only be called for events related to the process definition and to all events related to process instances that are started with that specific process definition. The listener implementations can be defined using a fully qualified classname, an expression that resolves to a bean that implements the listener interface or can be configured to throw a message/signal/error BPMN event.


===== Listeners executing user-defined logic

The snippet below adds 2 listeners to a process-definition. The first listener will receive events of any type, with a listener implementation based on a fully-qualified class name. The second listener is only notified when a job is successfully executed or when it failed, using a listener that has been defined in the +beans+ property of the process engine configuration.

[source,xml,linenums]
----
<process id="testEventListeners">
  <extensionElements>
    <activiti:eventListener class="org.activiti.engine.test.MyEventListener" />
    <activiti:eventListener delegateExpression="${testEventListener}" events="JOB_EXECUTION_SUCCESS,JOB_EXECUTION_FAILURE" />
  </extensionElements>

  ...

</process>
----

For events related to entities, it's also possible to add listeners to a process-definition that get only notified when entity-events occur for a certain entity type. The snippet below shows how this can be achieved. It can be used along for ALL entity-events (first example) or for specific event types only (second example).

[source,xml,linenums]
----
<process id="testEventListeners">
  <extensionElements>
    <activiti:eventListener class="org.activiti.engine.test.MyEventListener" entityType="task" />
    <activiti:eventListener delegateExpression="${testEventListener}" events="ENTITY_CREATED" entityType="task" />
  </extensionElements>

  ...

</process>
----

Supported values for the +entityType+ are: +attachment+, +comment+, +execution+, ++identity-link++, ++job++, ++process-instance++, ++process-definition++, ++task++.



===== Listeners throwing BPMN events

<<experimental, [EXPERIMENTAL] >>


Another way of handling events being dispatched is to throw a BPMN event. Please bear in mind that it only makes sense to throw BPMN-events with certain kinds of Activiti event types. For example, throwing a BPMN event when the process-instance is deleted will result in an error. The snippet below shows how to throw a signal inside process-instance, throw a signal to an external process (global), throw a message-event inside the process-instance and throw an error-event inside the process-instance. Instead of using the +class+ or +delegateExpression+, the attribute +throwEvent+ is used, along with an additional attribute, specific to the type of event being thrown.

[source,xml,linenums]
----
<process id="testEventListeners">
  <extensionElements>
    <activiti:eventListener throwEvent="signal" signalName="My signal" events="TASK_ASSIGNED" />
  </extensionElements>
</process>
----

[source,xml,linenums]
----
<process id="testEventListeners">
  <extensionElements>
    <activiti:eventListener throwEvent="globalSignal" signalName="My signal" events="TASK_ASSIGNED" />
  </extensionElements>
</process>
----


[source,xml,linenums]
----
<process id="testEventListeners">
  <extensionElements>
    <activiti:eventListener throwEvent="message" messageName="My message" events="TASK_ASSIGNED" />
  </extensionElements>
</process>
----

[source,xml,linenums]
----
<process id="testEventListeners">
  <extensionElements>
    <activiti:eventListener throwEvent="error" errorCode="123" events="TASK_ASSIGNED" />
  </extensionElements>
</process>
----

If additional logic is needed to decide whether or not to throw the BPMN-event, it's possible to extend the listener-classes provided by Activiti. By overriding the +isValidEvent(ActivitiEvent event) in your subclass, the BPMN-event throwing can be prevented. The classes involved are +org.activiti.engine.test.api.event.SignalThrowingEventListenerTest+, +org.activiti.engine.impl.bpmn.helper.MessageThrowingEventListener+ and +org.activiti.engine.impl.bpmn.helper.ErrorThrowingEventListener+.


===== Notes on listeners on a process-definition

* Event-listeners can only be declared on the +process+ element, as a child-element of the +extensionElements+. Listeners cannot be defined on individual activities in the process.
* Expressions used in the +delegateExpression+ do not have access to the execution-context, as other expressions (e.g. in gateways) have. They can only reference beans defined in the +beans+ property of the process engine configuration or when using spring (and the beans property is absent) to any spring-bean that implements the listener interface.
* When using the +class+ attribute of a listener, there will only be a single instance of that class created. Make sure the listener implementations do not rely on member-fields or ensure safe usage from multiple threads/contexts.
* When an illegal event-type is used in the +events+ attribute or illegal +throwEvent+ value is used, an exception will be thrown when the process-definition is deployed (effectively failing the deployment). When an illegal value for +class+ or +delegateExecution+ is supplied (either a nonexistent class, a nonexistent bean reference or a delegate not implementing listener interface), an exception will be thrown when the process is started (or when the first valid event for that process-definition is dispatched to the listener). Make sure the referenced classes are on the classpath and that the expressions resolve to a valid instance.


[[eventDispatcherCustomEvents]]

==== Dispatching events through API

We opened up the event-dispatching mechanism through the API, to allow you to dispatch custom events to any listeners that are registered in the engine. It's recommended (although not enforced) to only dispatch +ActivitiEvents+ with type +CUSTOM+. Dispatching the event can be done using the ++RuntimeService++:

[source,java,linenums]
----

/**
 * Dispatches the given event to any listeners that are registered.
 * @param event event to dispatch.
 *
 * @throws ActivitiException if an exception occurs when dispatching the event or when the {@link ActivitiEventDispatcher}
 * is disabled.
 * @throws ActivitiIllegalArgumentException when the given event is not suitable for dispatching.
 */
 void dispatchEvent(ActivitiEvent event);
----

[[eventDispatcherEventTypes]]


==== Supported event types

Listed below are all event types that can occur in the engine. Each type corresponds to an enum value in the +org.activiti.engine.delegate.event.ActivitiEventType+.

[[eventTypes]]
.Supported events
[options="header"]
|===============
|Event name|Description|Event classes
|ENGINE_CREATED|The process-engine this listener is attached to, has been created and is ready for API-calls.|+org.activiti...ActivitiEvent+
|ENGINE_CLOSED|The process-engine this listener is attached to, has been closed. API-calls to the engine are no longer possible.|+org.activiti...ActivitiEvent+
|ENTITY_CREATED|A new entity is created. The new entity is contained in the event.|+org.activiti...ActivitiEntityEvent+
|ENTITY_INITIALIZED|A new entity has been created and is fully initialized. If any children are created as part of the creation of an entity, this event will be fired AFTER the create/initialisation of the child entities as opposed to the +$$ENTITY_CREATE$$+ event.|+org.activiti...ActivitiEntityEvent+
|ENTITY_UPDATED|An existing is updated. The updated entity is contained in the event.|+org.activiti...ActivitiEntityEvent+
|ENTITY_DELETED|An existing entity is deleted. The deleted entity is contained in the event.|+org.activiti...ActivitiEntityEvent+
|ENTITY_SUSPENDED|An existing entity is suspended. The suspended entity is contained in the event. Will be dispatched for ProcessDefinitions, ProcessInstances and Tasks.|+org.activiti...ActivitiEntityEvent+
|ENTITY_ACTIVATED|An existing entity is activated. The activated entity is contained in the event. Will be dispatched for ProcessDefinitions, ProcessInstances and Tasks.|+org.activiti...ActivitiEntityEvent+
|JOB_EXECUTION_SUCCESS|A job has been executed successfully. The event contains the job that was executed.|+org.activiti...ActivitiEntityEvent+
|JOB_EXECUTION_FAILURE|The execution of a job has failed. The event contains the job that was executed and the exception.|+org.activiti...ActivitiEntityEvent+ and +org.activiti...ActivitiExceptionEvent+
|JOB_RETRIES_DECREMENTED|The number of job retries have been decremented due to a failed job. The event contains the job that was updated.|+org.activiti...ActivitiEntityEvent+
|TIMER_FIRED|A timer has been fired. The event contains the job that was executed?|+org.activiti...ActivitiEntityEvent+
|JOB_CANCELED|A job has been canceled. The event contains the job that was canceled. Job can be canceled by
                  API call, task was completed and associated boundary timer was canceled, on the new process definition
                  deployment.
                |+org.activiti...ActivitiEntityEvent+
|ACTIVITY_STARTED|An activity is starting to execute|+org.activiti...ActivitiActivityEvent+
|ACTIVITY_COMPLETED|An activity is completed successfully|+org.activiti...ActivitiActivityEvent+
|ACTIVITY_CANCELLED|An activity is going to be cancelled. There can be three reasons for activity cancellation (MessageEventSubscriptionEntity, SignalEventSubscriptionEntity, TimerEntity).|+org.activiti...ActivitiActivityCancelledEvent+
|ACTIVITY_SIGNALED|An activity received a signal|+org.activiti...ActivitiSignalEvent+
|ACTIVITY_MESSAGE_RECEIVED|An activity received a message. Dispatched before the activity receives the message. When received, a +$$ACTIVITY_SIGNAL$$+ or +$$ACTIVITY_STARTED$$+ will
                be dispatched for this activity, depending on the type (boundary-event or event-subprocess start-event)|+org.activiti...ActivitiMessageEvent+
|ACTIVITY_ERROR_RECEIVED|An activity has received an error event. Dispatched before the actual error has been handled by
                 the activity. The event's +activityId+ contains a reference to the error-handling activity.
                 This event will be either followed by a +$$ACTIVITY_SIGNALLED$$+ event or +$$ACTIVITY_COMPLETE$$+
                  for the involved activity, if the error was delivered successfully.|+org.activiti...ActivitiErrorEvent+
|UNCAUGHT_BPMN_ERROR|An uncaught BPMN error has been thrown. The process did not have any handlers for that specific error. The event's +activityId+ will be empty.|+org.activiti...ActivitiErrorEvent+
|ACTIVITY_COMPENSATE|An activity is about to be compensated. The event contains the id of the activity that is will be executed for compensation.|+org.activiti...ActivitiActivityEvent+
|VARIABLE_CREATED|A variable has been created. The event contains the variable name, value and related execution and task (if any).|+org.activiti...ActivitiVariableEvent+
|VARIABLE_UPDATED|An existing variable has been updated. The event contains the variable name, updated value and related execution and task (if any).|+org.activiti...ActivitiVariableEvent+
|VARIABLE_DELETED|An existing variable has been deleted. The event contains the variable name, last known value and related execution and task (if any).|+org.activiti...ActivitiVariableEvent+
|TASK_ASSIGNED|A task has been assigned to a user. The event contains the task|+org.activiti...ActivitiEntityEvent+
|TASK_CREATED|A task has been created. This is dispatched after the +$$ENTITY_CREATE$$+ event. In case the task is part of a process, this event will be
                  fired before the task listeners are executed.
                |+org.activiti...ActivitiEntityEvent+
|TASK_COMPLETED|A task has been completed. This is dispatched before the +$$ENTITY_DELETE$$+ event. In case the task is part of a process, this event will be
                fired before the process has moved on and will be followed by a +$$ACTIVITY_COMPLETE$$+ event, targeting the activity that represents the completed task.|+org.activiti...ActivitiEntityEvent+
|PROCESS_COMPLETED| A process has been completed. Dispatched after the last activity +$$ACTIVITY_COMPLETED $$+ event. Process is completed when it reaches state in which process instance does not have
                  any transition to take.
                |+org.activiti...ActivitiEntityEvent+
|PROCESS_CANCELLED|A process has been cancelled. Dispatched before the process instance is deleted from runtime. Process instance is cancelled by API call +RuntimeService.deleteProcessInstance+|+org.activiti...ActivitiCancelledEvent+
|MEMBERSHIP_CREATED|A user has been added to a group. The event contains the ids of the user and group involved.|+org.activiti...ActivitiMembershipEvent+
|MEMBERSHIP_DELETED|A user has been removed from a group. The event contains the ids of the user and group involved.|+org.activiti...ActivitiMembershipEvent+
|MEMBERSHIPS_DELETED|All members will be removed from a group. The event is thrown before the members are removed, so they are still accessible. No individual
                +$$MEMBERSHIP_DELETED$$+ events will be thrown if all members are deleted at once, for performance reasons.|+org.activiti...ActivitiMembershipEvent+

|===============


All +$$ENTITY_\*$$+ events are related to entities inside the engine. The list below show an overview of what entity-events are dispatched for which entities:


* *+$$ENTITY_CREATED, ENTITY_INITIALIZED, ENTITY_DELETED$$+*: Attachment, Comment, Deployment, Execution, Group, IdentityLink, Job, Model, ProcessDefinition, ProcessInstance, Task, User.
* *+$$ENTITY_UPDATED$$+*: Attachment, Deployment, Execution, Group, IdentityLink, Job, Model, ProcessDefinition, ProcessInstance, Task, User.
* *+$$ENTITY_SUSPENDED, ENTITY_ACTIVATED$$+*: ProcessDefinition, ProcessInstance/Execution, Task.


[[eventDispatcherRemarks]]


==== Additional remarks


*Only listeners are notified in the engine the events are dispatched from.* So in case you have different engines - running against the same database - only events that originated in the engine the listener is registered for, are dispatched to that listener. The events that occur in the other engine are not dispatched to the listeners, regardless of the fact they are running in the same JVM or not.

Certain event-types (related to entities) expose the targeted entity. Depending on the type or event, these entities cannot be updated anymore (e.g. when the entity is deleted). If possible, use the +EngineServices+ exposed by the event to interact in a safe way with the engine. Even then, you need to be cautious with updates/operations on entities that are involved in the dispatched event.

No entity-events are dispatched related to history, as they all have a runtime-counterpart which have their events dispatched.
