[[chDeployment]]

== 部署 Deployment

=== 业务存档 Business archives

要部署流程，需要将它们包装在业务存档里。业务存档是Activiti引擎的部署单元，也就是一个zip文件。可以包含BPMN 2.0流程，任务表单，规则，与其他类型的文件。总的来说，业务存档包含一组已命名的资源。


当部署业务存档时，会扫描具有++.bpmn20.xml++或++.bpmn++扩展名的BPMN文件。每一个这种文件都会被解析，并可以包含多个流程定义。

[NOTE]
====
业务存档中的Java类**不会添加至classpath**。业务存档中，所有流程定义使用的自定义类（例如Java服务任务service tasks或者事件监听器实现event listener implementations），都应该放在用于运行流程的activiti引擎的classpath下。
====

==== 编程方式部署 Deploying programmatically

从zip文件部署业务存档，可以这样做：

[source,java,linenums]
----
String barFileName = "path/to/process-one.bar";
ZipInputStream inputStream = new ZipInputStream(new FileInputStream(barFileName));

repositoryService.createDeployment()
    .name("process-one.bar")
    .addZipInputStream(inputStream)
    .deploy();

----

也可以从不同资源构建部署。查看javadoc获取更多信息。

[[deploymentWithExplorer]]


==== 使用Activiti Exploreer部署 (Deploying with Activiti Explorer)

Activiti Explorer web应用，可以通过web应用用户界面，上传bar文件（或者单独的++bpmn20.xml++文件）。选择__Management__页签并点击__Deployment__:

image::images/deployment.explorer.png[align="center"]

会弹出窗口，让你选择电脑中的文件，或者（如果你的浏览器支持）可以直接拖放文件到指定区域。

image::images/deployment.explorer.2.png[align="center"]



=== 外部资源 External resources

流程定义保存在Activiti数据库中。这些流程定义，在使用服务任务、执行监听器或执行Activiti配置文件中定义的Spring bean时，可以引用委托类。这些类与Spring配置文件，需要对所有可能运行这个流程定义的流程引擎都可用。

==== Java类 Java classes

所有流程中用到的自定义类（例如服务任务、事件监听器、任务监听器等中，用到的JavaDelegate），在流程启动时，都需要存在于引擎的classpath中。

然而在业务存档部署时，classpath中不是必须要有这些类。这意味着使用Ant部署新业务存档时，你的代理类不必须放在classpath中。

当使用演示配置，且希望添加自定义类时，需要在activiti-explorer或activiti-rest web应用库中，添加包含有你的自定义类的jar。别忘了也要添加你的自定义类的依赖（若有）。或者，也可以将你的依赖添加到Tomcat的库文件夹，++${tomcat.home}/lib++中。


==== Using Spring beans from a process

When expressions or scripts use Spring beans, those beans have to be available to the engine when executing the process definition. If you are building your own webapp and you configure your process engine in your context as described in <<springintegration,the spring integration section>>, that is straightforward. But bear in mind that you also should update the Activiti rest webapp with that context if you use it. You can do that by replacing the +activiti.cfg.xml+ in the +activiti-rest/lib/activiti-cfg.jar+ JAR file with an +activiti-context.xml+ file containing your Spring context configuration.

==== Creating a single app

Instead of making sure that all process engines have all the delegation classes on their classpath and use the right Spring configuration, you may consider including the Activiti rest webapp inside your own webapp so that there is only a single +ProcessEngine+.


[[versioningOfProcessDefinitions]]


=== Versioning of process definitions

BPMN doesn't have a notion of versioning.  That is actually good because the executable BPMN process file will probably live in a version control system repository (e.g. Subversion, Git or Mercurial) as part of your development project.  Versions of process definitions are created during deployment. During deployment, Activiti will assign a version to the +ProcessDefinition+ before it is stored in the Activiti DB.


For each process definition in a business archive the following steps are performed to initialize the properties +key+, +version+, +name+ and ++id++:

* The process definition +id+ attribute in the XML file is used as the process definition +key+ property.
* The process definition +name+ attribute in the XML file is used as the process definition +name+ property. If the name attribute is not specified, then id attribute is used as the name.
* The first time a process with a particular key is deployed, version 1 is assigned.  For all subsequent deployments of process definitions with the same key, the version will be set 1 higher than the maximum currently deployed version. The key property is used to distinguish process definitions.
* The id property is set to {processDefinitionKey}:{processDefinitionVersion}:{generated-id}, where +generated-id+ is a unique number added to guarantee uniqueness of the process id for the process definition caches in a clustered environment.

Take for example the following process

[source,xml,linenums]
----
<definitions id="myDefinitions" >
  <process id="myProcess" name="My important process" >
    ...
----

When deploying this process definition, the process definition in the database will look like this:

[options="header"]
|===============
|id|key|name|version
|myProcess:1:676|myProcess|My important process|1

|===============


Suppose we now deploy an updated version of the same process (e.g. changing some user tasks), but the ++id++ of the process definition remains the same. The process definition table will now contain the following entries:

[options="header"]
|===============
|id|key|name|version
|myProcess:1:676|myProcess|My important process|1
|myProcess:2:870|myProcess|My important process|2

|===============

When the ++runtimeService.startProcessInstanceByKey("myProcess")++ is called, it will now use the process definition with version ++2++, as this is the latest version of the process definition.

Should we create a second process, as defined below and deploy this to Activiti, a third row will be added to the table.

[source,xml,linenums]
----
<definitions id="myNewDefinitions" >
  <process id="myNewProcess" name="My important process" >
    ...
----

The table will look like this:

[options="header"]
|===============
|id|key|name|version
|myProcess:1:676|myProcess|My important process|1
|myProcess:2:870|myProcess|My important process|2
|myNewProcess:1:1033|myNewProcess|My important process|1

|===============

Note how the key for the new process is different from our first process. Even though the name is the same (we should probably have changed that too), Activiti only considers the +id+ attribute when distinguishing processes. The new process is therefore deployed with version 1.


[[providingProcessDiagram]]


=== Providing a process diagram

A process diagram image can be added to a deployment. This image will be stored in the Activiti repository and is accessible through the API. This image is also used to visualize the process in Activiti Explorer.

Suppose we have a process on our classpath, +org/activiti/expenseProcess.bpmn20.xml+ that has a process key 'expense'. The following naming conventions for the process diagram image apply (in this specific order):

* If an image resource exists in the deployment that has a name of the BPMN 2.0 XML file name concatenated with the process key and an image suffix, this image is used. In our example, this would be +org/activiti/expenseProcess.expense.png+ (or .jpg/gif). In case you have multiple images defined in one BPMN 2.0 XML file, this approach makes most sense. Each diagram image will then have the process key in its file name.
* If no such image exists, am image resource in the deployment matching the name of the BPMN 2.0 XML file is searched for. In our example this would be +org/activiti/expenseProcess.png+. Note that this means that *every process definition* defined in the same BPMN 2.0 file has the same process diagram image. In case there is only one process definition in each BPMN 2.0 XML file, this is obviously not a problem.


Example when deploying programmatically:

[source,java,linenums]
----

repositoryService.createDeployment()
  .name("expense-process.bar")
  .addClasspathResource("org/activiti/expenseProcess.bpmn20.xml")
  .addClasspathResource("org/activiti/expenseProcess.png")
  .deploy();
----


The image resource can be retrieved through the API afterwards:

[source,java,linenums]
----
ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery()
  .processDefinitionKey("expense")
  .singleResult();

String diagramResourceName = processDefinition.getDiagramResourceName();
InputStream imageStream = repositoryService.getResourceAsStream(
    processDefinition.getDeploymentId(), diagramResourceName);
----


[[generatingProcessDiagram]]


=== Generating a process diagram

In case no image is provided in the deployment, as described in the <<providingProcessDiagram,previous section>>, the Activiti engine will generate a diagram image if the process definition contains the necessary 'diagram interchange' information.

The resource can be retrieved in exactly the same way as when <<providingProcessDiagram, an image is provided>> in the deployment.

image::images/deployment.image.generation.png[align="center"]

If, for some reason, it is not necessary or wanted to generate a diagram during deployment the +isCreateDiagramOnDeploy+ property can be set on the process engine configuration:

[source,xml,linenums]
----
<property name="createDiagramOnDeploy" value="false" />
----

No diagram will be generated now.


[[deploymentCategory]]


=== Category

Both deployments and process definitions have user defined categories.  The process definition category is initialized value in attribute in the BPMN file: +<definitions ... targetNamespace="yourCategory" ...+


The deployment category can be specified in the API like this:

[source,java,linenums]
----
repositoryService
    .createDeployment()
    .category("yourCategory")
    ...
    .deploy();
----
