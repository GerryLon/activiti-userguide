[[bpmnConstructs]]

== BPMN 2.0 结构 BPMN 2.0 Constructs

本章节包含了Activiti支持的BPMN 2.0结构，以及对BPMN标准的自定义扩展。

[[bpmnCustomExtensions]]


=== 自定义扩展 Custom extensions


BPMN 2.0标准对流程的所有的参与者都是个好东西。最终用户不需要因为依赖专利解决方案，而被供应商“绑架”。类似Activiti的开源框架，也可以提供与大型供应商的解决方案相同（经常是更好;-）的实现。有了BPMN 2.0标准，从大型供应商解决方案向Activiti的转变，就变得简单平滑。

然而标准的缺点，是它通常是不同公司（不同观点）大量讨论与妥协的结果。作为阅读BPMN 2.0 XML流程定义的开发者，有时会觉得某些结构或做事方法太笨重了。Activiti将开发者的感受放在最高优先，因此引入了一些**'Activiti BPMN extensions（扩展）'**。这些“扩展”并不在BPMN 2.0规格中，有些是新结构，有些是对特定结构的简化。

尽管BPMN 2.0规格明确指出可以支持自定义扩展，我们仍做了如下保证：

* 自定义扩展的前提是，**做事情的标准方式****总**可以进行更简化的改造。因此当你决定使用自定义扩展时，不用担心无路可退（仍然可以用标准方式）。
* 使用自定义扩展时，总是通过为新的XML元素、属性等提供**activiti:**命名空间前缀，明确标识出来。

因此是否使用自定义扩展，完全取决于你自己。有些其他因素会影响选择（图形化编辑器的使用，公司策略，等等）。我们提供扩展，只是因为相信，标准中的某些地方可以用更简单或效率更高的方式处理。请不要吝啬给我们反馈对扩展的评价（正面的和/或负面的），也可以给我们提供关于自定义扩展的新想法。说不定某一天，你的想法会成为规格的一部分！


[[bpmnEvents]]

=== 事件 Events

事件通常用于为流程生命周期中发生的事情建模。事件总是图形化为圆圈。在BPMN 2.0中，有两种主要的事件分类：__catching（捕获）__与__throwing（抛出）__事件。

* **捕获:** 当流程执行到达这个事件时，会等待直到触发器动作。触发器的类型，由其中的图标，或者说XML中的类型声明，而定义。捕获事件与抛出事件显示上的区别，是其内部的图标没有填充（也就是说，是白色的）。
* **抛出:** 当流程执行到达这个事件时，会触发一个触发器。触发器的类型，由其中的图标，或者说XML中的类型声明，而定义。抛出事件与捕获事件显示上的区别，是其内部的图标填充为黑色。

[[eventDefinitions]]


==== 事件定义 Event Definitions

事件定义，定义了事件的语义。没有事件定义的话，事件就“不做什么特别的事情”。例如一个没有事件定义的开始事件，并不限定具体是什么启动了流程。如果为这个开始事件添加事件定义（例如定时器事件定义），就声明了启动流程的“类型”（例如对于定时器事件定义，就是到达了特定的时间点）。


[[timerEventDefinitions]]


==== 定时器事件定义 Timer Event Definitions

定时器事件，是由定义的定时器触发的事件。可以用于<<bpmnTimerStartEvent,开始事件 start event>>，<<bpmnIntermediateCatchingEvent,中间事件 intermediate event>>，或<<bpmnTimerBoundaryEvent,边界事件 boundary event>>。定时器事件的行为，取决于所使用的业务日历（business calendar）。定时器事件有默认的业务日历，但也可以为每个定时器事件定义，定义业务日历。

[source,xml,linenums]
----
<timerEventDefinition activiti:businessCalendarName="custom">
    ...
</timerEventDefinition>
----
其中businessCalendarName指向流程引擎配置中的业务日历。如果省略业务日历定义，就是用默认业务日历。

定时器定义必须且只能使用下列的一种元素：

* **timeDate**。这个方式指定了link:$$http://en.wikipedia.org/wiki/ISO_8601#Dates$$[ISO 8601]格式的固定时间。
在这个时间点，会触发触发器。例如：


[source,xml,linenums]
----
<timerEventDefinition>
    <timeDate>2011-03-11T12:13:14</timeDate>
</timerEventDefinition>
----


* **timeDuration**。要定义在触发前，定时器需要等待多长时间，可以用__timeDuration__作为__timerEventDefinition__的子元素来指定。使用link:$$http://en.wikipedia.org/wiki/ISO_8601#Durations$$[ISO 8601]格式（BPMN 2.0规格要求）。例如（等待10天）：

[source,xml,linenums]
----
<timerEventDefinition>
    <timeDuration>P10D</timeDuration>
</timerEventDefinition>
----

* **timeCycle**。指定重复周期，可用于周期性启动流程，或者为超期用户任务多次发送提醒。这个元素可以使用两种格式。第一种是按照link:$$http://en.wikipedia.org/wiki/ISO_8601#Repeating_intervals$$[ISO 8601]标准定义的循环时间周期。例如（三次重复间隔，每次间隔为10小时）：

[source,xml,linenums]
----
<timerEventDefinition>
    <timeCycle activiti:endDate="2015-02-25T16:42:11+00:00">R3/PT10H</timeCycle>
</timerEventDefinition>
----

也可以指定__endDate__，作为__timeCycle__的可选属性，或者像这样直接写在时间表达式的结尾：++R3/PT10H/${EndDate}++。
当到达endDate时，应用会停止，并为该任务创建其他作业。
可以使用link:$$http://en.wikipedia.org/wiki/ISO_8601#Dates$$[ISO 8601]标准的静态值，比如__"2015-02-25T16:42:11+00:00"__。也可以使用变量__${EndDate}__

[source,xml,linenums]
----
<timerEventDefinition>
    <timeCycle>R3/PT10H/${EndDate}</timeCycle>
</timerEventDefinition>
----

如果同时使用了两种指定方式，则系统会使用属性方式定义的endDate。

目前只有__BoundaryTimerEvents__与__CatchTimerEvent__支持__EndDate__功能。

另外，也可以使用cron表达式指定定时周期。下面的例子展示了一个整点启动，每5分钟触发的触发器：


----
0 0/5 * * * ?
----


请参考link:$$http://www.quartz-scheduler.org/docs/tutorials/crontrigger.html$$[这个教程]了解如何使用cron表达式。

**请注意:** 与普通的Unix cron不同，第一个符号代表的是秒。

重复时间周期更适用于使用相对时间，也就是从某个特定时间点开始计算（比如用户任务开始的时间）。而cron表达式可以使用绝对时间，因此绝对适合用于<<timerStartEventDescription,定时启动事件 timer start events>>。


可以在定时事件定义中使用表达式，也就是使用流程变量调整定时器定义。这个流程变量必须是包含合适时间格式的字符串，ISO 8601（或者对于循环类型，cron）。

[source,xml,linenums]
----
<boundaryEvent id="escalationTimer" cancelActivity="true" attachedToRef="firstLineSupport">
  <timerEventDefinition>
    <timeDuration>${duration}</timeDuration>
  </timerEventDefinition>
</boundaryEvent>
----

**请注意：**定时器只有在作业或者异步执行器启用时才能触发（也就是说，需要在++activiti.cfg.xml++中，将__jobExecutorActivate__或者__asyncExecutorActivate__设置为++true++。因为默认情况下，作业与异步执行器都是禁用的）。

[[bpmnErrorEventDefinition]]


==== 错误事件定义 Error Event Definitions

**重要提示：** BPMN错误与Java异常**不**是一回事。事实上，这两者毫无共同点。BPMN错误事件是建模__业务异常（business exceptions）__的方式。而Java异常使用<<serviceTaskExceptionHandling,它们自己的方式>>处理。

[source,xml,linenums]
----
<endEvent id="myErrorEndEvent">
  <errorEventDefinition errorRef="myError" />
</endEvent>

----

[[bpmnSignalEventDefinition]]


==== 信号事件定义 Signal Event Definitions


信号事件，是引用具名信号的事件。信号是全局范围（广播）的事件，并会被传递给所有激活的处理器（等待中的流程实例/捕获信号事件 catching signal events）。


信号事件定义使用++signalEventDefinition++元素声明。++signalRef++属性引用一个++signal++元素，该++signal++元素需要声明为++definitions++根元素的子元素。下面摘录一个流程，使用中间事件（intermediate event）抛出与捕获信号事件。

[source,xml,linenums]
----
<definitions... >
	<!-- 声明信号 -->
	<signal id="alertSignal" name="alert" />

	<process id="catchSignal">
		<intermediateThrowEvent id="throwSignalEvent" name="Alert">
			<!-- 信号事件定义 -->
			<signalEventDefinition signalRef="alertSignal" />
		</intermediateThrowEvent>
		...
		<intermediateCatchEvent id="catchSignalEvent" name="On Alert">
			<!-- 信号事件定义 -->
			<signalEventDefinition signalRef="alertSignal" />
		</intermediateCatchEvent>
		...
	</process>
</definitions>
----


两个++signalEventDefinition++引用同一个++signal++元素。


[[bpmnSignalEventDefinitionThrow]]


===== 抛出信号事件 Throwing a Signal Event

信号可以由流程实例使用BPMN结构抛出，也可以通过编程方式使用java API抛出。下面++org.activiti.engine.RuntimeService++中的方法可以用于编程方式抛出信号：

[source,java,linenums]
----
RuntimeService.signalEventReceived(String signalName);
RuntimeService.signalEventReceived(String signalName, String executionId);
----

++signalEventReceived(String signalName);++与++signalEventReceived(String signalName, String executionId);++的区别，是前者在全局范围，为所有已订阅处理器抛出信号（广播），而后者只为指定的执行传递信号。


[[bpmnSignalEventDefinitionCatch]]


===== 捕获信号事件 Catching a Signal Event


信号事件可用信号捕获中间事件（intermediate catch signal event）或者信号边界事件（signal boundary event）捕获。


[[bpmnSignalEventDefinitionQuery]]


===== 查询信号事件订阅 Querying for Signal Event subscriptions


可以查询所有订阅了某一信号事件的所有执行：

[source,java,linenums]
----
 List<Execution> executions = runtimeService.createExecutionQuery()
      .signalEventSubscriptionName("alert")
      .list();
----

可以使用++signalEventReceived(String signalName, String executionId)++方法为这些执行传递这个信号。


[[bpmnSignalEventDefinitionScope]]


===== 信号事件范围 Signal event scope

默认情况下，信号事件在__流程引擎全局广播__。这意味着你可以在一个流程实例中抛出一个信号事件，而不同流程定义的不同流程实例都会响应这个事件。

然而，有事也会希望只在__同一个流程实例__中响应信号事件。例如在流程实例中使用异步机制，而两个或多个活动彼此互斥的时候。

要限制信号事件的__范围（scope）__，在信号事件定义中添加（非BPMN 2.0标准！）__scope属性__：

[source,xml,linenums]
----
<signal id="alertSignal" name="alert" activiti:scope="processInstance"/>
----

这个属性的默认值为__"global（全局）"__。


[[bpmnSignalEventDefinitionExample]]


===== 信号事件示例 Signal Event example(s)

下面是一个关于两个不同的流程通过信号通信的例子。第一个流程在保险政策更新或变更时启动。在变更由人工审核之后，会抛出信号事件，指出政策已经发生了变更：

image::images/bpmn.signal.event.throw.png[align="center"]

这个事件可以被所有感兴趣的流程实例捕获。下面是一个订阅这个事件的流程的例子。

image::images/bpmn.signal.event.catch.png[align="center"]

**请注意：**要理解信号事件会广播给**所有**激活的处理器，这很重要。这意味着在上面的例子中，所有捕获这个信号的流程实例，都会接收这个信号。在这个例子中这就是我们期望的。然而，有的情况下，不希望使用广播方式。考虑下面的流程：

image::images/bpmn.signal.event.warning.1.png[align="center"]


Activiti不支持上面流程中描述的模式。理想情况是，在执行"do something"任务时抛出的错误，由错误边界事件捕获，并通过信号抛出事件传播至执行的并行分支，最终中断"do something in parallel"任务。到目前为止Activiti会按照预期效果执行。**然而，由于信号的广播效应，它也会被传播至所有其他订阅了这个信号事件的流程实例。**这可能并我们希望的效果。

**请注意：**信号事件与特定的流程实例无关，而是会广播给所有流程实例。如果你需要只为某一特定的流程实例传递信号，则需要使用++signalEventReceived(String signalName, String executionId)++手动建立关联，并使用适当的的<<bpmnSignalEventDefinitionQuery,查询机制 query mechanisms>>。


[[bpmnMessageEventDefinition]]


==== 消息事件定义 Message Event Definitions

消息事件，是指引用具名消息的事件。消息具有名字与载荷。与信号不同，消息事件只有一个接收者。

消息事件定义使用++messageEventDefinition++元素声明。++messageRef++属性引用一个++message++元素，该++message++元素需要声明为++definitions++根元素的子元素。下面摘录一个流程，声明了两个消息事件，并由开始事件与消息捕获中间事件（intermediate catching message event）引用。

[source,xml,linenums]
----
<definitions id="definitions"
  xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL"
  xmlns:activiti="http://activiti.org/bpmn"
  targetNamespace="Examples"
  xmlns:tns="Examples">

  <message id="newInvoice" name="newInvoiceMessage" />
  <message id="payment" name="paymentMessage" />

  <process id="invoiceProcess">

    <startEvent id="messageStart" >
    	<messageEventDefinition messageRef="newInvoice" />
    </startEvent>
    ...
    <intermediateCatchEvent id="paymentEvt" >
    	<messageEventDefinition messageRef="payment" />
    </intermediateCatchEvent>
    ...
  </process>

</definitions>
----




[[bpmnMessageEventDefinitionThrow]]


===== 抛出消息事件 Throwing a Message Event


作为可嵌入的流程引擎，Activiti不关心实际接收消息。因为这可能与环境相关，并需要进行平台定义的操作，例如连接至JMS（Java Messaging Service Java消息服务）队列（Queue）/主题（Topic），或者处理Webservice或者REST请求。因此接收消息需要作为应用的一部分，或者是流程引擎所嵌入的基础框架中的一部分，由你实现。

在应用中接收到消息后，需要决定如何处理它。如果这个消息需要启动新的流程实例，可以选择下面由runtime服务提供的方法中的一种：

[source,java,linenums]
----
ProcessInstance startProcessInstanceByMessage(String messageName);
ProcessInstance startProcessInstanceByMessage(String messageName, Map<String, Object> processVariables);
ProcessInstance startProcessInstanceByMessage(String messageName, String businessKey, Map<String, Object> processVariables);
----

这些方法可以使用引用的消息启动流程实例。

如果需要由已有的流程实例接收消息，需要首先将消息与特定的流程实例关联（查看后续章节），然后触发等待中的执行，让其继续。runtime服务提供了下列方法，根据消息事件的订阅，触发执行：

[source,java,linenums]
----
void messageEventReceived(String messageName, String executionId);
void messageEventReceived(String messageName, String executionId, HashMap<String, Object> processVariables);
----


[[bpmnMessageEventDefinitionQuery]]


===== 查询消息事件订阅 Querying for Message Event subscriptions


* 对于消息启动事件，消息事件的订阅与特定的__流程定义__相关。这种类型的消息订阅，可以使用++ProcessDefinitionQuery++查询：

[source,java,linenums]
----
ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery()
      .messageEventSubscription("newCallCenterBooking")
      .singleResult();
----

因为对于一个消息，只能有一个流程定义订阅，因此这个查询总是返回0或1个结果。如果流程定义更新了，只有该流程定义的最新版本会订阅这个消息事件。

* 对于消息捕获中间事件（intermediate catch message event），消息事件的订阅与特定的__执行__相关。这种类型的消息订阅，可以使用++ExecutionQuery++查询：

[source,java,linenums]
----
Execution execution = runtimeService.createExecutionQuery()
      .messageEventSubscriptionName("paymentReceived")
      .variableValueEquals("orderId", message.getOrderId())
      .singleResult();
----

这种查询通常有关联查询，并且通常需要了解流程（在这个例子里，对于给定的orderId，至多只有一个流程实例）。


[[bpmnMessageEventDefinitionExample]]


===== 消息事件示例 Message Event example(s)


下面是一个流程的例子，可以使用两种不同的消息启动：

image::images/bpmn.start.message.event.example.1.png[align="center"]

在流程需要通过不同的方式响应不同的启动事件，但是后续使用统一的方式处理时，这就很有用。


[[bpmnStartEvents]]


==== 启动事件 Start Events


启动事件指明了流程的起点。启动事件的类型（流程在消息到达时启动，在指定的时间间隔后启动，等等），定义了流程__如何__启动，并显示为启动事件中的小图标。在XML中，类型由子元素声明来定义。

启动事件“随时捕获”：概念上，事件（随时）等候，知道特定的触发器被触发。

在启动事件中，可以使用下列Activiti专用参数：

* *initiator*: 指明认证用户（authenticated user）id的变量名。在流程启动时，该id会使用这个变量名被保存。例如：

[source,xml,linenums]
----
<startEvent id="request" activiti:initiator="initiator" />
----

认证用户必须通过++IdentityService.setAuthenticatedUserId(String)++方法，在try-finally块中设置，像这样：

[source,java,linenums]
----
try {
  identityService.setAuthenticatedUserId("bono");
  runtimeService.startProcessInstanceByKey("someProcessKey");
} finally {
  identityService.setAuthenticatedUserId(null);
}

----

这段代码在集成在Activiti Explorer应用中。因此可以与<<forms,表单>>一起使用。


[[bpmnNoneStartEvent]]


==== 空启动事件 None Start Event

[[noneStartEventDescription]]


===== 描述 Description

“空”启动事件，技术上指的是没有特别指定启动流程实例的触发器。这意味着引擎无法预知何时启动流程实例。空启动事件用于流程实例通过调用下列__startProcessInstanceByXXX__ API方法启动的情况。

[source,java,linenums]
----
ProcessInstance processInstance = runtimeService.startProcessInstanceByXXX();
----

__请注意：__子流程（subprocess）总是有空启动事件。


[[noneStartEventGraphicalNotation]]


===== 图示 Graphical notation

空启动事件用空心圆圈表示，中间没有图标（也就是说没有触发器）。

image::images/bpmn.none.start.event.png[align="center"]



[[noneStartEventXml]]


===== XML表示 XML representation


空启动事件的XML表示格式，就是普通的启动事件声明，而没有任何子元素（其他种类的启动事件都有子元素，用于声明其类型）。

[source,xml,linenums]
----
<startEvent id="start" name="my start event" />
----




[[noneStartEventCustomExtension]]


===== 空启动事件的自定义扩展 Custom extensions for the none start event

*formKey*: 引用表单模板，用户需要在启动新流程实例时填写该表单。可以在<<forms,表单章节>>找到更多信息。例如：

[source,xml,linenums]
----
<startEvent id="request" activiti:formKey="org/activiti/examples/taskforms/request.form" />
----


[[bpmnTimerStartEvent]]


==== 定时器启动事件 Timer Start Event

[[timerStartEventDescription]]


===== 描述 Description

定时器启动事件，用于在指定时间创建流程实例。在流程只需要启动一次，与流程需要在特定的时间间隔重复启动时，都可以使用。

__请注意：__子流程不能有定时器启动事件。

__请注意：__定时器启动事件，在流程部署的同时就开始计时。不需要调用startProcessInstanceByXXX，尽管也不禁止使用启动流程的方法。调用startProcessInstanceByXXX时也会启动流程。

__请注意：__当部署带有定时器启动事件的流程的新版本时，上一版本的定时器作业会被移除。这是因为通常并不希望旧版本的流程仍然自动启动新的流程实例。


[[timerStartEventGraphicalNotation]]


===== 图示 Graphical notation

定时器启动事件，用其中有一个钟表图标的圆圈来表示。

image::images/bpmn.clock.start.event.png[align="center"]


[[timerStartEventXml]]


===== XML表示 XML representation


定时器启动事件的XML表示格式，是普通的启动事件声明，加上定时器定义子元素。请参考<<timerEventDefinitions,定时器定义>>了解详细配置方法。


示例：流程会启动4次，间隔5分钟，从2011年3月11日，12:13开始

[source,xml,linenums]
----
<startEvent id="theStart">
  <timerEventDefinition>
    <timeCycle>R4/2011-03-11T12:13/PT5M</timeCycle>
</timerEventDefinition>
</startEvent>
----

示例：流程会在选定的时间启动一次

[source,xml,linenums]
----
<startEvent id="theStart">
  <timerEventDefinition>
    <timeDate>2011-03-11T12:13:14</timeDate>
  </timerEventDefinition>
</startEvent>
----


[[bpmnMessageStartEvent]]


==== 消息启动事件 Message Start Event

[[messageStartEventDescription]]


===== 描述 Description


<<bpmnMessageEventDefinition,消息>>启动事件，使用具名消息启动流程实例。它让我们可以使用消息名，有效地在一组可选的启动事件中__选择__正确的启动事件。

当**部署**具有一个或多个消息启动事件的流程定义时，请考虑下列因素：

* 消息启动事件的名字，在给定流程定义中，必须是唯一的。一个流程定义不得包含多个同名的消息启动事件。如果流程定义中有两个或多个消息启动事件引用同一个消息，也即两个或多个消息启动事件引用了具有相同消息名字的消息，则Activiti在部署这个流程定义时，会抛出异常。
* 消息启动事件的名字，在所有已部署的流程定义中，必须是唯一的。如果流程定义中，一个或多个消息启动事件，引用了已经部署的另一流程定义中的消息启动事件，已经使用的消息名，则Activiti在部署这个流程定义时，会抛出异常。
* 流程版本：在部署流程定义的新版本时，会取消上一版本的消息订阅。即使新版本中并没有这个消息事件，仍然这样（取消上版本的消息订阅）。

当**启动**流程实例时，可以使用下列++RuntimeService++中的方法，触发消息启动事件：

[source,java,linenums]
----
ProcessInstance startProcessInstanceByMessage(String messageName);
ProcessInstance startProcessInstanceByMessage(String messageName, Map<String, Object> processVariables);
ProcessInstance startProcessInstanceByMessage(String messageName, String businessKey, Map<String, Object< processVariables);
----


++messageName++是由++message++元素的++name++属性决定的名字。++message++元素被++messageEventDefinition++的++messageRef++属性引用。当**启动**流程实例时，请考虑下列因素：

* 只有顶层流程（top-level process）才支持消息启动事件。嵌入式子流程不支持消息启动事件。
* 如果一个流程定义中有多个消息启动事件，++runtimeService.startProcessInstanceByMessage(...)++允许选择合适的启动事件。
* 如果一个流程定义中有多个消息启动事件，与一个空启动事件，则++runtimeService.startProcessInstanceByKey(...)++与++runtimeService.startProcessInstanceById(...)++会使用空启动事件启动流程实例。
* 如果一个流程定义中有多个消息启动事件，而没有空启动事件，则++runtimeService.startProcessInstanceByKey(...)++与++runtimeService.startProcessInstanceById(...)++会抛出异常。
* 如果一个流程定义中只有一个消息启动事件，则++runtimeService.startProcessInstanceByKey(...)++与++runtimeService.startProcessInstanceById(...)++会使用这个消息启动事件启动新流程实例。
* 如果流程由调用活动（call activity）启动，则消息启动事件只有在下列情况下才被支持
** 除了消息启动事件，流程还有唯一的空启动事件
** 或者流程只有唯一的消息启动事件，而没有其他启动事件。


[[messageStartEventGraphicalNotation]]


===== 图示 Graphical notation


消息启动事件，用其中有一个消息事件标志的圆圈表示。这个标志并未填充，用以表示捕获（接收）行为。

image::images/bpmn.start.message.event.png[align="center"]



[[messageStartEventXml]]


===== XML表示 XML representation


消息启动事件的XML表示格式，为普通启动事件声明，加上messageEventDefinition子元素：

[source,xml,linenums]
----
<definitions id="definitions"
  xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL"
  xmlns:activiti="http://activiti.org/bpmn"
  targetNamespace="Examples"
  xmlns:tns="Examples">

  <message id="newInvoice" name="newInvoiceMessage" />

  <process id="invoiceProcess">

    <startEvent id="messageStart" >
    	<messageEventDefinition messageRef="tns:newInvoice" />
    </startEvent>
    ...
  </process>

</definitions>
----





[[bpmnSignalStartEvent]]


==== 信号启动事件 Signal Start Event

[[bpmnSignalStartEventDescription]]


===== 描述 Description

<<bpmnSignalEventDefinition,信号>>启动事件，使用具名信号启动流程实例。这个信号可以由流程实例中的信号抛出中间事件，或者API（__runtimeService.signalEventReceivedXXX__方法）触发。这些情况下，所有拥有相同名字信号启动事件的流程定义都会被启动。

请注意这些情况下，都可以选择异步还是同步启动流程实例。

需要为API传递的++signalName++，是由++signal++元素的++name++属性决定的名字。++signal++元素被++signalEventDefinition++的++signalRef++属性所引用。


[[signalStartEventGraphicalNotation]]


===== 图示 Graphical notation


信号启动事件，用其中有一个信号事件标志的圆圈表示。这个标志并未填充，用以表示捕获（接收）行为。

image::images/bpmn.start.signal.event.png[align="center"]



[[signalStartEventXml]]


===== XML表示 XML representation


信号启动事件的XML表示格式，为普通启动事件声明，加上signalEventDefinition子元素：


[source,xml,linenums]
----
<signal id="theSignal" name="The Signal" />

<process id="processWithSignalStart1">
  <startEvent id="theStart">
    <signalEventDefinition id="theSignalEventDefinition" signalRef="theSignal"  />
  </startEvent>
  <sequenceFlow id="flow1" sourceRef="theStart" targetRef="theTask" />
  <userTask id="theTask" name="Task in process A" />
  <sequenceFlow id="flow2" sourceRef="theTask" targetRef="theEnd" />
	  <endEvent id="theEnd" />
</process>
----

[[bpmnErrorStartEvent]]


==== 错误启动事件 Error Start Event

[[errorStartEventDescription]]


===== 描述 Description

<<bpmnErrorEventDefinition,错误>>启动事件，可用于触发事件子流程（Event Sub-Process）。**错误启动事件不能用于启动流程实例**。

错误启动事件总是中断。


[[errorStartEventGraphicalNotation]]


===== 图示 Graphical notation


错误启动事件，用其中有一个错误事件标志的圆圈表示。这个标志并未填充，用以表示捕获（接收）行为。

image::images/bpmn.start.error.event.png[align="center"]



[[errorStartEventXml]]


===== XML表示 XML representation

错误启动事件的XML表示格式，为普通启动事件声明，加上errorEventDefinition子元素：

[source,xml,linenums]
----
<startEvent id="messageStart" >
	<errorEventDefinition errorRef="someError" />
</startEvent>
----





[[bpmnEndEvent]]


==== 结束事件 End Events


结束事件标志着（子）流程的（分支的）结束。结束事件**总是抛出（型）事件**。这意味着当流程执行到达结束事件时，会抛出一个__结果__。结果的类型由事件内部的黑色图标描绘。在XML表示中，类型由子元素声明给出。


[[bpmnNoneEndEvent]]


==== 空结束事件 None End Event

[[noneEndEventDescription]]


===== 描述 Description

“空”结束事件，意味着当到达这个事件时，抛出的__结果__没有特别指定。因此，引擎除了结束当前执行分支之外，不会多做任何事情。


[[bpmnNoneEndEventDescription]]


===== 图示 Graphical notation

空结束事件，用其中没有图标（没有结果类型）的粗圆圈表示。

image::images/bpmn.none.end.event.png[align="center"]



[[bpmnNoneStartEventXml]]


===== XML表示 XML representation

空事件的XML表示格式，为普通结束事件声明，没有任何子元素（其它种类的结束事件都有子元素，用于声明其类型）。


[source,xml,linenums]
----
<endEvent id="end" name="my end event" />
----


[[bpmnErrorEndEvent]]


==== 错误结束事件 Error End Event

[[bpmnErrorEndEventDescription]]


===== 描述 Description

当流程执行到达**错误结束事件**时，结束执行的当前分支，并抛出错误。这个错误可以<<bpmnBoundaryErrorEvent,使用匹配的错误边界中间事件 intermediate boundary error event 捕获>>。如果找不到匹配的错误边界事件，将会抛出异常。


[[bpmnErrorEndEventGraphicalNotation]]


===== 图示 Graphical notation

错误结束事件事件，用内部有一个错误图标的标准结束事件（粗圆圈）表示。错误图标是全黑的，代表抛出的含义。

image::images/bpmn.error.end.event.png[align="center"]


[[bpmnErrorEndEventXml]]


===== XML表示 XML representation

错误结束事件，表示为结束事件，加上___errorEventDefinition___子元素：

[source,xml,linenums]
----
<endEvent id="myErrorEndEvent">
  <errorEventDefinition errorRef="myError" />
</endEvent>

----

__errorRef__属性可以引用在流程外定义的__error__元素：

[source,xml,linenums]
----
<error id="myError" errorCode="123" />
...
<process id="myProcess">
...
----

__error__的**errorCode**用于查找匹配的错误捕获边界事件。如果__errorRef__不匹配任何已定义的__error__，则该__errorRef__会用做__errorCode__的快捷方式。这个快捷方式是Activiti特有的。下面的代码片段在功能上是相同的。

[source,xml,linenums]
----
<error id="myError" errorCode="error123" />
...
<process id="myProcess">
...
  <endEvent id="myErrorEndEvent">
    <errorEventDefinition errorRef="myError" />
  </endEvent>
...
----

与下面的功能相同

[source,xml,linenums]
----
<endEvent id="myErrorEndEvent">
  <errorEventDefinition errorRef="error123" />
</endEvent>
----

请注意__errorRef__必须遵从BPMN 2.0概要（schema），且必须是合法的QName。

[[bpmnCancelEndEvent]]

==== 终止结束事件 Terminate End Event

===== 描述 Description

当到达__终止结束事件__时，当前的流程实例或子流程会被终止。概念上说，当执行到达终止结束事件时，会判断第一个__范围 scope__（流程或子流程）并终止它。请注意在BPMN 2.0中，子流程可以是嵌入式子流程，调用活动，事件子流程，或事务子流程。有一条通用规则：当存在多实例的调用过程或嵌入式子流程时，只会终止一个实例，其他的实例与流程实例不会受影响。

可以添加一个可选属性__terminateAll__。当其为__true__时，无论该终止结束事件在流程定义中的位置，也无论它是否在子流程（甚至是嵌套子流程）中，都会终止（根）流程实例。

===== 图示 Graphical notation

终止结束事件，用内部有一个全黑圆的标准结束事件（粗圆圈）表示。

image::images/bpmn.terminate.end.event.png[align="center"]


===== XML表示 XML representation

终止结束事件，表示为结束事件，加上__terminateEventDefinition__子元素。

请注意__terminateAll__属性是可选的（默认为__false__）。

[source,xml,linenums]
----
<endEvent id="myEndEvent >
  <terminateEventDefinition activiti:terminateAll="true"></terminateEventDefinition>
</endEvent>
----


==== 取消结束事件 Cancel End Event

<<experimental, [EXPERIMENTAL]>>[[bpmnCancelEndEventDescription]]


===== 描述 Description

取消结束事件，只能与bpmn事务子流程（bpmn transaction subprocess）一起使用。当到达取消结束事件时，会抛出取消事件，且必须由取消边界事件（cancel boundary event）捕获。之后这个取消边界事件将取消事务，并触发补偿（compensation）。


[[bpmnCancelEndEventGraphicalNotation]]


===== 图示 Graphical notation

取消结束事件，用内部有一个取消图标的标准结束事件（粗圆圈）表示。取消图标是全黑的，代表抛出的含义。

image::images/bpmn.cancel.end.event.png[align="center"]



[[bpmnCancelEndEventXml]]


===== XML表示 XML representation


取消结束事件，表示为结束事件，加上__cancelEventDefinition__子元素。

[source,xml,linenums]
----
<endEvent id="myCancelEndEvent">
  <cancelEventDefinition />
</endEvent>
----




[[bpmnBoundaryEvent]]


==== 边界事件 Boundary Events

边界事件是__捕获__（型）事件，依附在活动（activity）上（边界事件永远不会抛出）。这意味着当活动运行时，事件在__监听__特定类型的触发器。当事件__捕获__时，活动会被终止，并沿该事件的出口顺序流继续。

所有的边界事件都用相同的方式定义：

[source,xml,linenums]
----
<boundaryEvent id="myBoundaryEvent" attachedToRef="theActivity">
      <XXXEventDefinition/>
</boundaryEvent>
----

边界事件由下列（元素）定义：

* 唯一标识符（流程范围）
* 通过**attachedToRef**属性定义的，对该事件所依附的活动的引用。请注意边界事件，与其所依附的活动，定义在相同级别（也就是说，边界事件并不包含在活动内部）。
* 定义了边界事件的类型的，__XXXEventDefinition__形式的XML子元素（例如__TimerEventDefinition__，__ErrorEventDefinition__，等等）。查阅特定边界事件类型，以了解更多细节。



[[bpmnTimerBoundaryEvent]]


==== 定时器边界事件 Timer Boundary Event

[[timerBoundaryEventDescription]]


===== 描述 Description


定时器边界事件的行为像是秒表与闹钟。当执行到达了边界事件所依附的活动时，启动定时器。当定时器触发时（例如在特定间隔后），活动会被中断，沿着边界事件继续执行。


[[bpmnTimerBoundaryEventGraphicalNotation]]


===== 图示 Graphical Notation

定时器边界事件，用内部有一个定时器图标的标准边界事件（圆圈）表示。

image::images/bpmn.boundary.timer.event.png[align="center"]



[[bpmnTimerBoundaryEventXml]]


===== XML表示 XML Representation


定时器边界事件与<<bpmnBoundaryEvent,一般边界事件>>一样定义。其中类型子元素为**timerEventDefinition**元素。

[source,xml,linenums]
----
<boundaryEvent id="escalationTimer" cancelActivity="true" attachedToRef="firstLineSupport">
  <timerEventDefinition>
    <timeDuration>PT4H</timeDuration>
  </timerEventDefinition>
</boundaryEvent>
----

请参考<<timerEventDefinitions,定时器事件定义>>了解定时器配置的细节。

上面的例子在图示中，圆圈画为虚线：

image::images/bpmn.non.interrupting.boundary.timer.event.png[align="center"]

其典型使用场景，是发送额外的升级邮件，但不中断正常的流程流向。

在BPMN 2.0中，中断与非中断定时器事件是不同的。默认为中断。非中断意味着最初的活动**不会**被中断，而会保留。并会创建额外的执行，用于处理事件的出口转移（outgoing transition）。在XML表示中，__cancelActivity__属性设置为false。

[source,xml,linenums]
----
<boundaryEvent id="escalationTimer" cancelActivity="false" attachedToRef="firstLineSupport"/>
----

**请注意：**定时器边界事件只有在作业或异步执行器启用时才能触发（也就是说，需要在++activiti.cfg.xml++中，将__jobExecutorActivate__或者__asyncExecutorActivate__设置为++true++。因为默认情况下，作业与异步执行器都是禁用的。）


[[bpmnKnownIssueBoundaryEvent]]


===== 边界事件的已知问题 Known issue with boundary events


所有类型的边界事件，都有一个关于并发的已知问题。不能在边界事件上附加多个出口顺序流（查看问题link:$$https://activiti.atlassian.net/browse/ACT-47$$[ACT-47]）。这个问题的解决方案，是使用一条出口顺序流，指向并行网关。

image::images/bpmn.known.issue.boundary.event.png[align="center"]



[[bpmnBoundaryErrorEvent]]


==== 错误边界事件 Error Boundary Event

[[bpmnBoundaryErrorEventDescription]]


===== 描述 Description


在活动边界上的错误__捕获__中间（事件），或简称**错误边界事件**，捕获其依附的活动范围内抛出的错误。


在<<bpmnSubProcess,嵌入式子流程>>或者<<bpmnCallActivity,调用活动>>上定义错误边界事件最有意义，因为子流程会为其中的所有活动创建范围。错误由<<bpmnErrorEndEvent,错误结束事件>>抛出。这样的错误会逐层向其上级父范围传播，直到找到一个错误边界事件的范围，定义了匹配的错误事件定义。

当错误事件被捕获时，边界事件定义所在的活动会被销毁，同时销毁其中所有的当前执行（例如，并行活动，嵌套子流程，等等）。流程执行沿着边界事件的出口顺序流继续。


[[bpmnBoundaryErrorEventgraphicalNotation]]


===== 图示 Graphical notation

错误边界事件，用内部有一个错误图标的标准中间事件（两层圆圈）表示。错误图标是白色的，代表__捕获__的含义。

image::images/bpmn.boundary.error.event.png[align="center"]

[[bpmnBoundaryErrorEventXml]]


===== XML表示 Xml representation


错误边界事件与标准<<bpmnBoundaryEvent,边界事件>>一样定义：

[source,xml,linenums]
----
<boundaryEvent id="catchError" attachedToRef="mySubProcess">
  <errorEventDefinition errorRef="myError"/>
</boundaryEvent>
----

在<<bpmnBoundaryEvent,边界事件>>中，__errorRef__引用一个流程元素外定义的错误：

[source,xml,linenums]
----
<error id="myError" errorCode="123" />
...
<process id="myProcess">
...

----

**errorCode**用于匹配捕获的错误：

* 如果省略了__errorRef__，错误边界事件会捕获**所有错误事件**，无论__error__的errorCode是什么。
* 如果提供了__errorRef__，并且其引用了存在的__error__，则边界事件**只会捕获相同错误代码的错误**。
* 如果提供了__errorRef__，但BPMN 2.0文件中没有定义__error__，则**errorRef会用作errorCode**（与错误结束事件类似）。


[[bpmnBoundaryErrorEventExample]]


===== 示例 Example


下面的示例流程展示了如何使用错误结束事件。当__'Review profitability (审核盈利能力)'__用户任务完成，并指出提供的信息不足时，会抛出错误。当这个错误被子流程边界捕获时，__'Review sales lead (审核销售线索)'__子流程中的所有运行中活动都会被销毁（即使__'Review customer rating 审核客户等级'__还没有完成），并创建__'Provide additional details (提供更多信息)'__用户任务。

image::images/bpmn.boundary.error.example.png[align="center"]

这个流程作为演示配置的示例提供。可以在__org.activiti.examples.bpmn.event.error__包中找到流程XML与单元测试。


[[bpmnBoundarySignalEvent]]


==== 信号边界事件 Signal Boundary Event

[[bpmnBoundarySignalEventDescription]]


===== 描述 Description


依附在活动边界上的<<bpmnSignalEventDefinition,信号>>捕获中间（事件），或简称**信号边界事件**，捕获与其信号定义具有相同信号名的信号。

**请注意：**与其他事件例如错误边界事件相反的是，信号边界事件不只是捕获其所依附范围抛出的信号。信号边界事件为全局范围（广播）的，意味着信号可以从任何地方抛出，甚至是不同的流程实例。

**请注意：**与其他事件例如错误事件不同，信号在被捕获后不会被消耗。如果有两个激活的信号边界事件，捕获相同的信号事件，则两个边界事件都会被激活，哪怕它们不在同一个流程实例里。


[[bpmnBoundarySignalEventGraphicalNotation]]


===== 图示 Graphical notation

信号边界事件，用内部有一个信号图标的标准中间事件（两层圆圈）表示。信号图标是白色的，代表__捕获__的含义。

image::images/bpmn.boundary.signal.event.png[align="center"]


[[bpmnBoundarySignalEventXml]]


===== XML表示 XML representation

信号边界事件与标准<<bpmnBoundaryEvent,边界事件>>一样定义：

[source,xml,linenums]
----
<boundaryEvent id="boundary" attachedToRef="task" cancelActivity="true">
          <signalEventDefinition signalRef="alertSignal"/>
</boundaryEvent>
----




[[bpmnBoundarySignalEventExample]]


===== 示例 Example


查看<<bpmnSignalEventDefinition,信号事件定义>>章节内容。


[[bpmnBoundaryMessageEvent]]


==== 消息边界事件 Message Boundary Event

[[bpmnBoundaryMessageEventDescription]]


===== 描述 Description

在活动边界上的<<bpmnMessageEventDefinition,消息>>__捕获__中间（事件），或简称**消息边界事件**，捕获与其消息定义具有相同消息名的消息。


[[bpmnBoundaryMessageEventGraphicalNotation]]


===== 图示 Graphical notation

消息边界事件，用内部有一个消息图标的标准中间事件（两层圆圈）表示。信号图标是白色的，代表__捕获__的含义。

image::images/bpmn.boundary.message.event.png[align="center"]

请注意消息边界事件既可以是中断型的（右手边），也可以是非中断型的（左手边）。


[[bpmnBoundaryMessageEventXml]]


===== XML表示 XML representation


消息边界事件与标准<<bpmnBoundaryEvent,边界事件>>一样定义：

[source,xml,linenums]
----
<boundaryEvent id="boundary" attachedToRef="task" cancelActivity="true">
          <messageEventDefinition messageRef="newCustomerMessage"/>
</boundaryEvent>
----




[[bpmnBoundaryMessageEventExample]]


===== 示例 Example


查看<<bpmnMessageEventDefinition,消息事件定义>>章节内容。


[[bpmnBoundaryCancelEvent]]


==== 取消边界事件 Cancel Boundary Event

<<experimental, [EXPERIMENTAL]>>[[bpmnBoundaryCancelEventDescription]]


===== 描述 Description


依附在事务子流程边界上的取消__捕获__中间（事件），或简称**取消边界事件**，在事务取消时触发。当取消边界事件触发时，首先会中断当前范围的所有活动执行。接下来，启动事务范围内所有有效的的补偿边界事件（compensation boundary event）。补偿会同步执行，也就是说在离开事务前，边界事件会等待补偿完成。当补偿完成时，使用取消边界事件的出口顺序流，离开事务子流程。


**请注意：**一个事务子流程只允许一个取消边界事件。

**请注意：**如果事务子流程中有嵌套的子流程，只有成功完成的子流程才会触发补偿。

**请注意：**如果取消边界事件放置在具有多实例特性的事务子流程上，如果一个实例触发了取消，则边界事件将取消所有实例。


[[bpmnBoundaryCancelEventGraphicalNotation]]


===== 图示 Graphical notation


取消边界事件，用内部有一个取消图标的标准中间事件（两层圆圈）表示。取消图标是白色的（未填充），代表__捕获__的含义。

image::images/bpmn.boundary.cancel.event.png[align="center"]



[[bpmnBoundarySignalEventXml]]


===== XML表示 XML representation


取消边界事件与标准<<bpmnBoundaryEvent,边界事件>>一样定义：

[source,xml,linenums]
----
<boundaryEvent id="boundary" attachedToRef="transaction" >
          <cancelEventDefinition />
</boundaryEvent>
----

因为取消边界事件总是中断型的，因此不需要++cancelActivity++属性。


[[bpmnBoundaryCompensationEvent]]


==== 补偿边界事件 Compensation Boundary Event

<<experimental, [EXPERIMENTAL]>>[[bpmnBoundaryCompensationEventDescription]]


===== 描述 Description

依附在活动边界上的补偿__捕获__中间（事件），或简称**补偿边界事件**，可以为活动附加补偿处理器。

补偿边界事件必须通过直接关联的方式，引用单个的补偿处理器。

补偿边界事件与其它边界事件的活动策略不同。其它边界事件，例如信号边界事件，当其依附的活动启动时激活；当离开该活动时，会被解除，并取消相应的事件订阅。而补偿边界事件不是这样。补偿边界事件在其依附的活动**成功完成**时激活。同时，创建补偿事件的相应订阅。当补偿事件被触发，或者相应的流程实例结束时，才会移除订阅。因此如下判断：

* 当补偿被触发时，补偿边界事件关联的补偿处理器会被调用，次数与其依附的活动成功完成的次数相同。
* 如果补偿边界事件依附在具有多实例特性的活动上，则会为每一个实例创建补偿事件订阅。
* 如果补偿边界事件依附在位于循环内部的活动上，则每次该活动执行时，都会创建一个补偿事件订阅。
* 如果流程实例结束，则取消补偿事件的订阅。

**请注意：**嵌入式子流程不支持补偿边界事件。


[[bpmnBoundaryCompensationEventGraphicalNotation]]


===== Graphical notation


A compensation boundary event is visualized as a typical intermediate event (Circle with smaller circle inside) on the boundary, with the compensation icon inside. The compensation icon is white (unfilled), to indicate the _catching_ semantics. In addition to a compensation boundary event, the following figure shows a compensation handler associated with the boundary event using a unidirectional association:

image::images/bpmn.boundary.compensation.event.png[align="center"]


[[bpmnBoundaryCompensationEventXml]]


===== XML representation


A compensation boundary event is defined as a typical <<bpmnBoundaryEvent,boundary event>>:

[source,xml,linenums]
----
<boundaryEvent id="compensateBookHotelEvt" attachedToRef="bookHotel" >
          <compensateEventDefinition />
</boundaryEvent>

<association associationDirection="One" id="a1"  sourceRef="compensateBookHotelEvt" targetRef="undoBookHotel" />

<serviceTask id="undoBookHotel" isForCompensation="true" activiti:class="..." />
----

Since the compensation boundary event is activated after the activity has completed successfully, the +cancelActivity+ attribute is not supported.


[[bpmnIntermediateCatchingEvent]]


==== Intermediate Catching Events


All intermediate catching events are defined in the same way:

[source,xml,linenums]
----
<intermediateCatchEvent id="myIntermediateCatchEvent" >
      <XXXEventDefinition/>
</intermediateCatchEvent>
----

An intermediate catching event is defined with

* A unique identifier (process-wide)
* An XML sub-element of the form _XXXEventDefinition_ (e.g. _TimerEventDefinition_, etc.) defining the type of the intermediate catching event. See the specific catching event types for more details.


[[bpmnTimerIntermediateEvent]]


==== Timer Intermediate Catching Event

[[bpmnTimerIntermediateEventDescription]]


===== Description

A timer intermediate event acts as a stopwatch. When an execution arrives in catching event activity, a timer is started. When the timer fires (e.g. after a specified interval), the sequence flow going out of the timer intermediate event is followed.


[[bpmnTimerIntermediateEventGraphicalNotation]]


===== Graphical Notation

A timer intermediate event is visualized as an intermediate catching event, with the timer icon on the inside.

image::images/bpmn.intermediate.timer.event.png[align="center"]



[[bpmnTimerIntermediateEventXml]]


===== XML Representation


A timer intermediate event is defined as an <<bpmnIntermediateCatchingEvent,intermediate catching event>>. The specific type sub-element is in this case a *timerEventDefinition* element.

[source,xml,linenums]
----
<intermediateCatchEvent id="timer">
  <timerEventDefinition>
    <timeDuration>PT5M</timeDuration>
  </timerEventDefinition>
</intermediateCatchEvent>
----

See <<timerEventDefinitions,timer event definitions>> for configuration details.


[[bpmnIntermediateSignalEvent]]


==== Signal Intermediate Catching Event

[[bpmnIntermediateSignalEventDescription]]


===== Description

An intermediate _catching_ <<bpmnSignalEventDefinition,signal>> event catches signals with the same signal name as the referenced signal definition.

*Note:* contrary to other events like an error event, a signal is not consumed if it is caught. If you have two active signal boundary events catching the same signal event, both boundary events are triggered, even if they are part of different process instances.


[[bpmnIntermediateSignalEventGraphicalNotation]]



===== Graphical notation

An intermediate signal catch event is visualized as a typical intermediate event (Circle with smaller circle inside), with the signal icon inside. The signal icon is white (unfilled), to indicate the _catch_ semantics.

image::images/bpmn.intermediate.signal.catch.event.png[align="center"]


[[bpmnIntermediateSignalEventXml]]


===== XML representation


A signal intermediate event is defined as an <<bpmnIntermediateCatchingEvent,intermediate catching event>>. The specific type sub-element is in this case a *signalEventDefinition* element.

[source,xml,linenums]
----
<intermediateCatchEvent id="signal">
  <signalEventDefinition signalRef="newCustomerSignal" />
</intermediateCatchEvent>
----




[[bpmnIntermediateSignalEventExample]]


===== Example


See section on <<bpmnSignalEventDefinition,signal event definitions>>.


[[bpmnIntermediateMessageEvent]]


==== Message Intermediate Catching Event

[[bpmnIntermediateMessageEventDescription]]


===== Description

An intermediate _catching_ <<bpmnMessageEventDefinition,message>> event catches messages with a specified name.


[[bpmnIntermediateMessageEventGraphicalNotation]]


===== Graphical notation

An intermediate catching message event is visualized as a typical intermediate event (Circle with smaller circle inside), with the message icon inside. The message icon is white (unfilled), to indicate the _catch_ semantics.

image::images/bpmn.intermediate.message.catch.event.png[align="center"]



[[bpmnIntermediateSignalEventXml]]


===== XML representation

A message intermediate event is defined as an <<bpmnIntermediateCatchingEvent,intermediate catching event>>. The specific type sub-element is in this case a *messageEventDefinition* element.

[source,xml,linenums]
----
<intermediateCatchEvent id="message">
  <messageEventDefinition signalRef="newCustomerMessage" />
</intermediateCatchEvent>
----




[[bpmnIntermediateMessageEventExample]]


===== Example

See section on <<bpmnMessageEventDefinition,message event definitions>>.


[[bpmnIntermediateThrowEvent]]


==== Intermediate Throwing Event


All intermediate throwing events are defined in the same way:

[source,xml,linenums]
----
<intermediateThrowEvent id="myIntermediateThrowEvent" >
      <XXXEventDefinition/>
</intermediateThrowEvent>
----

An intermediate throwing event is defined with

* A unique identifier (process-wide)
* An XML sub-element of the form _XXXEventDefinition_ (e.g. _signalEventDefinition_, etc.) defining the type of the intermediate throwing event. See the specific throwing event types for more details.

[[bpmnIntermediateThrowNoneEvent]]


==== Intermediate Throwing None Event

The following process diagram shows a simple example of an intermediate none event, which is often used to indicate some state achieved in the process.

image::images/bpmn.intermediate.none.event.png[align="center"]

This can be a good hook to monitor some KPI's, basically by adding an <<executionListeners,execution listener>>.

[source,xml,linenums]
----
<intermediateThrowEvent id="noneEvent">
  <extensionElements>
    <activiti:executionListener class="org.activiti.engine.test.bpmn.event.IntermediateNoneEventTest$MyExecutionListener" event="start" />
  </extensionElements>
</intermediateThrowEvent>

----


There you can add some own code to maybe send some event to your BAM tool or DWH. The engine itself doesn't do anything in that event, it just passes through.


[[bpmnIntermediateThrowSignalEvent]]


==== Signal Intermediate Throwing Event

[[bpmnIntermediateThrowSignalEventDescription]]


===== Description


An intermediate _throwing_ <<bpmnSignalEventDefinition,signal>> event throws a signal event for a defined signal.

In Activiti, the signal is broadcast to all active handlers (i.e. all catching signal events). Signals can be published synchronous or asynchronous.

* In the default configuration, the signal is delivered *synchronously*. This means that the throwing process instance waits until the signal is delivered to all catching process instances. The catching process instances are also notified in the same transaction as the throwing process instance, which means that if one of the notified instances produces a technical error (throws an exception), all involved instances fail.
* A signal can also be delivered *asynchronously*. In that case it is determined which handlers are active at the time the throwing signal event is reached. For each active handler, an asynchronous notification message (Job) is stored and delivered by the JobExecutor.


[[bpmnIntermediateThrowSignalEventGraphicalNotation]]


===== Graphical notation

An intermediate signal throw event is visualized as a typical intermediate event (Circle with smaller circle inside), with the signal icon inside. The signal icon is black (filled), to indicate the _throw_ semantics.

image::images/bpmn.intermediate.signal.throw.event.png[align="center"]



[[bpmnIntermediateThrowSignalEventXml]]


===== XML representation


A signal intermediate event is defined as an <<bpmnIntermediateThrowEvent,intermediate throwing event>>. The specific type sub-element is in this case a *signalEventDefinition* element.

[source,xml,linenums]
----
<intermediateThrowEvent id="signal">
  <signalEventDefinition signalRef="newCustomerSignal" />
</intermediateThrowEvent>
----

An asynchronous signal event would look like this:

[source,xml,linenums]
----
<intermediateThrowEvent id="signal">
  <signalEventDefinition signalRef="newCustomerSignal" activiti:async="true" />
</intermediateThrowEvent>
----




[[bpmnIntermediateSignalEventExample]]


===== Example


See section on <<bpmnSignalEventDefinition,signal event definitions>>.


[[bpmnIntermediateThrowCompensationEvent]]


==== Compensation Intermediate Throwing Event

<<experimental, [EXPERIMENTAL]>>[[bpmnIntermediateThrowCompensationEventDescription]]


===== Description

An intermediate _throwing_ compensation event can be used to trigger compensation.


*Triggering compensation:* Compensation can either be triggered for a designated activity or for the scope which hosts the compensation event. Compensation is performed through execution of the compensation handler associated with an activity.

* When compensation is thrown for an activity, the associated compensation handler is executed the same number of times the activity competed successfully.
* If compensation is thrown for the current scope, all activities within the current scope are compensated, which includes activities on concurrent branches.
* Compensation is triggered hierarchically: if an activity to be compensated is a subprocess, compensation is triggered for all activities contained in the subprocess. If the subprocess has nested activities, compensation is thrown recursively. However, compensation is not propagated to the "upper levels" of the process: if compensation is triggered within a subprocess, it is not propagated to activities outside of the subprocess scope. The BPMN specification states that compensation is triggered for activities at "the same level of subprocess".
* In Activiti compensation is performed in reverse order of execution. This means that whichever activity completed last is compensated first, etc.
* The intermediate throwing compensation event can be used to compensate transaction subprocesses which competed successfully.

*Note:* If compensation is thrown within a scope which contains a subprocess and the subprocess contains activities with compensation handlers, compensation is only propagated to the subprocess if it has completed successfully when compensation is thrown. If some of the activities nested inside the subprocess have completed and have attached compensation handlers, the compensation handlers are not executed if the subprocess containing these activities is not completed yet. Consider the following example:

image::images/bpmn.throw.compensation.example1.png[align="center"]

In this process we have two concurrent executions, one executing the embedded subprocess and one executing the "charge credit card" activity. Let's assume both executions are started and the first concurrent execution is waiting for a user to complete the "review bookings" task. The second execution performs the "charge credit card" activity and an error is thrown, which causes the "cancel reservations" event to trigger compensation. At this point the parallel subprocess is not yet completed which means that the compensation event is not propagated to the subprocess and thus the "cancel hotel reservation"  compensation handler is not executed. If the user task (and thus the embedded subprocess) completes before the "cancel reservations" is performed, compensation is propagated to the embedded subprocess.

*Process variables:* When compensating an embedded subprocess, the execution used for executing the compensation handlers has access to the local process variables of the subprocess in the state they were in when the subprocess completed execution. To achieve this, a snapshot of the process variables associated with the scope execution (execution created for executing the subprocess) is taken. Form this, a couple of implications follow:

* The compensation handler does not have access to variables added to concurrent executions created inside the subprocess scope.
* Process variables associated with executions higher up in the hierarchy, (for instance process variables associated with the process instance execution are not contained in the snapshot: the compensation handler has access to these process variables in the state they are in when compensation is thrown.
* A variable snapshot is only taken for embedded subprocesses, not for other activities.

*Current limitations:*

* +waitForCompletion="false"+ is currently unsupported. When compensation is triggered using the intermediate throwing compensation event, the event is only left, after compensation completed successfully.
* Compensation itself is currently performed by concurrent executions. The concurrent executions are started in reverse order in which the compensated activities completed. Future versions of activity might include an option to perform compensation sequentially.
* Compensation is not propagated to sub process instances spawned by call activities.


[[bpmnIntermediateThrowCompensationEventGraphicalNotation]]


===== Graphical notation

An intermediate compensation throw event is visualized as a typical intermediate event (Circle with smaller circle inside), with the compensation icon inside. The compensation icon is black (filled), to indicate the _throw_ semantics.

image::images/bpmn.intermediate.compensation.throw.event.png[align="center"]



[[bpmnIntermediateThrowSignalEventXml]]


===== Xml representation


A compensation intermediate event is defined as an <<bpmnIntermediateThrowEvent,intermediate throwing event>>. The specific type sub-element is in this case a *compensateEventDefinition* element.

[source,xml,linenums]
----
<intermediateThrowEvent id="throwCompensation">
	<compensateEventDefinition />
</intermediateThrowEvent>
----

In addition, the optional argument +activityRef+ can be used to trigger compensation of a specific scope / activity:

[source,xml,linenums]
----
<intermediateThrowEvent id="throwCompensation">
	<compensateEventDefinition activityRef="bookHotel" />
</intermediateThrowEvent>
----


[[bpmnSequenceFlow]]


=== Sequence Flow

[[sequenceFlowDescription]]


==== Description

A sequence flow is the connector between two elements of a process. After an element is visited during process execution, all outgoing sequence flow will be followed. This means that the default nature of BPMN 2.0 is to be parallel: two outgoing sequence flow will create two separate, parallel paths of execution.


[[sequenceFlowGraphicalNotation]]


==== Graphical notation

A sequence flow is visualized as an arrow going from the source element towards the target element. The arrow always points towards the target.

image::images/bpmn.sequence.flow.png[align="center"]



[[sequenceFlowXml]]


==== XML representation


Sequence flow need to have a process-unique *id*, and a reference to an existing *source* and *target* element.

[source,xml,linenums]
----
<sequenceFlow id="flow1" sourceRef="theStart" targetRef="theTask" />
----




[[bpmnConditionalSequenceFlow]]


==== Conditional sequence flow

[[condSeqFlowDescription]]


===== Description

A sequence flow can have a condition defined on it. When a BPMN 2.0 activity is left, the default behavior is to evaluate the conditions on the outgoing sequence flow. When a condition evaluates to _true_, that outgoing sequence flow is selected. When multiple sequence flow are selected that way, multiple _executions_ will be generated and the process will be continued in a parallel way.

*Note:* the above holds for BPMN 2.0 activities (and events), but not for gateways. Gateways will handle sequence flow with conditions in specific ways, depending on the gateway type.


[[conditionalSequenceFlowGraphicalNotation]]


===== Graphical notation

A conditional sequence flow is visualized as a regular sequence flow, with a small diamond at the beginning. The condition expression is shown next to the sequence flow.

image::images/bpmn.conditional.sequence.flow.png[align="center"]


[[conditionalSequenceFlowXml]]


===== XML representation


A conditional sequence flow is represented in XML as a regular sequence flow, containing a *conditionExpression* sub-element. Note that for the moment only _tFormalExpressions_ are supported, Omitting the _xsi:type=""_ definition will simply default to this only supported type of expressions.

[source,xml,linenums]
----
<sequenceFlow id="flow" sourceRef="theStart" targetRef="theTask">
  <conditionExpression xsi:type="tFormalExpression">
    <![CDATA[${order.price > 100 && order.price < 250}]]>
  </conditionExpression>
</sequenceFlow>
----

Currently conditionalExpressions can *only be used with UEL*, detailed info about these can be found in section <<apiExpressions,Expressions>>. The expression used should resolve to a boolean value, otherwise an exception is thrown while evaluating the condition.

* The example below references data of a process variable, in the typical JavaBean style through getters.

[source,xml,linenums]
----
<conditionExpression xsi:type="tFormalExpression">
  <![CDATA[${order.price > 100 && order.price < 250}]]>
</conditionExpression>
----

* This example invokes a method that resolves to a boolean value.

[source,xml,linenums]
----
<conditionExpression xsi:type="tFormalExpression">
  <![CDATA[${order.isStandardOrder()}]]>
</conditionExpression>
----


The Activiti distribution contains the following example process using value and method expressions (see __org.activiti.examples.bpmn.expression)__:

image::images/bpmn.uel-expression.on.seq.flow.png[align="center"]


[[bpmnDefaultSequenceFlow]]


==== Default sequence flow

[[bpmnDefaultSequenceFlowDescription]]


===== Description


All BPMN 2.0 tasks and gateways can have a *default sequence flow*. This sequence flow is only selected as the outgoing sequence flow for that activity if and only if none of the other sequence flow could be selected. Conditions on a default sequence flow are always ignored.


[[bpmnDefaultSequenceFlowGraphicalNotation]]


===== Graphical notation


A default sequence flow is visualized as a regular sequence flow, with a 'slash' marker at the beginning.

image::images/bpmn.default.sequence.flow.png[align="center"]



[[bpmnDefaultSequenceFlowXmlRepresentation]]


===== XML representation


A default sequence flow for a certain activity is defined by the *default attribute* on that activity. The following XML snippet shows for example an exclusive gateway that has as default sequence flow _flow 2_. Only when _conditionA_ and _conditionB_ both evaluate to false, will it be chosen as outgoing sequence flow for the gateway.

[source,xml,linenums]
----
<exclusiveGateway id="exclusiveGw" name="Exclusive Gateway" default="flow2" />
<sequenceFlow id="flow1" sourceRef="exclusiveGw" targetRef="task1">
  <conditionExpression xsi:type="tFormalExpression">${conditionA}</conditionExpression>
</sequenceFlow>
<sequenceFlow id="flow2" sourceRef="exclusiveGw" targetRef="task2"/>
<sequenceFlow id="flow3" sourceRef="exclusiveGw" targetRef="task3">
  <conditionExpression xsi:type="tFormalExpression">${conditionB}</conditionExpression>
</sequenceFlow>
----


Which corresponds with the following graphical representation:


[[bpmnGateways]]


=== Gateways


A gateway is used to control the flow of execution (or as the BPMN 2.0 describes, the _tokens_ of execution). A gateway is capable of _consuming_ or _generating_ tokens.

A gateway is graphically visualized as a diamond shape, with an icon inside. The icon shows the type of gateway.

image::images/bpmn.gateway.png[align="center"]


[[bpmnExclusiveGateway]]


==== Exclusive Gateway

[[exclusiveGatewayDescription]]


===== Description

An exclusive gateway (also called the _XOR gateway_ or more technical the __exclusive data-based gateway__), is used to model a *decision* in the process. When the execution arrives at this gateway, all outgoing sequence flow are evaluated in the order in which they are defined. The sequence flow which condition evaluates to true (or which doesn't have a condition set, conceptually having a _'true'_ defined on the sequence flow) is selected for continuing the process.

*Note that the semantics of outgoing sequence flow is different to that of the general case in BPMN 2.0. While in general all sequence flow which condition evaluates to true are selected to continue in a parallel way, only one sequence flow is selected when using the exclusive gateway. In case multiple sequence flow have a condition that evaluates to true, the first one defined in the XML (and only that one!) is selected for continuing the process. If no sequence flow can be selected, an exception will be thrown.*


[[exclusiveGatewayGraphNotation]]


===== Graphical notation


An exclusive gateway is visualized as a typical gateway (i.e. a diamond shape) with an 'X' icon inside, referring to the _XOR_ semantics. Note that a gateway without an icon inside defaults to an exclusive gateway. The BPMN 2.0 specification does not allow mixing the diamond with and without an X in the same process definition.

image::images/bpmn.exclusive.gateway.notation.png[align="center"]


[[exclusiveGatewayXML]]


===== XML representation


The XML representation of an exclusive gateway is straight-forward: one line defining the gateway and condition expressions defined on the outgoing sequence flow. See the section on <<bpmnConditionalSequenceFlow,conditional sequence flow>> to see which options are available for such expressions.

Take for example the following model:

image::images/bpmn.exclusive.gateway.png[align="center"]

Which is represented in XML as follows:

[source,xml,linenums]
----
<exclusiveGateway id="exclusiveGw" name="Exclusive Gateway" />

<sequenceFlow id="flow2" sourceRef="exclusiveGw" targetRef="theTask1">
  <conditionExpression xsi:type="tFormalExpression">${input == 1}</conditionExpression>
</sequenceFlow>

<sequenceFlow id="flow3" sourceRef="exclusiveGw" targetRef="theTask2">
  <conditionExpression xsi:type="tFormalExpression">${input == 2}</conditionExpression>
</sequenceFlow>

<sequenceFlow id="flow4" sourceRef="exclusiveGw" targetRef="theTask3">
  <conditionExpression xsi:type="tFormalExpression">${input == 3}</conditionExpression>
</sequenceFlow>
----


[[bpmnParallelGateway]]


==== Parallel Gateway

[[bpmnParallelGatewayDescription]]


===== Description


Gateways can also be used to model concurrency in a process. The most straightforward gateway to introduce concurrency in a process model, is the *Parallel Gateway*, which allows to _fork_ into multiple paths of execution or _join_ multiple incoming paths of execution.

The functionality of the parallel gateway is based on the incoming and outgoing sequence flow:

* *fork:* all outgoing sequence flow are followed in parallel, creating one concurrent execution for each sequence flow.
* *join:* all concurrent executions arriving at the parallel gateway wait in the gateway until an execution has arrived for each of the incoming sequence flow. Then the process continues past the joining gateway.


Note that a parallel gateway can have *both fork and join behavior*, if there are multiple incoming and outgoing sequence flow for the same parallel gateway. In that case, the gateway will first join all incoming sequence flow, before splitting into multiple concurrent paths of executions.

*An important difference with other gateway types is that the parallel gateway does not evaluate conditions. If conditions are defined on the sequence flow connected with the parallel gateway, they are simply neglected.*


[[bpmnParallelGatewayGraphicalNotation]]


===== Graphical Notation

A parallel gateway is visualized as a gateway (diamond shape) with the 'plus' symbol inside, referring to the 'AND' semantics.

image::images/bpmn.parallel.gateway.png[align="center"]

[[bpmnParallelGatewayXML]]


===== XML representation


Defining a parallel gateway needs one line of XML:

[source,xml,linenums]
----
<parallelGateway id="myParallelGateway" />
----


The actual behavior (fork, join or both), is defined by the sequence flow connected to the parallel gateway.

For example, the model above comes down to the following XML:

[source,xml,linenums]
----
<startEvent id="theStart" />
<sequenceFlow id="flow1" sourceRef="theStart" targetRef="fork" />

<parallelGateway id="fork" />
<sequenceFlow sourceRef="fork" targetRef="receivePayment" />
<sequenceFlow sourceRef="fork" targetRef="shipOrder" />

<userTask id="receivePayment" name="Receive Payment" />
<sequenceFlow sourceRef="receivePayment" targetRef="join" />

<userTask id="shipOrder" name="Ship Order" />
<sequenceFlow sourceRef="shipOrder" targetRef="join" />

<parallelGateway id="join" />
<sequenceFlow sourceRef="join" targetRef="archiveOrder" />

<userTask id="archiveOrder" name="Archive Order" />
<sequenceFlow sourceRef="archiveOrder" targetRef="theEnd" />

<endEvent id="theEnd" />
----


In the above example, after the process is started, two tasks will be created:

[source,java,linenums]
----
ProcessInstance pi = runtimeService.startProcessInstanceByKey("forkJoin");
TaskQuery query = taskService.createTaskQuery()
                         .processInstanceId(pi.getId())
                         .orderByTaskName()
                         .asc();

List<Task> tasks = query.list();
assertEquals(2, tasks.size());

Task task1 = tasks.get(0);
assertEquals("Receive Payment", task1.getName());
Task task2 = tasks.get(1);
assertEquals("Ship Order", task2.getName());
----


When these two tasks are completed, the second parallel gateway will join the two executions and since there is only one outgoing sequence flow, no concurrent paths of execution will be created, and only the _Archive Order_ task will be active.

Note that a parallel gateway does not need to be 'balanced' (i.e. a matching number of incoming/outgoing sequence flow for corresponding parallel gateways). A parallel gateway will simply wait for all incoming sequence flow and create a concurrent path of execution for each outgoing sequence flow, not influenced by other constructs in the process model. So, the following process is legal in BPMN 2.0:

image::images/bpmn.unbalanced.parallel.gateway.png[align="center"]

[[bpmnInclusiveGateway]]


==== Inclusive Gateway

[[bpmnInclusiveGatewayDescription]]


===== Description


The *Inclusive Gateway* can be seen as a combination of an exclusive and a parallel gateway. Like an exclusive gateway you can define conditions on outgoing sequence flows and the inclusive gateway will evaluate them. But the main difference is that the inclusive gateway can take more than one sequence flow, like the parallel gateway.

The functionality of the inclusive gateway is based on the incoming and outgoing sequence flow:

* *fork:* all outgoing sequence flow conditions are evaluated and for the sequence flow conditions that evaluate to true the flows are followed in parallel, creating one concurrent execution for each sequence flow.
* *join:* all concurrent executions arriving at the inclusive gateway wait in the gateway until an execution has arrived for each of the incoming sequence flows that have a process token. This is an important difference with the parallel gateway. So in other words, the inclusive gateway will only wait for the incoming sequence flows that will be executed. After the join, the process continues past the joining inclusive gateway.


Note that an inclusive gateway can have *both fork and join behavior*, if there are multiple incoming and outgoing sequence flow for the same inclusive gateway. In that case, the gateway will first join all incoming sequence flows that have a process token, before splitting into multiple concurrent paths of executions for the outgoing sequence flows that have a condition that evaluates to true.


[[bpmnInclusiveGatewayGraphicalNotation]]


===== Graphical Notation


An inclusive gateway is visualized as a gateway (diamond shape) with the 'circle' symbol inside.

image::images/bpmn.inclusive.gateway.png[align="center"]



[[bpmnInclusiveGatewayXML]]


===== XML representation


Defining an inclusive gateway needs one line of XML:

[source,xml,linenums]
----
<inclusiveGateway id="myInclusiveGateway" />
----


The actual behavior (fork, join or both), is defined by the sequence flows connected to the inclusive gateway.

For example, the model above comes down to the following XML:

[source,xml,linenums]
----
<startEvent id="theStart" />
<sequenceFlow id="flow1" sourceRef="theStart" targetRef="fork" />

<inclusiveGateway id="fork" />
<sequenceFlow sourceRef="fork" targetRef="receivePayment" >
  <conditionExpression xsi:type="tFormalExpression">${paymentReceived == false}</conditionExpression>
</sequenceFlow>
<sequenceFlow sourceRef="fork" targetRef="shipOrder" >
  <conditionExpression xsi:type="tFormalExpression">${shipOrder == true}</conditionExpression>
</sequenceFlow>

<userTask id="receivePayment" name="Receive Payment" />
<sequenceFlow sourceRef="receivePayment" targetRef="join" />

<userTask id="shipOrder" name="Ship Order" />
<sequenceFlow sourceRef="shipOrder" targetRef="join" />

<inclusiveGateway id="join" />
<sequenceFlow sourceRef="join" targetRef="archiveOrder" />

<userTask id="archiveOrder" name="Archive Order" />
<sequenceFlow sourceRef="archiveOrder" targetRef="theEnd" />

<endEvent id="theEnd" />
----


In the above example, after the process is started, two tasks will be created if the process variables paymentReceived == false and shipOrder == true. In case only one of these process variables equals to true only one task will be created. If no condition evaluates to true and exception is thrown. This can be prevented by specifying a default outgoing sequence flow. In the following example one task will be created, the ship order task:

[source,java,linenums]
----
HashMap<String, Object> variableMap = new HashMap<String, Object>();
          variableMap.put("receivedPayment", true);
          variableMap.put("shipOrder", true);
          ProcessInstance pi = runtimeService.startProcessInstanceByKey("forkJoin");
TaskQuery query = taskService.createTaskQuery()
                         .processInstanceId(pi.getId())
                         .orderByTaskName()
                         .asc();

List<Task> tasks = query.list();
assertEquals(1, tasks.size());

Task task = tasks.get(0);
assertEquals("Ship Order", task.getName());
----


When this task is completed, the second inclusive gateway will join the two executions and since there is only one outgoing sequence flow, no concurrent paths of execution will be created, and only the _Archive Order_ task will be active.

Note that an inclusive gateway does not need to be 'balanced' (i.e. a matching number of incoming/outgoing sequence flow for corresponding inclusive gateways). An inclusive gateway will simply wait for all incoming sequence flow and create a concurrent path of execution for each outgoing sequence flow, not influenced by other constructs in the process model.


[[bpmnEventbasedGateway]]


==== Event-based Gateway

[[eventBasedGatewayDescription]]


===== Description


The Event-based Gateway allows to take a decision based on events. Each outgoing sequence flow of the gateway needs to be connected to an intermediate catching event. When process execution reaches an Event-based Gateway, the gateway acts like a wait state: execution is suspended. In addition, for each outgoing sequence flow, an event subscription is created.

Note the sequence flows running out of an Event-based Gateway are different from ordinary sequence flows. These sequence flows are never actually "executed". On the contrary, they allow the process engine to determine which events an execution arriving at an Event-based Gateway needs to subscribe to. The following restrictions apply:

* An Event-based Gateway must have two or more outgoing sequence flows.
* An Event-based Gateway must only be connected to elements of type +intermediateCatchEvent+ only. (Receive Tasks after an Event-based Gateway are not supported by Activiti.)
* An +intermediateCatchEvent+ connected to an Event-based Gateway must have a single incoming sequence flow.



[[eventBasedGatewayGraphNotation]]


===== Graphical notation


An Event-based Gateway is visualized as a diamond shape like other BPMN gateways with a special icon inside.

image::images/bpmn.event.based.gateway.notation.png[align="center"]



[[eventBasedGatewayXML]]


===== XML representation


The XML element used to define an Event-based Gateway is +eventBasedGateway+.


[[eventBasedGatewayExample]]


===== Example(s)


The following process is an example of a process with an Event-based Gateway. When the execution arrives at the Event-based Gateway, process execution is suspended. In addition, the process instance subscribes to the alert signal event and created a timer which fires after 10 minutes. This effectively causes the process engine to wait for ten minutes for a signal event. If the signal occurs within 10 minutes, the timer is cancelled and execution continues after the signal. If the signal is not fired, execution continues after the timer and the signal subscription is cancelled.

image::images/bpmn.event.based.gateway.example.png[align="center"]


[source,xml,linenums]
----
<definitions id="definitions"
	xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL"
	xmlns:activiti="http://activiti.org/bpmn"
	targetNamespace="Examples">

	<signal id="alertSignal" name="alert" />

	<process id="catchSignal">

		<startEvent id="start" />

		<sequenceFlow sourceRef="start" targetRef="gw1" />

		<eventBasedGateway id="gw1" />

		<sequenceFlow sourceRef="gw1" targetRef="signalEvent" />
		<sequenceFlow sourceRef="gw1" targetRef="timerEvent" />

		<intermediateCatchEvent id="signalEvent" name="Alert">
			<signalEventDefinition signalRef="alertSignal" />
		</intermediateCatchEvent>

		<intermediateCatchEvent id="timerEvent" name="Alert">
			<timerEventDefinition>
				<timeDuration>PT10M</timeDuration>
			</timerEventDefinition>
		</intermediateCatchEvent>

		<sequenceFlow sourceRef="timerEvent" targetRef="exGw1" />
		<sequenceFlow sourceRef="signalEvent" targetRef="task" />

		<userTask id="task" name="Handle alert"/>

		<exclusiveGateway id="exGw1" />

		<sequenceFlow sourceRef="task" targetRef="exGw1" />
		<sequenceFlow sourceRef="exGw1" targetRef="end" />

		<endEvent id="end" />
</process>
</definitions>
----




[[bpmnTask]]


=== Tasks

[[bpmnUserTask]]


==== User Task

[[bpmnUserTaskDescription]]


===== Description


A 'user task' is used to model work that needs to be done by a human actor. When the process execution arrives at such a user task, a new task is created in the task list of the user(s) or group(s) assigned to that task.


[[bpmnUserTaskGraphicalNotation]]


===== Graphical notation


A user task is visualized as a typical task (rounded rectangle), with a small user icon in the left upper corner.

image::images/bpmn.user.task.png[align="center"]



[[bpmnUserTaskXml]]


===== XML representation

A user task is defined in XML as follows. The _id_ attribute is required, the _name_ attribute is optional.

[source,xml,linenums]
----
<userTask id="theTask" name="Important task" />
----

A user task can have also a description. In fact any BPMN 2.0 element can have a description. A description is defined by adding the *documentation* element.

[source,xml,linenums]
----

<userTask id="theTask" name="Schedule meeting" >
  <documentation>
	  Schedule an engineering meeting for next week with the new hire.
  </documentation>
----



The description text can be retrieved from the task in the standard Java way:

[source,java,linenums]
----
task.getDescription()
----


[[bpmnUserTaskDueDate]]


===== Due Date


Each task has a field, indicating the due date of that task. The Query API can be used to query for tasks that are due on, before or after a certain date.

There is an activity extension which allows you to specify an expression in your task-definition to set the initial due date of a task when it is created. The expression *should always resolve to a +java.util.Date+, +java.util.String (ISO8601 formatted)+, ISO8601 time-duration (e.g. PT50M) or +null+*. For example, you could use a date that was entered in a previous form in the process or calculated in a previous Service Task. In case a time-duration is used, the due-date is calculated based on the current time, incremented by the given period. For example, when "PT30M" is used as dueDate, the task is due in thirty minutes from now.

[source,xml,linenums]
----
<userTask id="theTask" name="Important task" activiti:dueDate="${dateVariable}"/>
----

The due date of a task can also be altered using the +TaskService+ or in ++TaskListener++s using the passed +DelegateTask+.


[[bpmnUserTaskAssignment]]


===== User assignment


A user task can be directly assigned to a user. This is done by defining a *humanPerformer* sub element. Such a _humanPerformer_ definition needs a *resourceAssignmentExpression* that actually defines the user. Currently, only *formalExpressions* are supported.

[source,xml,linenums]
----
<process >

  ...

  <userTask id='theTask' name='important task' >
    <humanPerformer>
      <resourceAssignmentExpression>
        <formalExpression>kermit</formalExpression>
      </resourceAssignmentExpression>
    </humanPerformer>
  </userTask>
----

*Only one* user can be assigned as human performer to the task. In Activiti terminology, this user is called the *assignee*. Tasks that have an assignee are not visible in the task lists of other people and  can be found in the so-called *personal task list* of the assignee instead.

Tasks directly assigned to users can be retrieved through the TaskService as follows:

[source,java,linenums]
----
List<Task> tasks = taskService.createTaskQuery().taskAssignee("kermit").list();
----

Tasks can also be put in the so-called *candidate task list* of people. In that case, the *potentialOwner* construct must be used. The usage is similar to the _humanPerformer_ construct. Do note that it is required to define for each element in the formal expression to specify if it is a user or a group (the engine cannot guess this).

[source,xml,linenums]
----
<process >

  ...

  <userTask id='theTask' name='important task' >
    <potentialOwner>
      <resourceAssignmentExpression>
        <formalExpression>user(kermit), group(management)</formalExpression>
      </resourceAssignmentExpression>
    </potentialOwner>
  </userTask>
----

Tasks defines with the _potential owner_ construct, can be retrieved as follows (or a similar _TaskQuery_ usage as for the tasks with an assignee):

[source,java,linenums]
----
 List<Task> tasks = taskService.createTaskQuery().taskCandidateUser("kermit");
----


This will retrieve all tasks where kermit is a *candidate user*, i.e. the formal expression contains _user(kermit)_. This will also retrieve all tasks that are *assigned to a group where kermit is a member of* (e.g. _group(management)_, if kermit is a member of that group and the Activiti identity component is used). The groups of a user are resolved at runtime and these can be managed through the <<apiEngine,IdentityService>>.

If no specifics are given whether the given text string is a user or group, the engine defaults to group. So the following would be the same as when _group(accountancy) was declared_.

[source,xml,linenums]
----
<formalExpression>accountancy</formalExpression>
----


[[bpmnUserTaskUserAssignmentExtension]]


===== Activiti extensions for task assignment

It is clear that user and group assignments are quite cumbersome for use cases where the assignment is not complex. To avoid these complexities, <<bpmnCustomExtensions,custom extensions>> on the user task are possible.

* *assignee attribute*: this custom extension allows to directly assign a user task to a given user.

[source,xml,linenums]
----
<userTask id="theTask" name="my task" activiti:assignee="kermit" />
----

This is exactly the same as using a *humanPerformer* construct as defined <<bpmnUserTaskAssignment,above>>.

* *candidateUsers attribute*: this custom extension allows to make a user a candidate for a task.

[source,xml,linenums]
----
<userTask id="theTask" name="my task" activiti:candidateUsers="kermit, gonzo" />
----

This is exactly the same as using a *potentialOwner* construct as defined <<bpmnUserTaskAssignment,above>>. Note that it is not required to use the _user(kermit)_ declaration as is the case with the _potential owner_ construct, since the attribute can only be used for users.

* *candidateGroups attribute*: this custom extension allows to make a group a candidate for a task.

[source,xml,linenums]
----
<userTask id="theTask" name="my task" activiti:candidateGroups="management, accountancy" />
----

This is exactly the same as using a *potentialOwner* construct as defined <<bpmnUserTaskAssignment,above>>. Note that it is not required to use the _group(management)_ declaration as is the case with the _potential owner_ construct, since the attribute can only be used for groups.

* _candidateUsers_ and _candidateGroups_ can both be defined on the same user task.

Note: Although Activiti provides an identity management component, which is exposed through the <<apiEngine,IdentityService>>, no check is done whether a provided user is known by the identity component. This allows Activiti to integrate with existing identity management solutions when it is embedded into an application.


[[bpmnUserTaskUserCustomIdentityLinkAssignmentExtension]]


===== Custom identity link types (Experimental)

<<experimental,[EXPERIMENTAL]>>

The BPMN standard supports a single assigned user or *humanPerformer* or a set of users that form a potential pool of *potentialOwners* as defined in <<bpmnUserTaskAssignment,User assignment>>. In addition, Activiti defines <<bpmnUserTaskUserAssignmentExtension,extension attribute elements>> for the User Task that can represent the task *assignee* or *candidate owner*.

The supported Activiti identity link types are:

[source,java,linenums]
----
public class IdentityLinkType {
  /* Activiti native roles */
  public static final String ASSIGNEE = "assignee";
  public static final String CANDIDATE = "candidate";
  public static final String OWNER = "owner";
  public static final String STARTER = "starter";
  public static final String PARTICIPANT = "participant";
}
----

The BPMN standard and Activiti example authorization identities are *user* and *group*. As mentioned in the previous section, the Activiti identity management implementation is not intended for production use, but should be extended depending upon the supported authorization scheme.

If additional link types are required, custom resources can be defined as extension elements with the following syntax:

[source,xml,linenums]
----
<userTask id="theTask" name="make profit">
  <extensionElements>
    <activiti:customResource activiti:name="businessAdministrator">
      <resourceAssignmentExpression>
        <formalExpression>user(kermit), group(management)</formalExpression>
      </resourceAssignmentExpression>
    </activiti:customResource>
  </extensionElements>
</userTask>
----

The custom link expressions are added to the _TaskDefinition_ class:

[source,java,linenums]
----

protected Map<String, Set<Expression>> customUserIdentityLinkExpressions =
      new HashMap<String, Set<Expression>>();
protected Map<String, Set<Expression>> customGroupIdentityLinkExpressions =
      new HashMap<String, Set<Expression>>();

public Map<String,
         Set<Expression>> getCustomUserIdentityLinkExpressions() {
  return customUserIdentityLinkExpressions;
}

public void addCustomUserIdentityLinkExpression(String identityLinkType,
      Set<Expression> idList)
  customUserIdentityLinkExpressions.put(identityLinkType, idList);
}

public Map<String,
       Set<Expression>> getCustomGroupIdentityLinkExpressions() {
  return customGroupIdentityLinkExpressions;
}

public void addCustomGroupIdentityLinkExpression(String identityLinkType,
       Set<Expression> idList) {
  customGroupIdentityLinkExpressions.put(identityLinkType, idList);
}
----

which are populated at runtime by the _UserTaskActivityBehavior handleAssignments_ method.

Finally, the _IdentityLinkType_ class must be extended to support the custom identity link types:

[source,java,linenums]
----
package com.yourco.engine.task;

public class IdentityLinkType
    extends org.activiti.engine.task.IdentityLinkType
{
    public static final String ADMINISTRATOR = "administrator";

    public static final String EXCLUDED_OWNER = "excludedOwner";
}
----


[[bpmnUserTaskUserCustomAssignmentTaskListeners]]


===== Custom Assignment via task listeners


In case the previous approaches are not sufficient, it is possible to delegate to custom assignment logic using a <<taskListeners,task listener>> on the create event:

[source,xml,linenums]
----
<userTask id="task1" name="My task" >
  <extensionElements>
    <activiti:taskListener event="create" class="org.activiti.MyAssignmentHandler" />
  </extensionElements>
</userTask>
----

The +DelegateTask+ that is passed to the +TaskListener+ implementation, allows to set the assignee and candidate-users/groups:

[source,java,linenums]
----
public class MyAssignmentHandler implements TaskListener {

  public void notify(DelegateTask delegateTask) {
    // Execute custom identity lookups here

    // and then for example call following methods:
    delegateTask.setAssignee("kermit");
    delegateTask.addCandidateUser("fozzie");
    delegateTask.addCandidateGroup("management");
    ...
  }

}
----

When using Spring it is possible to use the custom assignment attributes as described in the section above, and delegate to a Spring bean using a <<taskListeners,task listener>> with an <<springExpressions,expression>> that listens to task _create_ events. In the following example, the assignee will be set by calling the +findManagerOfEmployee+ on the +ldapService+ Spring bean. The _emp_ parameter that is passed, is a process variable>.

[source,xml,linenums]
----
<userTask id="task" name="My Task" activiti:assignee="${ldapService.findManagerForEmployee(emp)}"/>
----

This also works similar for candidate users and groups:

[source,xml,linenums]
----
<userTask id="task" name="My Task" activiti:candidateUsers="${ldapService.findAllSales()}"/>
----

Note that this will only work if the return type of the invoked methods is +String+ or +Collection<String>+ (for candidate users and groups):

[source,java,linenums]
----
public class FakeLdapService {

  public String findManagerForEmployee(String employee) {
    return "Kermit The Frog";
  }

  public List<String> findAllSales() {
    return Arrays.asList("kermit", "gonzo", "fozzie");
  }

}
----



[[bpmnScriptTask]]


==== Script Task

[[bpmnScriptTaskDescription]]


===== Description


A script task is an automatic activity. When a process execution arrives at the script task, the corresponding script is executed.


[[bpmnScriptTaskGraphicalNotation]]


===== Graphical Notation

A script task is visualized as a typical BPMN 2.0 task (rounded rectangle), with a small 'script' icon in the top-left corner of the rectangle.

image::images/bpmn.scripttask.png[align="center"]


[[bpmnScriptTaskXml]]


===== XML representation


A script task is defined by specifying the *script* and the *scriptFormat*.

[source,xml,linenums]
----
<scriptTask id="theScriptTask" name="Execute script" scriptFormat="groovy">
  <script>
    sum = 0
    for ( i in inputArray ) {
      sum += i
    }
  </script>
</scriptTask>
----


The value of the *scriptFormat* attribute must be a name that is compatible with the link:$$http://jcp.org/en/jsr/detail?id=223$$[JSR-223] (scripting for the Java platform). By default JavaScript is included in every JDK and as such doesn't need any additional jars. If you want to use another (JSR-223 compatible) scripting engine, it is sufficient to add the corresponding jar to the classpath and use the appropriate name. For example, the Activiti unit tests often use Groovy because the syntax is pretty similar to that of Java.

Do note that the Groovy scripting engine is bundled with the groovy-all jar. Before version 2.0, the scripting engine was part of the regular Groovy jar. As such, one must now add following dependency:

[source,xml,linenums]
----
<dependency>
      <groupId>org.codehaus.groovy</groupId>
      <artifactId>groovy-all</artifactId>
      <version>2.x.x<version>
</dependency>
----


[[bpmnScriptTaskVariables]]


===== Variables in scripts


All process variables that are accessible through the execution that arrives in the script task, can be used within the script. In the example, the script variable _'inputArray'_ is in fact a process variable (an array of integers).

[source,xml,linenums]
----
<script>
    sum = 0
    for ( i in inputArray ) {
      sum += i
    }
</script>
----

It's also possible to set process variables in a script, simply by calling _execution.setVariable("variableName", variableValue)_. By default, no variables are stored automatically (*Note: before Activiti 5.12 this was the case!*). It is possible to automatically store any variable defined in the script (e.g. __sum__ in the example above) by setting the property ++autoStoreVariables++ on the ++scriptTask++ to ++true++. However, *the best practice is not to do this and use an explicit execution.setVariable() call*, as on some recent versions of the JDK auto storing of variables does not work for some scripting languages. See link:$$http://www.jorambarrez.be/blog/2013/03/25/bug-on-jdk-1-7-0_17-when-using-scripttask-in-activiti/$$[this link] for more details.

[source,xml,linenums]
----
<scriptTask id="script" scriptFormat="JavaScript" activiti:autoStoreVariables="false">
----

The default of this parameter is +false+, meaning that if the parameter is omitted from the script task definition, all the declared variables will only exist during the duration of the script.

Example on how to set a variable in a script:

[source,xml,linenums]
----
<script>
    def scriptVar = "test123"
    execution.setVariable("myVar", scriptVar)
</script>
----

Note: the following names are reserved and *cannot be used* as variable names: *out, out:print, lang:import, context, elcontext*.


[[bpmnScriptTaskResultValue]]


===== Script results


The return value of a script task can be assigned to an already existing or to a new process variable by specifying the process variable name as a literal value for the _'activiti:resultVariable'_ attribute of a script task definition. Any existing value for a specific process variable will be overwritten by the result value of the script execution. When not specifying a result variable name, the script result value gets ignored.

[source,xml,linenums]
----
<scriptTask id="theScriptTask" name="Execute script" scriptFormat="juel" activiti:resultVariable="myVar">
  <script>#{echo}</script>
</scriptTask>
----

In the above example, the result of the script execution (the value of the resolved expression __'#{echo}'__) is set to the process variable named __'myVar'__ after the script completes.

===== Security

It is also possible when using _javascript_ as scripting language to use '_secure scripting_'. See the <<advancedSecureScripting, secure scripting section>>.


[[bpmnJavaServiceTask]]


==== Java Service Task

[[bpmnJavaServiceTaskDescription]]


===== Description


A Java service task is used to invoke an external Java class.


[[bpmnJavaServiceTaskGraphicalNotation]]


===== Graphical Notation


A service task is visualized as a rounded rectangle with a small gear icon in the top-left corner.

image::images/bpmn.java.service.task.png[align="center"]



[[bpmnJavaServiceTaskXML]]


===== XML representation


There are 4 ways of declaring how to invoke Java logic:


* Specifying a class that implements JavaDelegate or ActivityBehavior
* Evaluating an expression that resolves to a delegation object
* Invoking a method expression
* Evaluating a value expression


To specify a class that is called during process execution, the fully qualified classname needs to be provided by the *'activiti:class'* attribute.

[source,xml,linenums]
----
<serviceTask id="javaService"
             name="My Java Service Task"
             activiti:class="org.activiti.MyJavaDelegate" />
----


See <<bpmnJavaServiceTaskImplementation,the implementation section>> for more details on how to use such a class.

It is also possible to use an expression that resolves to an object. This object must follow the same rules as objects that are created when the +activiti:class+ attribute is used (see <<bpmnJavaServiceTaskImplementation,further>>).

[source,xml,linenums]
----
<serviceTask id="serviceTask" activiti:delegateExpression="${delegateExpressionBean}" />
----

Here, the +delegateExpressionBean+ is a bean that implements the +JavaDelegate+ interface, defined in for example the Spring container.

To specify a UEL method expression that should be evaluated, use attribute *activiti:expression*.

[source,xml,linenums]
----
<serviceTask id="javaService"
             name="My Java Service Task"
             activiti:expression="#{printer.printMessage()}" />
----

Method ++printMessage++ (without parameters) will be called on the named object called ++printer++.

It's also possible to pass parameters with an method used in the expression.

[source,xml,linenums]
----
<serviceTask id="javaService"
             name="My Java Service Task"
             activiti:expression="#{printer.printMessage(execution, myVar)}" />
----

Method +printMessage+ will be called on the object named +printer+. The first parameter passed is the +DelegateExecution+, which is available in the expression context by default available as +execution+. The second parameter passed, is the value of the variable with name +myVar+ in the current execution.

To specify a UEL value expression that should be evaluated, use attribute *activiti:expression*.

[source,xml,linenums]
----
<serviceTask id="javaService"
             name="My Java Service Task"
             activiti:expression="#{split.ready}" />
----

The getter method of property ++ready++, ++getReady++ (without parameters), will be called on the named bean called ++split++. The named objects are resolved in the execution's process variables and (if applicable) in the Spring context.


[[bpmnJavaServiceTaskImplementation]]


===== Implementation

To implement a class that can be called during process execution, this class needs to implement the _org.activiti.engine.delegate.JavaDelegate_ interface and provide the required logic in the _execute_ method. When process execution arrives at this particular step, it will execute this logic defined in that method and leave the activity in the default BPMN 2.0 way.

Let's create for example a Java class that can be used to change a process variable String to uppercase. This class needs to implement the _org.activiti.engine.delegate.JavaDelegate_ interface, which requires us to implement the _execute(DelegateExecution)_ method. It's this operation that will be called by the engine and which needs to contain the business logic. Process instance information such as process variables  and other can be accessed and manipulated through the link:$$http://activiti.org/javadocs/org/activiti/engine/delegate/DelegateExecution.html$$[DelegateExecution] interface (click on the link for a detailed Javadoc of its operations).

[source,java,linenums]
----
public class ToUppercase implements JavaDelegate {

  public void execute(DelegateExecution execution) throws Exception {
    String var = (String) execution.getVariable("input");
    var = var.toUpperCase();
    execution.setVariable("input", var);
  }

}
----

Note: there will be *only one instance of that Java class created for the serviceTask it is defined on*. All process-instances share the same class instance that will be used to call _execute(DelegateExecution)_. This means that the class must not use any member variables and must be thread-safe, since it can be executed simultaneously from different threads. This also influences the way <<serviceTaskFieldInjection,Field injection>> is handled.

The classes that are referenced in the process definition (i.e. by using ++activiti:class++) are *NOT instantiated during deployment*. Only when a process execution arrives for the first time at the point in the process where the class is used, an instance of that class will be created. If the class cannot be found, an +ActivitiException+ will be thrown. The reasoning for this is that the environment (and more specifically the __classpath__) when you are deploying is often different from the actual runtime environment. For example when using _ant_ or the business archive upload in Activiti Explorer to deploy processes, the classpath does not contain the referenced classes.

<<internal,[INTERNAL: non-public implementation classes]>> It is also possible to provide a class that implements the _org.activiti.engine.impl.pvm.delegate.ActivityBehavior_ interface. Implementations have then access to the more powerful _ActivityExecution_ that for example also allows to influence the control flow of the process. Note however that this is not a very good practice, and should be avoided as much as possible. So, it is advised to use the _ActivityBehavior_ interface only for advanced use cases and if you know exactly what you're doing.


[[serviceTaskFieldInjection]]


===== Field Injection

It's possible to inject values into the fields of the delegated classes. The following types of injection are supported:

* Fixed string values
* Expressions

If available, the value is injected through a public setter method on your delegated class, following the Java Bean naming conventions (e.g. field +firstName+ has setter ++setFirstName(...)++). If no setter is available for that field, the value of private member will be set on the delegate. SecurityManagers in some environments don't allow modifying private fields, so it's safer to expose a public setter-method for the fields you want to have injected.

*Regardless of the type of value declared in the process-definition, the type of the setter/private field on the injection target should always be +org.activiti.engine.delegate.Expression+. When the expression is resolved it can be cast to the appropriate type.*

Field injection is supported when using the _'actviiti:class'_ attribute. Field injection is also possible when using the _activiti:delegateExpression_ attribute, however special rules with regards to thread-safety apply (see next section).

The following code snippet shows how to inject a constant value into a field declared on the class. Note that we need to *declare a 'extensionElements' XML element before the actual field injection declarations*, which is a requirement of the BPMN 2.0 XML Schema.

[source,xml,linenums]
----
<serviceTask id="javaService"
    name="Java service invocation"
    activiti:class="org.activiti.examples.bpmn.servicetask.ToUpperCaseFieldInjected">
    <extensionElements>
      <activiti:field name="text" stringValue="Hello World" />
  </extensionElements>
</serviceTask>
----

The class +ToUpperCaseFieldInjected+ has a field +text+ which is of type +org.activiti.engine.delegate.Expression+. When calling +text.getValue(execution)+, the configured string value +Hello World+ will be returned:

[source,java,linenums]
----
public class ToUpperCaseFieldInjected implements JavaDelegate {

  private Expression text;

  public void execute(DelegateExecution execution) {
    execution.setVariable("var", ((String)text.getValue(execution)).toUpperCase());
  }

}
----

Alternatively, for longs texts (e.g. an inline e-mail) the _'activiti:string'_ sub element can be used:

[source,xml,linenums]
----
<serviceTask id="javaService"
    name="Java service invocation"
    activiti:class="org.activiti.examples.bpmn.servicetask.ToUpperCaseFieldInjected">
  <extensionElements>
    <activiti:field name="text">
        <activiti:string>
          This is a long string with a lot of words and potentially way longer even!
      </activiti:string>
    </activiti:field>
  </extensionElements>
</serviceTask>
----

To inject values that are dynamically resolved at runtime, expressions can be used. Those expressions can use process variables, or Spring defined beans (if Spring is used). As noted in <<bpmnJavaServiceTaskImplementation,Service Task Implementation>>, an instance of the Java class is shared among all process-instances in a service task when using the _activiti:class_ attribute. To have dynamic injection of values in fields, you can inject value and method expressions in a +org.activiti.engine.delegate.Expression+ which can be evaluated/invoked using the +DelegateExecution+ passed in the +execute+ method.

The example class below uses the injected expressions and resolves them using the current +DelegateExecution+. A _generBean_ method call is used while passing the _gender_ variable. Full code and test can be found in +org.activiti.examples.bpmn.servicetask.JavaServiceTaskTest.testExpressionFieldInjection+

[source,xml,linenums]
----
<serviceTask id="javaService" name="Java service invocation"
  activiti:class="org.activiti.examples.bpmn.servicetask.ReverseStringsFieldInjected">

  <extensionElements>
    <activiti:field name="text1">
      <activiti:expression>${genderBean.getGenderString(gender)}</activiti:expression>
    </activiti:field>
    <activiti:field name="text2">
       <activiti:expression>Hello ${gender == 'male' ? 'Mr.' : 'Mrs.'} ${name}</activiti:expression>
    </activiti:field>
  </ extensionElements>
</ serviceTask>
----

[source,java,linenums]
----
public class ReverseStringsFieldInjected implements JavaDelegate {

  private Expression text1;
  private Expression text2;

  public void execute(DelegateExecution execution) {
    String value1 = (String) text1.getValue(execution);
    execution.setVariable("var1", new StringBuffer(value1).reverse().toString());

    String value2 = (String) text2.getValue(execution);
    execution.setVariable("var2", new StringBuffer(value2).reverse().toString());
  }
}
----


Alternatively, you can also set the expressions as an attribute instead of a child-element, to make the XML less verbose.

[source,xml,linenums]
----
<activiti:field name="text1" expression="${genderBean.getGenderString(gender)}" />
<activiti:field name="text1" expression="Hello ${gender == 'male' ? 'Mr.' : 'Mrs.'} ${name}" />
----

[[serviceTaskFieldInjectionThreadSafety]]

===== Field injection and thread safety

In general, using service tasks with Java delegates and field injections are thread-safe. However, there are a few situations where thread-safety is not guaranteed, depending on the setup or environment Activiti is running in.

When using the _activiti:class_ attribute, using field injection is always thread safe. For each service task that references a certain class, a new instance will be instantiated and fields will be injected once when the instance is created. Reusing the same class in multiple times in different tasks or process definitions is no problem.

When using the _activiti:expression_ attribute, using field injection is not possible. Parameters are passed via method calls and these are always thread-safe.

When using the _activiti:delegateExpression_ attribute, the thread-safety of the delegate instance will depend on how the expression is resolved. If the delegate expression is reused in various tasks and/or process definitions and the expression always returns the same instance, using field injection *is not thread-safe*. Let's look at a few examples to clarify.

Suppose the expression is _${factory.createDelegate(someVariable)}_, where factory is a Java bean known to the engine (for example a Spring bean when using the Spring integration) that creates a new instance each time the expression is resolved. When using field injection in this case, there is no problem with regards to thread-safety: each time the expression is resolved, the fields are injected on this new instance.

However, suppose the expression is _${someJavaDelegateBean}_ that resolves to an implementation of the JavaDelegate class and we're running in an environment that creates singleton instances of each bean (like Spring, but many others too). When using this expression in different tasks and/or process definitions, the expression will always be resolved to the same instance. In this case, using field injection is not thread-safe. For example:

[source,xml,linenums]
----
<serviceTask id="serviceTask1" activiti:delegateExpression="${someJavaDelegateBean}">
    <extensionElements>
        <activiti:field name="someField" expression="${input * 2}"/>
    </extensionElements>
</serviceTask>

<!-- other process definition elements -->

<serviceTask id="serviceTask2" activiti:delegateExpression="${someJavaDelegateBean}">
    <extensionElements>
        <activiti:field name="someField" expression="${input * 2000}"/>
    </extensionElements>
</serviceTask>
----

This example snippet has two service tasks that use the same delegate expression, but injects different values for the _Expression_ field. *If the expression resolves to the same instance, there can be race conditions in concurrent scenarios* when it comes to injecting the field _someField_ when the processes are executed.

The easiest solution to solve this, is to either

* rewrite the Java delegate to use an expression and passing the needed data to the delegate via a method arguments.
* return a new instance of the delegate class each time the delegate expression is resolved. For example when using Spring, this means that the scope of the bean must be set to *prototype* (for example by adding the @Scope(SCOPE_PROTOTYPE) annotation to the delegate class)

As of Activiti version 5.21, the process engine configuration can be configured in a way to disable the use of field injection on delegate epxressions, by setting the value of the _delegateExpressionFieldInjectionMode_ property (which takes one of the values in the _org.activiti.engine.imp.cfg.DelegateExpressionFieldInjectionMode_ enum).

Following settings are possible:

* *DISABLED* : fully disables field injection when using delegate expressions. No field injection will be attempted. This is the safest mode, when it comes to thread-safety.
* *COMPATIBILITY*: in this mode, the behavior will be exactly as it was before version 5.21: field injection is possible when using delegate expressions and an exception will be thrown when the fields are not defined on the delegate class. This is of course the least safe mode with regards to thread-safety, but it can be needed for backwards compatibility or can be used safely when the delegate expression is used only on one task in a set of process definitions (and thus no concurrent race conditions can happen).
* *MIXED*: Allows injection when using delegateExpressions but will not throw an exception when the fields are not defined on the delegate. This allows for mixed behaviors where some delegates have injection (for example because they are not singletons) and some don't.

* *The default mode for Activiti version 5.x is COMPATIBILITY.*
* *The default mode for Activiti version 6.x is MIXED.*

For example, suppose that we're using _MIXED_ mode and we're using the Spring integration. Suppose that we have following beans in the Spring configuration:

[source,xml,linenums]
----
<bean id="singletonDelegateExpressionBean"
  class="org.activiti.spring.test.fieldinjection.SingletonDelegateExpressionBean" />

<bean id="prototypeDelegateExpressionBean"
  class="org.activiti.spring.test.fieldinjection.PrototypeDelegateExpressionBean"
  scope="prototype" />
----

The first bean is a regular Spring bean and thus a singleton. The second one has _prototype_ as scope, and the Spring container will return a new instance every time the bean is requested.

Given following process definition:

[source,xml,linenums]
----
<serviceTask id="serviceTask1" activiti:delegateExpression="${prototypeDelegateExpressionBean}">
  <extensionElements>
    <activiti:field name="fieldA" expression="${input * 2}"/>
    <activiti:field name="fieldB" expression="${1 + 1}"/>
    <activiti:field name="resultVariableName" stringValue="resultServiceTask1"/>
  </extensionElements>
</serviceTask>

<serviceTask id="serviceTask2" activiti:delegateExpression="${prototypeDelegateExpressionBean}">
  <extensionElements>
    <activiti:field name="fieldA" expression="${123}"/>
    <activiti:field name="fieldB" expression="${456}"/>
    <activiti:field name="resultVariableName" stringValue="resultServiceTask2"/>
  </extensionElements>
</serviceTask>

<serviceTask id="serviceTask3" activiti:delegateExpression="${singletonDelegateExpressionBean}">
  <extensionElements>
    <activiti:field name="fieldA" expression="${input * 2}"/>
    <activiti:field name="fieldB" expression="${1 + 1}"/>
    <activiti:field name="resultVariableName" stringValue="resultServiceTask1"/>
  </extensionElements>
</serviceTask>

<serviceTask id="serviceTask4" activiti:delegateExpression="${singletonDelegateExpressionBean}">
  <extensionElements>
    <activiti:field name="fieldA" expression="${123}"/>
    <activiti:field name="fieldB" expression="${456}"/>
    <activiti:field name="resultVariableName" stringValue="resultServiceTask2"/>
  </extensionElements>
</serviceTask>
----

We've got four service tasks, where the first and the second use the _${prototypeDelegateExpressionBean}_ delegate expression and the third and fourth use the _${singletonDelegateExpressionBean}_ delegate expression.

Let's look at the prototype bean first:

[source,java,linenums]
----
public class PrototypeDelegateExpressionBean implements JavaDelegate {

  public static AtomicInteger INSTANCE_COUNT = new AtomicInteger(0);

  private Expression fieldA;
  private Expression fieldB;
  private Expression resultVariableName;

  public PrototypeDelegateExpressionBean() {
    INSTANCE_COUNT.incrementAndGet();
  }

  @Override
  public void execute(DelegateExecution execution) throws Exception {

    Number fieldAValue = (Number) fieldA.getValue(execution);
    Number fieldValueB = (Number) fieldB.getValue(execution);

    int result = fieldAValue.intValue() + fieldValueB.intValue();
    execution.setVariable(resultVariableName.getValue(execution).toString(), result);
  }

}
----

When we check the _INSTANCE_COUNT_ after running a process instance of the process definition above, we'll get _two_ back, as a new instance is created every time _${prototypeDelegateExpressionBean}_ is resolved. Fields can be injected without any problem here and we can see the three _Expression_ member fields here.

The singleton bean, however, looks slightly different:

[source,java,linenums]
----
public class SingletonDelegateExpressionBean implements JavaDelegate {

  public static AtomicInteger INSTANCE_COUNT = new AtomicInteger(0);

  public SingletonDelegateExpressionBean() {
    INSTANCE_COUNT.incrementAndGet();
  }

  @Override
  public void execute(DelegateExecution execution) throws Exception {

    Expression fieldAExpression = DelegateHelper.getFieldExpression(execution, "fieldA");
    Number fieldA = (Number) fieldAExpression.getValue(execution);

    Expression fieldBExpression = DelegateHelper.getFieldExpression(execution, "fieldB");
    Number fieldB = (Number) fieldBExpression.getValue(execution);

    int result = fieldA.intValue() + fieldB.intValue();

    String resultVariableName = DelegateHelper.getFieldExpression(execution, "resultVariableName").getValue(execution).toString();
    execution.setVariable(resultVariableName, result);
  }

}
----

The _INSTANCE_COUNT_ will always be _one_ here, as it is a singleton. In this delegate, there are no _Expression_ member fields. This is possible since we're running in _MIXED_ mode. In _COMPATIBILITY_ mode, this would throw an exception as it expects the member fields to be there. _DISABLED_ mode would also work for this bean, but it would disallow the use the prototype bean above that does use field injection.

In this delegate code, the *org.activiti.engine.delegate.DelegateHelper* class is used, that has some useful utility methods to execute the same logic, but in a thread-safe way when the delegate is a singleton. Instead of injecting the _Expression_, it is fetched via the _getFieldExpression_ method. This means that when it comes to the service task xml, the fields are defined exactly the same as for the singleton bean. If you look at the xml snippet above, you can see they are equal in definition and only the implementation logic differs.

(Technical note: the _getFieldExpression_ will introspect the BpmnModel and create the Expression on the fly when the method is executed, making it thread-safe)


* For Activiti versions 5.x, the DelegateHelper cannot be used for an _ExecutionListener_ or _TaskListener_ (due to an architectural flaw). To make thread-safe instances of those listeners, use either an expression or make sure a new instance is created every time the delegate expression is resolved.
* For Activiti version 6.x the DelegateHelper does work in _ExecutionListener_ and _TaskListener_ implementations. For example in version 6.x, the following code can be written, using the *DelegateHelper*:

[source,xml,linenums]
----
<extensionElements>
  <activiti:executionListener
      delegateExpression="${testExecutionListener}" event="start">
    <activiti:field name="input" expression="${startValue}" />
    <activiti:field name="resultVar" stringValue="processStartValue" />
  </activiti:executionListener>
</extensionElements>
----

Where _testExecutionListener_ resolves to an instance implementing the ExecutionListener interface:

[source,java,linenums]
----
@Component("testExecutionListener")
public class TestExecutionListener implements ExecutionListener {

  @Override
  public void notify(DelegateExecution execution) {
    Expression inputExpression = DelegateHelper.getFieldExpression(execution, "input");
    Number input = (Number) inputExpression.getValue(execution);

    int result = input.intValue() * 100;

    Expression resultVarExpression = DelegateHelper.getFieldExpression(execution, "resultVar");
    execution.setVariable(resultVarExpression.getValue(execution).toString(), result);
  }

}
----



[[serviceTaskResultValue]]


===== Service task results


The return value of a service execution (for service task using expression only) can be assigned to an already existing or to a new process variable by specifying the process variable name as a literal value for the _'activiti:resultVariable'_ attribute of a service task definition. Any existing value for a specific process variable will be overwritten by the result value of the service execution. When not specifying a result variable name, the service execution result value gets ignored.

[source,xml,linenums]
----
<serviceTask id="aMethodExpressionServiceTask"
    activiti:expression="#{myService.doSomething()}"
    activiti:resultVariable="myVar" />
----

In the example above, the result of the service execution (the return value of the __'doSomething()'__ method invocation on an object that is made available under the name __'myService'__ either in the process variables or as a Spring bean) is set to the process variable named __'myVar'__ after the service execution completes.


[[serviceTaskExceptionHandling]]


===== Handling exceptions


When custom logic is executed, it is often required to catch certain business exceptions and handle them inside the surrounding process. Activiti provides different options to do that.


[[serviceTaskBpmnErrors]]


====== Throwing BPMN Errors


It is possible to throw BPMN Errors from user code inside Service Tasks or Script Tasks. In order to do this, a special ActivitiException called _BpmnError_ can be thrown in JavaDelegates, scripts, expressions and delegate expressions. The engine will catch this exception and forward it to an appropriate error handler, e.g., a Boundary Error Event or an Error Event Sub-Process.

[source,java,linenums]
----
public class ThrowBpmnErrorDelegate implements JavaDelegate {

  public void execute(DelegateExecution execution) throws Exception {
    try {
      executeBusinessLogic();
    } catch (BusinessException e) {
      throw new BpmnError("BusinessExceptionOccurred");
    }
  }

}
----

The constructor argument is an error code, which will be used to determine the error handler that is responsible for the error. See <<bpmnBoundaryErrorEvent,Boundary Error Event>> for information on how to catch a BPMN Error.

This mechanism should be used *only for business faults* that shall be handled by a Boundary Error Event or Error Event Sub-Process modeled in the process definition. Technical errors should be represented by other exception types and are usually not handled inside a process.

[[exceptionMapping]]

====== Exception mapping

It is also possible to directly map a java exception to business exception by using +mapException+ extension. Single mapping is the simplest form:
[source,xml,linenums]
----
<serviceTask id="servicetask1" name="Service Task" activiti:class="...">
  <extensionElements>
    <activiti:mapException
          errorCode="myErrorCode1">org.activiti.SomeException</activiti:mapException>
  </extensionElements>
</serviceTask>

----
In above code, if an instance of +org.activiti.SomeException+ is thrown in service task, it would be caught and converted to a BPMN exception with the given errorCode. From this point on, it will be handled exactly like a normal BPMN exception.
Any other exception will be treated as if there is no mapping in place. It will be propagated to the API caller.

One can map all the child exception of a certain exception in a single line by using +includeChildExceptions+ attribute.

[source,xml,linenums]
----
<serviceTask id="servicetask1" name="Service Task" activiti:class="...">
  <extensionElements>
    <activiti:mapException errorCode="myErrorCode1"
           includeChildExceptions="true">org.activiti.SomeException</activiti:mapException>
  </extensionElements>
</serviceTask>

----
The above code will cause activiti to convert any direct or indirect descendent of +SomeException+ to a BPMN error with the given error code.
+includeChildExceptions+ will be considered "false" when not given.


The most generic mapping is a default map. Default map is a map with no class. It will match any java exception:

[source,xml,linenums]
----
<serviceTask id="servicetask1" name="Service Task" activiti:class="...">
  <extensionElements>
    <activiti:mapException errorCode="myErrorCode1"/>
  </extensionElements>
</serviceTask>
----

The mappings are checked in order, from top to bottom and the first found match will be followed, except for the default map. Default map is selected only after all maps are unsuccessfully checked.
Only the first map with no class will be considered as default map. +includeChildExceptions+ is ignored for default Map.


[[serviceTaskExceptionSequenceFlow]]


====== Exception Sequence Flow


<<internal, [INTERNAL: non-public implementation classes]>>

Another option is to route process execution through another path in case some exception occurs. The following example shows how this is done.

[source,xml,linenums]
----
<serviceTask id="javaService"
  name="Java service invocation"
  activiti:class="org.activiti.ThrowsExceptionBehavior">
</serviceTask>

<sequenceFlow id="no-exception" sourceRef="javaService" targetRef="theEnd" />
<sequenceFlow id="exception" sourceRef="javaService" targetRef="fixException" />
----

Here, the service task has two outgoing sequence flow, called +exception+ and +no-exception+. This sequence flow id will be used to direct process flow in case of an exception:

[source,java,linenums]
----
public class ThrowsExceptionBehavior implements ActivityBehavior {

  public void execute(ActivityExecution execution) throws Exception {
    String var = (String) execution.getVariable("var");

    PvmTransition transition = null;
    try {
      executeLogic(var);
      transition = execution.getActivity().findOutgoingTransition("no-exception");
    } catch (Exception e) {
      transition = execution.getActivity().findOutgoingTransition("exception");
    }
    execution.take(transition);
  }

}
----


[[serviceTaskCallActivitiService]]


===== Using an Activiti service from within a JavaDelegate


For some use cases, it might be needed to use the Activiti services from within a Java service task (e.g. starting a process instance through the RuntimeService, if the callActivity doesn't suit your needs). The _org.activiti.engine.delegate.DelegateExecution_ allows to easily use these services through the _org.activiti.engine.EngineServices_ interface:

[source,java,linenums]
----
public class StartProcessInstanceTestDelegate implements JavaDelegate {

  public void execute(DelegateExecution execution) throws Exception {
    RuntimeService runtimeService = execution.getEngineServices().getRuntimeService();
    runtimeService.startProcessInstanceByKey("myProcess");
  }

}
----

All of the Activiti service API's are available through this interface.

All data changes that occur as an effect of using these API calls, will be part of the current transaction. This also works in environments with dependency injection like Spring and CDI with or without a JTA enabled datasource. For example, the following snippet of code will do the same as the snippet above, but now the RuntimeService is injected rather than it is being fetched through the _org.activiti.engine.EngineServices_ interface.

[source,java,linenums]
----
@Component("startProcessInstanceDelegate")
public class StartProcessInstanceTestDelegateWithInjection {

    @Autowired
    private RuntimeService runtimeService;

    public void startProcess() {
      runtimeService.startProcessInstanceByKey("oneTaskProcess");
    }

}
----

*Important technical note:* since the service call is being done as part of the current transaction any data that was produced or altered _before_ the service task is executed, is not yet flushed to the database. All API calls work on the database data, which means that these uncommitted changes are not be 'visible' within the api call of the service task.


[[bpmnWebserviceTask]]


==== Web Service Task

<<experimental,[EXPERIMENTAL]>>[[bpmnWebserviceTaskDescription]]


===== Description

A Web Service task is used to synchronously invoke an external Web service.


[[bpmnWebserviceTaskGraphicalNotation]]


===== Graphical Notation

A Web Service task is visualized the same as a Java service task.

image::images/bpmn.web.service.task.png[align="center"]


[[bpmnWebserviceTaskXML]]


===== XML representation

To use a Web service we need to import its operations and complex types. This can be done automatically by using the import tag pointing to the WSDL of the Web service:

[source,xml,linenums]
----
<import importType="http://schemas.xmlsoap.org/wsdl/"
	location="http://localhost:63081/counter?wsdl"
	namespace="http://webservice.activiti.org/" />
----

The previous declaration tells Activiti to import the definitions but it doesn't create the item definitions and messages for you. Let's suppose we want to invoke a specific method called 'prettyPrint', therefore we will need to create the corresponding message and item definitions for the request and response messages:

[source,xml,linenums]
----
<message id="prettyPrintCountRequestMessage" itemRef="tns:prettyPrintCountRequestItem" />
<message id="prettyPrintCountResponseMessage" itemRef="tns:prettyPrintCountResponseItem" />

<itemDefinition id="prettyPrintCountRequestItem" structureRef="counter:prettyPrintCount" />
<itemDefinition id="prettyPrintCountResponseItem" structureRef="counter:prettyPrintCountResponse" />
----

Before declaring the service task, we have to define the BPMN interfaces and operations that actually reference the Web service ones. Basically, we define and 'interface' and the required 'operation's'. For each operation we reuse the previous defined message for in and out. For example, the following declaration defines the 'counter' interface and the 'prettyPrintCountOperation' operation:

[source,xml,linenums]
----
<interface name="Counter Interface" implementationRef="counter:Counter">
	<operation id="prettyPrintCountOperation" name="prettyPrintCount Operation"
			implementationRef="counter:prettyPrintCount">
		<inMessageRef>tns:prettyPrintCountRequestMessage</inMessageRef>
		<outMessageRef>tns:prettyPrintCountResponseMessage</outMessageRef>
	</operation>
</interface>
----

Then we can declare a Web Service Task by using the ##WebService implementation and a reference to the Web service operation.

[source,xml,linenums]
----
<serviceTask id="webService"
	name="Web service invocation"
	implementation="##WebService"
	operationRef="tns:prettyPrintCountOperation">
----

[[bpmnWebserviceTaskIOSpecification]]


===== Web Service Task IO Specification


Unless we are using the simplistic approach for data input and output associations (See below), each Web Service Task needs to declare an IO Specification which states which are the inputs and outputs of the task. The approach is pretty straightforward and BPMN 2.0 complaint, for our prettyPrint example we define the input and output sets according to the previously declared item definitions:

[source,xml,linenums]
----
<ioSpecification>
	<dataInput itemSubjectRef="tns:prettyPrintCountRequestItem" id="dataInputOfServiceTask" />
	<dataOutput itemSubjectRef="tns:prettyPrintCountResponseItem" id="dataOutputOfServiceTask" />
	<inputSet>
		<dataInputRefs>dataInputOfServiceTask</dataInputRefs>
	</inputSet>
	<outputSet>
		<dataOutputRefs>dataOutputOfServiceTask</dataOutputRefs>
	</outputSet>
</ioSpecification>
----

[[bpmnWebserviceTaskDataInputAssociation]]


===== Web Service Task data input associations

There are 2 ways of specifying data input associations:


* Using expressions
* Using the simplistic approach

To specify the data input association using expressions we need to define the source and target items and specify the corresponding assignments between the fields of each item. In the following example we assign prefix and suffix fields of the items:

[source,xml,linenums]
----
<dataInputAssociation>
	<sourceRef>dataInputOfProcess</sourceRef>
	<targetRef>dataInputOfServiceTask</targetRef>
	<assignment>
		<from>${dataInputOfProcess.prefix}</from>
		<to>${dataInputOfServiceTask.prefix}</to>
	</assignment>
	<assignment>
		<from>${dataInputOfProcess.suffix}</from>
		<to>${dataInputOfServiceTask.suffix}</to>
	</assignment>
</dataInputAssociation>
----

On the other hand we can use the simplistic approach which is much more simple. The 'sourceRef' element is an Activiti variable name and the 'targetRef' element is a property of the item definition. In the following example we assign to the 'prefix' field the value of the variable 'PrefixVariable' and to the 'suffix' field the value of the variable 'SuffixVariable'.

[source,xml,linenums]
----
<dataInputAssociation>
	<sourceRef>PrefixVariable</sourceRef>
	<targetRef>prefix</targetRef>
</dataInputAssociation>
<dataInputAssociation>
	<sourceRef>SuffixVariable</sourceRef>
	<targetRef>suffix</targetRef>
</dataInputAssociation>
----

[[bpmnWebserviceTaskDataOutputAssociation]]


===== Web Service Task data output associations

There are 2 ways of specifying data out associations:

* Using expressions
* Using the simplistic approach


To specify the data out association using expressions we need to define the target variable and the source expression. The approach is pretty straightforward and similar data input associations:

[source,xml,linenums]
----
<dataOutputAssociation>
	<targetRef>dataOutputOfProcess</targetRef>
	<transformation>${dataOutputOfServiceTask.prettyPrint}</transformation>
</dataOutputAssociation>
----

On the other hand we can use the simplistic approach which is much more simple. The 'sourceRef' element is a property of the item definition and the 'targetRef' element is an Activiti variable name. The approach is pretty straightforward and similar data input associations:

[source,xml,linenums]
----
<dataOutputAssociation>
	<sourceRef>prettyPrint</sourceRef>
	<targetRef>OutputVariable</targetRef>
</dataOutputAssociation>
----

[[bpmnBusinessRuleTask]]


==== Business Rule Task

<<experimental,[EXPERIMENTAL]>>[[bpmnBusinessRuleTaskDescription]]


===== Description

A Business Rule task is used to synchronously execute one or more rules. Activiti uses Drools Expert, the Drools rule engine to execute business rules. Currently, the .drl files containing the business rules have to be deployed together with the process definition that defines a business rule task to execute those rules. This means that all .drl files that are used in a process have to be packaged in the process BAR file like for example the task forms. For more information about creating business rules for Drools Expert please refer to the Drools documentation at link:$$http://www.jboss.org/drools/documentation$$[JBoss Drools]

If you want to plug in your implementation of the rule task, e.g. because you want to use Drools differently or you want to use a completely different rule engine, then you can use the class or expression attribute on the BusinessRuleTask and it will behave exactly like a link:$$#bpmnJavaServiceTask$$[ServiceTask]


[[bpmnBusinessRuleTaskGraphicalNotation]]


===== Graphical Notation

A Business Rule task is visualized the with a table icon.

image::images/bpmn.business.rule.task.png[align="center"]


[[bpmnBusinessRuleTaskXML]]


===== XML representation

To execute one or more business rules that are deployed in the same BAR file as the process definition, we need to define the input and result variables. For the input variable definition a list of process variables can be defined separated by a comma. The output variable definition can only contain one variable name that will be used to store the output objects of the executed business rules in a process variable. Note that the result variable will contain a List of objects. If no result variable name is specified by default org.activiti.engine.rules.OUTPUT is used.

The following business rule task executes all business rules deployed with the process definition:

[source,xml,linenums]
----
<process id="simpleBusinessRuleProcess">

  <startEvent id="theStart" />
  <sequenceFlow sourceRef="theStart" targetRef="businessRuleTask" />

  <businessRuleTask id="businessRuleTask" activiti:ruleVariablesInput="${order}"
      activiti:resultVariable="rulesOutput" />

  <sequenceFlow sourceRef="businessRuleTask" targetRef="theEnd" />

  <endEvent id="theEnd" />

</process>
----

The business rule task can also be configured to execute only a defined set of rules from the deployed .drl files. A list of rule names separated by a comma must be specified for this.

[source,xml,linenums]
----
<businessRuleTask id="businessRuleTask" activiti:ruleVariablesInput="${order}"
      activiti:rules="rule1, rule2" />
----

In this case only rule1 and rule2 are executed.

You can also define a list of rules that should be excluded from execution.

[source,xml,linenums]
----
<businessRuleTask id="businessRuleTask" activiti:ruleVariablesInput="${order}"
      activiti:rules="rule1, rule2" exclude="true" />
----

In this case all rules deployed in the same BAR file as the process definition will be executed, except for rule1 and rule2.

As mentioned earlier another option is to hook in the implementation of the BusinessRuleTask yourself:

[source,xml,linenums]
----
<businessRuleTask id="businessRuleTask" activiti:class="${MyRuleServiceDelegate}" />
----

Now the BusinessRuleTask behaves exactly like a ServiceTask, but still keeps the BusinessRuleTask icon to visualize that we do business rule processing here.


[[bpmnEmailTask]]


==== Email Task

Activiti allows to enhance business processes with automatic mail service tasks that send e-mails to one or more recipients, including support for cc, bcc, HTML content, ... etc. Note that the mail task is *not* an 'official' task of the BPMN 2.0 spec (and it does not have a dedicated icon as a consequence). Hence, in Activiti the mail task is implemented as a dedicated service task.


[[bpmnEmailTaskServerConfiguration]]


===== Mail server configuration

The Activiti engine sends e-mails trough an external mail server with SMTP capabilities. To actually send e-mails, the engine needs to know how to reach the mail server. Following properties can be set in the _activiti.cfg.xml_ configuration file:

[options="header"]
|===============
|Property|Required?|Description
|mailServerHost|no|The hostname of your mail server (e.g. mail.mycorp.com). Default is +localhost+
|mailServerPort|yes, if not on the default port|The port for SMTP traffic on the mail server. The default is _25_
|mailServerDefaultFrom|no|The default e-mail address of the sender of e-mails, when none is provided by the user. By default this is _activiti@activiti.org_
|mailServerUsername|if applicable for your server|Some mail servers require credentials for sending e-mail. By default not set.
|mailServerPassword|if applicable for your server|Some mail servers require credentials for sending e-mail. By default not set.
|mailServerUseSSL|if applicable for your server|Some mail servers require ssl communication. By default set to false.
|mailServerUseTLS|if applicable for your server|Some mail servers (for instance gmail) require TLS communication. By default set to false.

|===============


[[bpmnEmailTaskUsage]]


===== Defining an Email Task

The Email task is implemented as a dedicated <<bpmnJavaServiceTask,Service Task>> and is defined by setting _'mail'_ for the _type_ of the service task.

[source,xml,linenums]
----
<serviceTask id="sendMail" activiti:type="mail">
----

The Email task is configured by <<serviceTaskFieldInjection,field injection>>. All the values for these properties can contain EL expression, which are resolved at runtime during process execution. Following properties can be set:

[options="header"]
|===============
|Property|Required?|Description
|to|yes|The recipients if the e-mail. Multiple recipients are defined in a comma-separated list
|from|no|The sender e-mail address. If not provided, the <<bpmnEmailTaskServerConfiguration,default configured>> from address is used.
|subject|no|The subject of the e-mail.
|cc|no|The cc's of the e-mail. Multiple recipients are defined in a comma-separated list
|bcc|no|The bcc's of the e-mail. Multiple recipients are defined in a comma-separated list
|charset|no|Allows to change the charset of the email, which is necessary for many
                 non-English languages.

|html|no|A piece of HTML that is the content of the e-mail.
|text|no|The content of the e-mail, in case one needs to send plain none-rich e-mails.
                   Can be used in combination with _html_, for e-mail clients
                   that don't support rich content. The client will then fall back to this text-only alternative.

|htmlVar|no|The name of a process variable that holds the HTML that is the content of the e-mail. The key difference between this and html is that this content will have expressions replaced before being sent by the mail task.
|textVar|no|The name of a process variable that holds the plain text content of the e-mail. The key difference between this and html is that this content will have expressions replaced before being sent by the mail task.
|ignoreException|no|Whether an failure when handling the e-mail throws an ActivitiException. By default this is set to false.
|exceptionVariableName|no|When email handling does not throw an exception since _ignoreException = true_ a variable with the given name is used to hold a failure message

|===============



[[bpmnEmailTaskExampleUsage]]


===== Example usage

The following XML snippet shows an example of using the Email Task.

[source,xml,linenums]
----
<serviceTask id="sendMail" activiti:type="mail">
  <extensionElements>
    <activiti:field name="from" stringValue="order-shipping@thecompany.com" />
    <activiti:field name="to" expression="${recipient}" />
    <activiti:field name="subject" expression="Your order ${orderId} has been shipped" />
    <activiti:field name="html">
      <activiti:expression>
        <![CDATA[
          <html>
            <body>
              Hello ${male ? 'Mr.' : 'Mrs.' } ${recipientName},<br/><br/>

              As of ${now}, your order has been <b>processed and shipped</b>.<br/><br/>

              Kind regards,<br/>

              TheCompany.
            </body>
          </html>
        ]]>
      </activiti:expression>
    </activiti:field>
  </extensionElements>
</serviceTask>

----

with the following result:

image::images/email.task.result.png[align="center"]


[[bpmnMuleTask]]


==== Mule Task


The mule task allows to send messages to Mule enhancing the integration features of Activiti. Note that the mule task is *not* an 'official' task of the BPMN 2.0 spec (and it does not have a dedicated icon as a consequence). Hence, in Activiti the mule task is implemented as a dedicated service task.

[[bpmnMuleTaskUsage]]


===== Defining an Mule Task


The Mule task is implemented as a dedicated <<bpmnJavaServiceTask,Service Task>> and is defined by setting _'mule'_ for the _type_ of the service task.

[source,xml,linenums]
----
<serviceTask id="sendMule" activiti:type="mule">
----

The Mule task is configured by <<serviceTaskFieldInjection,field injection>>. All the values for these properties can contain EL expression, which are resolved at runtime during process execution. Following properties can be set:

[options="header"]
|===============
|Property|Required?|Description
|endpointUrl|yes|The Mule endpoint you want to invoke.
|language|yes|The language you want to use to evaluate the payloadExpression field.
|payloadExpression|yes|An expression that will be the message's payload.
|resultVariable|no|The name of the variable which will store the result of the invocation.

|===============

[[bpmnMuleTaskExampleUsage]]


===== Example usage

The following XML snippet shows an example of using the Mule Task.

[source,xml,linenums]
----
<extensionElements>
  <activiti:field name="endpointUrl">
    <activiti:string>vm://in</activiti:string>
  </activiti:field>
  <activiti:field name="language">
    <activiti:string>juel</activiti:string>
  </activiti:field>
  <activiti:field name="payloadExpression">
    <activiti:string>"hi"</activiti:string>
  </activiti:field>
  <activiti:field name="resultVariable">
    <activiti:string>theVariable</activiti:string>
  </activiti:field>
</extensionElements>
----

[[bpmnCamelTask]]


==== Camel Task

The Camel task allows to send messages to and receive messages from Camel and thereby enhances the integration features of Activiti. Note that the Camel task is *not* an 'official' task of the BPMN 2.0 spec (and it does not have a dedicated icon as a consequence). Hence, in Activiti the Camel task is implemented as a dedicated service task. Also note to include the Activiti Camel module in your project to use the Camel task functionality.


[[bpmnCamelTaskUsage]]


===== Defining a Camel Task

The Camel task is implemented as a dedicated <<bpmnJavaServiceTask,Service Task>> and is defined by setting _'camel'_ for the _type_ of the service task.

[source,xml,linenums]
----
<serviceTask id="sendCamel" activiti:type="camel">
----

The process definition itself needs nothing else then the camel type definition on a service task. The integration logic is all delegated to the Camel container. By default the Activiti Engine looks for a camelContext bean in the Spring container. The camelContext bean defines the Camel routes that will be loaded by the Camel container. In the following example the routes are loaded from a specific Java package, but you can also define routes directly in the Spring configuration itself.

[source,xml,linenums]
----
<camelContext id="camelContext" xmlns="http://camel.apache.org/schema/spring">
  <packageScan>
    <package>org.activiti.camel.route</package>
  </packageScan>
</camelContext>
----

For more documentation about Camel routes you can look on the link:$$http://camel.apache.org/$$[Camel website]. The basic concepts are demonstrated through a few small samples here in this document. In the first sample, we will do the simplest form of Camel call from an Activiti workflow. Let's call it SimpleCamelCall.

If you want to define multiple Camel context beans and/or want to use a different bean name, this can be overridden on the Camel task definition like this:

[source,xml,linenums]
----
<serviceTask id="serviceTask1" activiti:type="camel">
  <extensionElements>
    <activiti:field name="camelContext" stringValue="customCamelContext" />
  </extensionElements>
</serviceTask>
----


[[bpmnCamelTaskSimpleCamelCall]]


===== Simple Camel Call example


All the files related to this example can be found in org.activiti.camel.examples.simpleCamelCall package of activiti-camel module. The target is simply activating a specific camel route. First of all we need an Spring context which contains the introduction to the routes as mentioned previously. This part of the file serves this purpose:

[source,xml,linenums]
----
<camelContext id="camelContext" xmlns="http://camel.apache.org/schema/spring">
  <packageScan>
    <package>org.activiti.camel.examples.simpleCamelCall</package>
  </packageScan>
</camelContext>
----

[source,java,linenums]
----
public class SimpleCamelCallRoute extends RouteBuilder {

  @Override
  public void configure() throws Exception {
    from("activiti:SimpleCamelCallProcess:simpleCall").to("log:org.activiti.camel.examples.SimpleCamelCall");
  }
}
----

The route just logs the message body and nothing more. Notice the format of the from endpoint. It is consisted of three parts:


[options="header"]
|===============
|Endpoint Url Part|Description
|activiti|refers to Activiti endpoint
|SimpleCamelCallProcess|name of the process
|simpleCall|name of the Camel service in the process

|===============

Ok, our route is now properly configured and accessible to the Camel. Now comes the workflow part. The workflow looks like:

[source,xml,linenums]
----
<process id="SimpleCamelCallProcess">
  <startEvent id="start"/>
  <sequenceFlow id="flow1" sourceRef="start" targetRef="simpleCall"/>

  <serviceTask id="simpleCall" activiti:type="camel"/>

  <sequenceFlow id="flow2" sourceRef="simpleCall" targetRef="end"/>
  <endEvent id="end"/>
</process>
----


[[bpmnCamelTaskPingPong]]


===== Ping Pong example


Our example worked but nothing is really transferred between Camel and Activiti and there is not much merit in it. In this example we try to send and receive data to and from Camel. We send a string, camel concatenates something to it and returns back the result. The sender part is trivial, we send our message in form of a variable to Camel Task. Here is our caller code:



[source,java,linenums]
----
@Deployment
public void testPingPong() {
  Map<String, Object> variables = new HashMap<String, Object>();

  variables.put("input", "Hello");
  Map<String, String> outputMap = new HashMap<String, String>();
  variables.put("outputMap", outputMap);

  runtimeService.startProcessInstanceByKey("PingPongProcess", variables);
  assertEquals(1, outputMap.size());
  assertNotNull(outputMap.get("outputValue"));
  assertEquals("Hello World", outputMap.get("outputValue"));
}
----


The variable "input" is actually the input for the Camel route and outputMap is there to capture the result back from Camel. The process should be something like this:

[source,xml,linenums]
----
<process id="PingPongProcess">
  <startEvent id="start"/>
  <sequenceFlow id="flow1" sourceRef="start" targetRef="ping"/>
  <serviceTask id="ping" activiti:type="camel"/>
  <sequenceFlow id="flow2" sourceRef="ping" targetRef="saveOutput"/>
  <serviceTask id="saveOutput"  activiti:class="org.activiti.camel.examples.pingPong.SaveOutput" />
  <sequenceFlow id="flow3" sourceRef="saveOutput" targetRef="end"/>
  <endEvent id="end"/>
</process>

----

Note that SaveOutput Service task, stores the value of "Output" variable from context to the previously mentioned OutputMap. Now we have to know how the variables are send to Camel and returned back. Here comes the notion of Camel behaviour into the play. The way variables are communicated to Camel is configurable via CamelBehavior. Here we use Default one in our sample, a short description of the other ones comes afterwards. With such a code you can configure the desired camel behaviour:

[source,xml,linenums]
----
<serviceTask id="serviceTask1" activiti:type="camel">
  <extensionElements>
    <activiti:field name="camelBehaviorClass" stringValue="org.activiti.camel.impl.CamelBehaviorCamelBodyImpl" />
  </extensionElements>
</serviceTask>
----

If you do not specify and specific behaviour then, org.activiti.camel.impl.CamelBehaviorDefaultImpl will be set. This behaviour copies the variables to Camel properties of the same name. In return regardless of selected behaviour, if the camel message body is a map, then each of its elements is copied as a variable, else the whole object is copied into a specific variable with the name of "camelBody". Knowing that, this camel route concludes our second example:

[source,java,linenums]
----
@Override
public void configure() throws Exception {
  from("activiti:PingPongProcess:ping").transform().simple("${property.input} World");
}
----

In this route, the string "world" is concatenated to the end of property named "input" and the result will be in the message body. It is accessible by checking "camelBody" variable in the java service task and copied to "outputMap" and checked in test case. Now that the example on its default behaviour works, lets see what are the other possibilities. In starting every camel route, the Process Instance ID will be copied into a camel property with the specific name of "PROCESS_ID_PROPERTY". It is later used for correlating the process instance and camel route. Also it can be exploited in the Camel route.


There are three different behaviours already available out of the box in Activiti. The behaviour can be overwritten by a specific phrase in the route URL. Here is an example of overriding the already defined behaviour in URL:

[source,java,linenums]
----
from("activiti:asyncCamelProcess:serviceTaskAsync2?copyVariablesToProperties=true").

----

the following table provides an overview of three available camel behaviours:

[options="header"]
|===============
|Behaviour|In Url|Description
|CamelBehaviorDefaultImpl|copyVariablesToProperties|Copy Activiti variables as Camel properties
|CamelBehaviorCamelBodyImpl|copyCamelBodyToBody|Copy only Activiti variable named "camelBody" as camel message body
|CamelBehaviorBodyAsMapImpl|copyVariablesToBodyAsMap|Copy all the Activiti variables in a map as Camel message body

|===============


The above table explains how Activiti variables are going to be transferred to Camel. The following table explains how the Camel variables are returned back to Activiti. This can only be configured in route URLs.

[options="header"]
|===============
|Url|Description
|Default|If Camel body is a map, copy each element as Activiti variable, otherwise copy the whole Camel body as "camelBody" Activiti variable
|copyVariablesFromProperties|Copy Camel properties as Activiti variables of the same name
|copyCamelBodyToBodyAsString|like default, but if camel Body is not a map, first convert it to String and then copy it in "camelBody"
|copyVariablesFromHeader|Additionally copy camel headers to Activiti variables of the same names

|===============

===== Returning back the variables
What is mentioned above about passing variables, only holds for start side of the variable transfer, in both directions from Camel to Activiti and vice versa. +
It is important to notice that because of special non blocking behavior of Activiti, variables are not automatically returned back from Activiti to Camel.
For that to happen, a special syntax is available. There can be one or more parameters in Camel route URL in format of +var.return.someVariableName+.
All variables having a name equal to one of these parameters without +var.return+ part, will be considered as output variables and will be copied back as camel properties with the same names. +
For example in a route like:
----
from("direct:start").to("activiti:process?var.return.exampleVar").to("mock:result");
----

Activiti variable with the name of +exampleVar+ will be considered as output variable and will be copied back as a property in camel with the same name.


[[bpmnCamelTaskAsyncPingPong]]


===== Asynchronous Ping Pong example

Previous examples were all synchronous. The workflow stops, until the camel route is concluded and returned. In some cases, we might need the Activiti workflow to continue. For such purposes the asynchronous capability of the Camel service task is useful. You can make use of this feature by setting the async property of the Camel service task to true.

[source,xml,linenums]
----
<serviceTask id="serviceAsyncPing" activiti:type="camel" activiti:async="true"/>
----


By setting this feature the specified Camel route is activated asynchronously by the Activiti job executor. When you define a queue in the Camel route the Activiti process will continue with the activities after the Camel service task. The Camel route will be executed fully asynchronously from the process execution. If you want to wait for a response of the Camel service task somewhere in your process definition, you can use a receive task.

[source,xml,linenums]
----
<receiveTask id="receiveAsyncPing" name="Wait State" />
----

The process instance will wait until a signal is received, for example from Camel. In Camel you can send a signal to the process instance by sending a message to the proper Activiti endpoint.

[source,java,linenums]
----
 from("activiti:asyncPingProcess:serviceAsyncPing").to("activiti:asyncPingProcess:receiveAsyncPing");
----


* constant string "activiti"
* process name
* receive task name


[[bpmnCamelTaskAsyncPingPong]]


===== Instantiate workflow from Camel route

In our all previous examples Activiti workflow started first and the Camel route was started within workflow. It is also possible from the other side. It is possible that a workflow is instantiated from an already started camel route. It is very similar to signalling receive task, except that the last part is not there. Here is a sample route:

[source,java,linenums]
----
from("direct:start").to("activiti:camelProcess");
----

as you see the url has two parts, the first is constant string "activiti" and the second name is the name of the process. Obviously the process should already be deployed and startable by engine configuration.

It is also possible to set the initiator of the process to some authenticated user id that is provided in a Camel header. To achieve this first of all an initiator variable must be specified in the process definition:

[source,xml,linenums]
----
<startEvent id="start" activiti:initiator="initiator" />
----

Then given that the user id is contained in a Camel header named _CamelProcessInitiatorHeader_ the Camel route could be defined as follows:

[source,java,linenums]
----
from("direct:startWithInitiatorHeader")
    .setHeader("CamelProcessInitiatorHeader", constant("kermit"))
    .to("activiti:InitiatorCamelCallProcess?processInitiatorHeaderName=CamelProcessInitiatorHeader");
----


[[bpmnManualTask]]


==== Manual Task

[[bpmnManualTaskDescription]]


===== Description

A _Manual Task_ defines a task that is external to the BPM engine. It is used to model work that is done by somebody, which the engine does not need to know of, nor is there a system or UI interface. For the engine, a manual task is handled as a *pass-through activity*, automatically continuing the process from the moment process execution arrives into it.


[[bpmnManualTaskGraphicalNotation]]


===== Graphical Notation

A manual task is visualized as a rounded rectangle, with a little 'hand' icon in the upper left corner

image::images/bpmn.manual.task.png[align="center"]



[[bpmnManualTaskXml]]


===== XML representation

[source,xml,linenums]
----
<manualTask id="myManualTask" name="Call client for more information" />
----


[[bpmnReceiveTask]]


==== Java Receive Task

[[bpmnReceiveTaskDescription]]


===== Description


A Receive Task is a simple task that waits for the arrival of a certain message. Currently, we have only implemented Java semantics for this task. When process execution arrives at a Receive Task, the process state is committed to the persistence store. This means that the process will stay in this wait state, until a specific message is received by the engine, which triggers the continuation of the process past the Receive Task.


===== Graphical notation

A Receive Task is visualized as a task (rounded rectangle) with a message icon in the top left corner. The message is white (a black message icon would have send semantics)

image::images/bpmn.receive.task.png[align="center"]


===== XML representation

[source,xml,linenums]
----
<receiveTask id="waitState" name="wait" />
----

To continue a process instance that is currently waiting at such a Receive Task, the _runtimeService.signal(executionId)_ must be called using the id of the execution that arrived in the Receive Task. The following code snippet shows how this works in practice:

[source,java,linenums]
----
ProcessInstance pi = runtimeService.startProcessInstanceByKey("receiveTask");
Execution execution = runtimeService.createExecutionQuery()
  .processInstanceId(pi.getId())
  .activityId("waitState")
  .singleResult();
assertNotNull(execution);

runtimeService.signal(execution.getId());
----


[[bpmnShellTask]]


==== Shell Task

[[bpmnShellTaskDescription]]


===== Description

The shell task allows to run shell scripts and commands. Note that the Shell task is *not* an 'official' task of BPMN 2.0 spec (and it does not have a dedicated icon as a consequence).


[[bpmnShellTaskUsage]]


===== Defining a shell task

The shell task is implemented as a dedicated <<bpmnJavaServiceTask,Service Task>> and is defined by setting _'shell'_ for the _type_ of the service task.

[source,xml,linenums]
----
<serviceTask id="shellEcho" activiti:type="shell">
----

The Shell task is configured by <<serviceTaskFieldInjection,field injection>>. All the values for these properties can contain EL expression, which are resolved at runtime during process execution. Following properties could be set:

[options="header"]
|===============
|Property|Required?|Type|Description|Default
|command|yes|String|Shell command to execute.|
|arg0-5|no|String|Parameter 0 to Parameter 5|
|wait|no|true/false|wait if necessary, until the shell process has terminated.|true
|redirectError|no|true/false|Merge standard error with the standard output.|false
|cleanEnv|no|true/false|Shell process does not inherit current environment.|false
|outputVariable|no|String|Name of variable to contain the output|Output is not recorded.
|errorCodeVariable|no|String|Name of variable to contain result error code|Error level is not registered.
|directory|no|String|Default directory of shell process|Current directory

|===============



[[bpmnShellTaskExampleUsage]]


===== Example usage

The following XML snippet shows an example of using the shell Task. It runs shell script "cmd /c echo EchoTest", waits for it to be terminated and puts the result in resultVar

[source,xml,linenums]
----
<serviceTask id="shellEcho" activiti:type="shell" >
  <extensionElements>
    <activiti:field name="command" stringValue="cmd" />
    <activiti:field name="arg1" stringValue="/c" />
    <activiti:field name="arg2" stringValue="echo" />
    <activiti:field name="arg3" stringValue="EchoTest" />
    <activiti:field name="wait" stringValue="true" />
    <activiti:field name="outputVariable" stringValue="resultVar" />
  </extensionElements>
</serviceTask>

----


[[executionListeners]]


==== Execution listener

*Compatibility note*: After releasing 5.3, we discovered that execution listeners and task listeners and expressions were still in non-public API. Those classes were in subpackages of +org.activiti.engine.impl...+,  which has +impl+ in it). +org.activiti.engine.impl.pvm.delegate.ExecutionListener+, +org.activiti.engine.impl.pvm.delegate.TaskListener+ and +org.activiti.engine.impl.pvm.el.Expression+ have been deprecated. From now on, you should use +org.activiti.engine.delegate.ExecutionListener+, +org.activiti.engine.delegate.TaskListener+ and +org.activiti.engine.delegate.Expression+. In the new publicly available API, access to +ExecutionListenerExecution.getEventSource()+ has been removed.  Apart from the deprecation compiler warning, the existing code should run fine.  But consider switching to the new public API interfaces (without .impl. in the package name).

Execution listeners allow you to execute external Java code or evaluate an expression when certain events occur during process execution. The events that can be captured are:

* Start and ending of a process instance.
* Taking a transition.
* Start and ending of an activity.
* Start and ending of a gateway.
* Start and ending of intermediate events.
* Ending a start event or starting an end event.

The following process definition contains 3 execution listeners:

[source,xml,linenums]
----
<process id="executionListenersProcess">

  <extensionElements>
    <activiti:executionListener class="org.activiti.examples.bpmn.executionlistener.ExampleExecutionListenerOne" event="start" />
  </extensionElements>

  <startEvent id="theStart" />
  <sequenceFlow sourceRef="theStart" targetRef="firstTask" />

  <userTask id="firstTask" />
  <sequenceFlow sourceRef="firstTask" targetRef="secondTask">
    <extensionElements>
      <activiti:executionListener class="org.activiti.examples.bpmn.executionListener.ExampleExecutionListenerTwo" />
    </extensionElements>
  </sequenceFlow>

  <userTask id="secondTask" >
    <extensionElements>
      <activiti:executionListener expression="${myPojo.myMethod(execution.event)}" event="end" />
    </extensionElements>
  </userTask>
  <sequenceFlow sourceRef="secondTask" targetRef="thirdTask" />

  <userTask id="thirdTask" />
  <sequenceFlow sourceRef="thirdTask" targetRef="theEnd" />

  <endEvent id="theEnd" />

</process>
----


The first execution listener is notified when the process starts. The listener is an external Java-class (like ++ExampleExecutionListenerOne++) and should implement +org.activiti.engine.delegate.ExecutionListener+ interface. When the event occurs (in this case +end+ event) the method +notify(ExecutionListenerExecution execution)+ is called.

[source,java,linenums]
----
public class ExampleExecutionListenerOne implements ExecutionListener {

  public void notify(ExecutionListenerExecution execution) throws Exception {
    execution.setVariable("variableSetInExecutionListener", "firstValue");
    execution.setVariable("eventReceived", execution.getEventName());
  }
}
----

It is also possible to use a delegation class that implements the +org.activiti.engine.delegate.JavaDelegate+ interface. These delegation classes can then be reused in other constructs, such as a delegation for a serviceTask.

The second execution listener is called when the transition is taken. Note that the +listener+ element doesn't define an +event+, since only +take+ events are fired on transitions. *Values in the +event+ attribute are ignored when a listener is defined on a transition.*

The last execution listener is called when activity +secondTask+ ends. Instead of using the +class+ on the listener declaration, a +expression+ is defined instead which is evaluated/invoked when the event is fired.

[source,xml,linenums]
----
<activiti:executionListener expression="${myPojo.myMethod(execution.eventName)}" event="end" />
----

As with other expressions, execution variables are resolved and can be used. Because the execution implementation object has a property that exposes the event name, it's possible to pass the event-name to your methods using +execution.eventName+.

Execution listeners also support using a +delegateExpression+, <<bpmnJavaServiceTaskXML,similar to a service task>>.

[source,xml,linenums]
----
<activiti:executionListener event="start" delegateExpression="${myExecutionListenerBean}" />
----


In Activiti 5.12 we also introduced a new type of execution listener, the org.activiti.engine.impl.bpmn.listener.ScriptExecutionListener. This script execution listener allows you to execute a piece of script logic for an execution listener event.

[source,xml,linenums]
----
<activiti:executionListener event="start" class="org.activiti.engine.impl.bpmn.listener.ScriptExecutionListener" >
  <activiti:field name="script">
    <activiti:string>
      def bar = "BAR";  // local variable
      foo = "FOO"; // pushes variable to execution context
      execution.setVariable("var1", "test"); // test access to execution instance
      bar // implicit return value
    </activiti:string>
  </activiti:field>
  <activiti:field name="language" stringValue="groovy" />
  <activiti:field name="resultVariable" stringValue="myVar" />
<activiti:executionListener>
----


[[executionListenerFieldInjection]]


===== Field injection on execution listeners

When using an execution listener that is configured with the +class+ attribute, field injection can be applied. This is exactly the same mechanism as used <<serviceTaskFieldInjection,Service task field injection>>, which contains an overview of the possibilities provided by field injection.

The fragment below shows a simple example process with an execution listener with fields injected.

[source,xml,linenums]
----
<process id="executionListenersProcess">
  <extensionElements>
    <activiti:executionListener class="org.activiti.examples.bpmn.executionListener.ExampleFieldInjectedExecutionListener" event="start">
      <activiti:field name="fixedValue" stringValue="Yes, I am " />
      <activiti:field name="dynamicValue" expression="${myVar}" />
    </activiti:executionListener>
  </extensionElements>

  <startEvent id="theStart" />
  <sequenceFlow sourceRef="theStart" targetRef="firstTask" />

  <userTask id="firstTask" />
  <sequenceFlow sourceRef="firstTask" targetRef="theEnd" />

  <endEvent id="theEnd" />
</process>
----

[source,java,linenums]
----
public class ExampleFieldInjectedExecutionListener implements ExecutionListener {

  private Expression fixedValue;

  private Expression dynamicValue;

  public void notify(ExecutionListenerExecution execution) throws Exception {
    execution.setVariable("var", fixedValue.getValue(execution).toString() + dynamicValue.getValue(execution).toString());
  }
}
----

The class +ExampleFieldInjectedExecutionListener+ concatenates the 2 injected fields (one fixed an the other dynamic) and stores this in the process variable '++var++'.

[source,java,linenums]
----
@Deployment(resources = {"org/activiti/examples/bpmn/executionListener/ExecutionListenersFieldInjectionProcess.bpmn20.xml"})
public void testExecutionListenerFieldInjection() {
  Map<String, Object> variables = new HashMap<String, Object>();
  variables.put("myVar", "listening!");

  ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("executionListenersProcess", variables);

  Object varSetByListener = runtimeService.getVariable(processInstance.getId(), "var");
  assertNotNull(varSetByListener);
  assertTrue(varSetByListener instanceof String);

  // Result is a concatenation of fixed injected field and injected expression
  assertEquals("Yes, I am listening!", varSetByListener);
}
----

Note that the same rules with regards to thread-safety apply as for service task. Please read the <<serviceTaskFieldInjectionThreadSafety, relevant section>> for more information.

[[taskListeners]]


==== Task listener

A _task listener_ is used to execute custom Java logic or an expression upon the occurrence of a certain task-related event.

A task listener can only be added in the process definition as a child element of a <<bpmnUserTask,user task>>. Note that this also must happen as a child of the _BPMN 2.0 extensionElements_ and in the _activiti_ namespace, since a task listener is an Activiti-specific construct.


[source,xml,linenums]
----
<userTask id="myTask" name="My Task" >
  <extensionElements>
    <activiti:taskListener event="create" class="org.activiti.MyTaskCreateListener" />
  </extensionElements>
</userTask>
----

A _task listener_ supports following attributes:

* *event* (required): the type of task event on which the task listener will be invoked. Possible events are
** *create*: occurs when the task has been created an *all task properties are set*.
** *assignment*: occurs when the task is assigned to somebody. Note: when process execution arrives in a userTask, first an _assignment_ event will be fired, *before* the _create_ event is fired. This might seem an unnatural order, but the reason is pragmatic: when receiving the _create_ event, we usually want to inspect all properties of the task including the assignee.
** *complete*: occurs when the task is completed and just before the task is deleted from the runtime data.
** *delete*: occurs just before the task is going to be deleted. Notice that it will also be executed when task is normally finished via completeTask.
* *class*: the delegation class that must be called. This class must implement the +org.activiti.engine.delegate.TaskListener+ interface.

[source,java,linenums]
----
public class MyTaskCreateListener implements TaskListener {

  public void notify(DelegateTask delegateTask) {
    // Custom logic goes here
  }

}
----

It is also possible to use <<serviceTaskFieldInjection,field injection>> to pass process variables or the execution to the delegation class. Note that an instance of the delegation class is created upon process deployment (as is the case with any class delegation in Activiti), which means that the instance is shared between all process instance executions.

* *expression*: (cannot be used together with the _class_ attribute): specifies an expression that will be executed when the event happens. It is possible to pass the +DelegateTask+ object and the name of the event (using ++task.eventName++) as parameter to the called object.

[source,java,linenums]
----
<activiti:taskListener event="create" expression="${myObject.callMethod(task, task.eventName)}" />
----

* *delegateExpression* allows to specify an expression that resolves to an object implementing the +TaskListener+ interface, <<bpmnJavaServiceTaskXML,similar to a service task>>.

[source,xml,linenums]
----
<activiti:taskListener event="create" delegateExpression="${myTaskListenerBean}" />
----

* In Activiti 5.12 we also introduced a new type of task listener, the org.activiti.engine.impl.bpmn.listener.ScriptTaskListener. This script task listener allows you to execute a piece of script logic for an task listener event.

[source,xml,linenums]
----
<activiti:taskListener event="complete" class="org.activiti.engine.impl.bpmn.listener.ScriptTaskListener" >
  <activiti:field name="script">
    <activiti:string>
      def bar = "BAR";  // local variable
      foo = "FOO"; // pushes variable to execution context
      task.setOwner("kermit"); // test access to task instance
      bar // implicit return value
    </activiti:string>
  </activiti:field>
  <activiti:field name="language" stringValue="groovy" />
  <activiti:field name="resultVariable" stringValue="myVar" />
<activiti:taskListener>
----


[[bpmnMultiInstance]]


==== Multi-instance (for each)

[[bpmnMultiInstanceDescription]]


===== Description


A _multi-instance activity_ is a way of defining repetition for a certain step in a business process. In programming concepts, a multi-instance matches the *for each* construct: it allows to execute a certain step or even a complete subprocess for each item in a given collection, *sequentially or in parallel*.

A _multi-instance_ is a regular activity that has extra properties defined (so-called _'multi-instance_ characteristics'') which will cause the activity to be executed multiple times at runtime. Following activities can become a _multi-instance activity:_

* <<bpmnUserTask,User Task>>
* <<bpmnScriptTask,Script Task>>
* <<bpmnJavaServiceTask,Java Service Task>>
* <<bpmnWebserviceTask,Web Service Task>>
* <<bpmnBusinessRuleTask,Business Rule Task>>
* <<bpmnEmailTask,Email Task>>
* <<bpmnManualTask,Manual Task>>
* <<bpmnReceiveTask,Receive Task>>
* <<bpmnSubProcess,(Embedded) Sub-Process>>
* <<bpmnCallActivity,Call Activity>>

A <<bpmnGateways,Gateway>> or <<bpmnEvents,Event>> *cannot* become multi-instance.

As required by the spec, each parent execution of the created executions for each instance will have following variables:

* *nrOfInstances*: the total number of instances
* *nrOfActiveInstances*: the number of currently active, i.e. not yet finished, instances. For a sequential multi-instance, this will always be 1.
* *nrOfCompletedInstances*: the number of already completed instances.

These values can be retrieved by calling the +execution.getVariable(x)+ method.

Additionally, each of the created executions will have an execution-local variable (i.e. not visible for the other executions, and not stored on process instance level) :

* *loopCounter*: indicates the _index in the for-each loop_ of that particular instance. loopCounter variable can be renamed by Activiti *elementIndexVariable* attribute.


[[bpmnMultiInstanceGraphicalNotation]]


===== Graphical notation

If an activity is multi-instance, this is indicated by three short lines at the bottom of that activity. Three _vertical_ lines indicates that the instances will be executed in parallel, while three _horizontal_ lines indicate sequential execution.

image::images/bpmn.multi.instance.png[align="center"]



[[bpmnMultiInstanceXml]]


===== Xml representation

To make an activity multi-instance, the activity xml element must have a +multiInstanceLoopCharacteristics+ child element.

[source,xml,linenums]
----
<multiInstanceLoopCharacteristics isSequential="false|true">
 ...
</multiInstanceLoopCharacteristics>
----

The *isSequential* attribute indicates if the instances of that activity are executed sequentially or parallel.

The number of instances are *calculated once, when entering the activity*. There are a few ways of configuring this. On way is directly specifying a number, by using the *loopCardinality* child element.

[source,xml,linenums]
----
<multiInstanceLoopCharacteristics isSequential="false|true">
  <loopCardinality>5</loopCardinality>
</multiInstanceLoopCharacteristics>
----

Expressions that resolve to a positive number are also possible:

[source,xml,linenums]
----
<multiInstanceLoopCharacteristics isSequential="false|true">
  <loopCardinality>${nrOfOrders-nrOfCancellations}</loopCardinality>
</multiInstanceLoopCharacteristics>
----

Another way to define the number of instances, is to specify the name of a process variable which is a collection using the +loopDataInputRef+ child element. For each item in the collection, an instance will be created. Optionally, it is possible to set that specific item of the collection for the instance using the +inputDataItem+ child element. This is shown in the following XML example:

[source,xml,linenums]
----
<userTask id="miTasks" name="My Task ${loopCounter}" activiti:assignee="${assignee}">
  <multiInstanceLoopCharacteristics isSequential="false">
    <loopDataInputRef>assigneeList</loopDataInputRef>
    <inputDataItem name="assignee" />
  </multiInstanceLoopCharacteristics>
</userTask>
----

Suppose the variable +assigneeList+ contains the values +\[kermit, gonzo, fozzie\]+. In the snippet above, three user tasks will be created in parallel. Each of the executions will have a process variable named +assignee+ containing one value of the collection, which is used to assign the user task in this example.

The downside of the +loopDataInputRef+ and +inputDataItem+ is that 1) the names are pretty hard to remember and 2) due to the BPMN 2.0 schema restrictions they can't contain expressions. Activiti solves this by offering the *collection* and *elementVariable* attributes on the ++multiInstanceCharacteristics++:

[source,xml,linenums]
----
<userTask id="miTasks" name="My Task" activiti:assignee="${assignee}">
  <multiInstanceLoopCharacteristics isSequential="true"
     activiti:collection="${myService.resolveUsersForTask()}" activiti:elementVariable="assignee" >
  </multiInstanceLoopCharacteristics>
</userTask>
----

A multi-instance activity ends when all instances are finished. However, it is possible to specify an expression that is evaluated every time one instance ends. When this expression evaluates to true, all remaining instances are destroyed and the multi-instance activity ends, continuing the process. Such an expression must be defined in the *completionCondition* child element.

[source,xml,linenums]
----
<userTask id="miTasks" name="My Task" activiti:assignee="${assignee}">
  <multiInstanceLoopCharacteristics isSequential="false"
     activiti:collection="assigneeList" activiti:elementVariable="assignee" >
    <completionCondition>${nrOfCompletedInstances/nrOfInstances >= 0.6 }</completionCondition>
  </multiInstanceLoopCharacteristics>
</userTask>
----

In this example, there will be parallel instances created for each element of the +assigneeList+ collection. However, when 60% of the tasks are completed, the other tasks are deleted and the process continues.


[[bpmnMultiInstanceBoundaryEvent]]


===== Boundary events and multi-instance

Since a multi-instance is a regular activity, it is possible to define a <<bpmnBoundaryEvent,boundary event>> on its boundary. In case of an interrupting boundary event, when the event is caught, *all instances* that are still active will be destroyed. Take for example following multi-instance subprocess:

image::images/bpmn.multi.instance.boundary.event.png[align="center"]

Here, all instances of the subprocess will be destroyed when the timer fires, regardless of how many instances there are or which inner activities are currently not yet completed.


[[bpmnCompensationHandlers]]

===== Multi instance and execution listeners

(Valid for Activiti 5.18 and up)

There is a caveat when using execution listeners in combination with multi instance. Take for example the following snippet of BPMN 2.0 xml, which is defined on the same level as the _multiInstanceLoopCharacteristics_ xml element is set:

[source,xml,linenums]
----
<extensionElements>
    <activiti:executionListener event="start" class="org.activiti.MyStartListener"/>
		<activiti:executionListener event="end" class="org.activiti.MyEndListener"/>
</extensionElements>
----

For a normal BPMN activity, there would be an invocation of these listeners when the activity is started and ended.

However, when the activity is multi instance, the behavior is different:

* When the multi instance activity is entered, before any of the _inner_ activities is executed, a start event is thrown. The _loopCounter_ variable is not yet set (is null).
* For each of the actual activities visited, a start event is thrown. The _loopCounter_ variable is set.

The same reasoning applies for the end event:

* When the actual activity is left, an end even is thrown. The _loopCounter_ variable is set.
* When the multi instance activity has finished as a whole, an end event is thrown. The _loopCounter_ variable is not set.

For example:

[source,xml,linenums]
----
<subProcess id="subprocess1" name="Sub Process">
  <extensionElements>
    <activiti:executionListener event="start" class="org.activiti.MyStartListener"/>
    <activiti:executionListener event="end" class="org.activiti.MyEndListener"/>
  </extensionElements>
  <multiInstanceLoopCharacteristics isSequential="false">
    <loopDataInputRef>assignees</loopDataInputRef>
    <inputDataItem name="assignee"></inputDataItem>
  </multiInstanceLoopCharacteristics>
  <startEvent id="startevent2" name="Start"></startEvent>
  <endEvent id="endevent2" name="End"></endEvent>
  <sequenceFlow id="flow3" name="" sourceRef="startevent2" targetRef="endevent2"></sequenceFlow>
</subProcess>
----

In this example, suppose the _assignees_ list has three items. The following happens at runtime:

* A start event is thrown for the multi instance as a whole. The _start_ execution listener is invoked. The _loopCounter_ nor the _assignee_ variable will not be set (i.e. they will be null).
* A start event is thrown for each activity instance. The _start_ execution listener is invoked three times. The _loopCounter_ nor the _assignee_ variable will be set (i.e. different from null).
* So in total, the start execution listener is invoked four times.

Note that the same applies when the _multiInstanceLoopCharacteristics_ are defined on something else than a subprocess too. For example in case the example above would be a simple userTask, the same reasoning still applies.



==== Compensation Handlers

[[bpmnCompensationHandlerDescription]]


===== Description

<<experimental,[EXPERIMENTAL]>>

If an activity is used for compensating the effects of another activity, it can be declared to be a compensation handler. Compensation handlers are not contained in normal flow and are only executed when a compensation event is thrown.

Compensation handlers must not have incoming or outgoing sequence flows.

A compensation handler must be associated with a compensation boundary event using a directed association.


[[bpmnCompensationHandlerGraphicalNotation]]


===== Graphical notation

If an activity is a compensation handler, the compensation event icon is displayed in the center bottom area. The following excerpt from a process diagram shows a service task with an attached compensation boundary event which is associated to a compensation handler. Notice the compensation handler icon in the bottom canter area of the "cancel hotel reservation" service task.

image::images/bpmn.boundary.compensation.event.png[align="center"]


[[bpmnCompensationHandlerXml]]


===== XML representation

In order to declare an activity to be a compensation handler, we need to set the attribute isForCompensation to true:

[source,xml,linenums]
----
<serviceTask id="undoBookHotel" isForCompensation="true" activiti:class="...">
</serviceTask>
----

[[bpmnSubprocessAndCallActivity]]


=== Sub-Processes and Call Activities

[[bpmnSubProcess]]


==== Sub-Process

[[bpmnSubProcessDescription]]


===== Description


A _Sub-Process_ is an activity that contains other activities, gateways, events, etc. which on itself form a process that is part of the bigger process. A _Sub-Process_ is completely defined inside a parent process (that's why it's often called an _embedded_ Sub-Process).

Sub-Processes have two major use cases:

* Sub-Processes allow *hierarchical modeling*. Many modeling tools allow that Sub-Processes can be _collapsed_, hiding all the details of the Sub-Process and displaying a high-level end-to-end overview of the business process.
* A Sub-Process creates a new *scope for events*. Events that are thrown during execution of the Sub-Process, can be caught by <<bpmnBoundaryEvent,a boundary event>> on the boundary of the Sub-Process, thus creating a scope for that event limited to the Sub-Process.

Using a Sub-Process does impose some constraints:

* A Sub-Process can only have *one none start event*, no other start event types are allowed. A Sub-Process must *at least have one end event*. Note that the BPMN 2.0 specification allows to omit the start and end events in a Sub-Process, but the current Activiti implementation does not support this.
* *Sequence flow cannot cross Sub-Process boundaries.*


[[bpmnSubProcessGraphicalNotation]]


===== Graphical Notation

A Sub-Process is visualized as a typical activity, i.e. a rounded rectangle. In case the Sub-Process is _collapsed_, only the name and a plus-sign are displayed, giving a high-level overview of the process:

image::images/bpmn.collapsed.subprocess.png[align="center"]

In case the Sub-Process is _expanded_, the steps of the Sub-Process are displayed within the Sub-Process boundaries:

image::images/bpmn.expanded.subprocess.png[align="center"]

One of the main reasons to use a Sub-Process, is to define a scope for a certain event. The following process model shows this: both the _investigate software/investigate hardware_ tasks need to be done in parallel, but both tasks need to be done within a certain time, before _Level 2 support_ is consulted. Here, the scope of the timer (i.e. which activities must be done in time) is constrained by the Sub-Process.

image::images/bpmn.subprocess.with.boundary.timer.png[align="center"]


[[bpmnSubProcessXML]]


===== XML representation

A Sub-Process is defined by the _subprocess_ element. All activities, gateways, events, etc. that are part of the Sub-Process, need to be enclosed within this element.

[source,xml,linenums]
----
<subProcess id="subProcess">

  <startEvent id="subProcessStart" />

  ... other Sub-Process elements ...

  <endEvent id="subProcessEnd" />

 </subProcess>
----


[[bpmnEventSubprocess]]


==== Event Sub-Process

[[bpmnEventSubprocessDescription]]


===== Description


The Event Sub-Process is new in BPMN 2.0. An Event Sub-Process is a subprocess that is triggered by an event. An Event Sub-Process can be added at the process level or at any subprocess level. The event used to trigger an event subprocess is configured using a start event. From this, it follows that none start events are not supported for Event Sub-Processes. An Event Sub-Process might be triggered using events like message events, error events, signal events, timer events, or compensation events. The subscription to the start event is created when the scope (process instance or subprocess) hosting the Event Sub-Process is created. The subscription is removed when the scope is destroyed.

An Event Sub-Process may be interrupting or non-interrupting. An interrupting subprocess cancels any executions in the current scope. A non-interrupting Event Sub-Process spawns a new concurrent execution. While an interrupting Event Sub-Process can only be triggered once for each activation of the scope hosting it, a non-interrupting Event Sub-Process can be triggered multiple times. The fact whether the subprocess is interrupting is configured using the start event triggering the Event Sub-Process.

An Event Sub-Process must not have any incoming or outgoing sequence flows. Since an Event Sub-Process is triggered by an event, an incoming sequence flow makes no sense. When an Event Sub-Process is ended, either the current scope is ended (in case of an interrupting Event Sub-Process), or the concurrent execution spawned for the non-interrupting subprocess is ended.

*Current limitations:*

* Activiti only supports interrupting Event Sub-Processes.
* Activiti only supports Event Sub-Process triggered using an Error Start Event or Message Start Event.


[[bpmnEventSubprocessGraphicalNotation]]


===== Graphical Notation

An Event Sub-Process might be visualized as a an <<bpmnSubProcessGraphicalNotation,embedded subprocess>> with a dotted outline.

image::images/bpmn.subprocess.eventSubprocess.png[align="center"]


[[bpmnEventSubprocessXMLRepresentation]]


===== XML representation

An Event Sub-Process is represented using XML in the same way as a an embedded subprocess. In addition the attribute +triggeredByEvent+ must have the value ++true++:

[source,xml,linenums]
----
<subProcess id="eventSubProcess" triggeredByEvent="true">
	...
</subProcess>
----


[[bpmnEventSubprocessExample]]


===== Example

The following is an example of an Event Sub-Process triggered using an Error Start Event. The Event Sub-Process is located at the "process level", i.e. is scoped to the process instance:

image::images/bpmn.subprocess.eventSubprocess.example.1.png[align="center"]

This is how the Event Sub-Process would look like in XML:

[source,xml,linenums]
----
<subProcess id="eventSubProcess" triggeredByEvent="true">
	<startEvent id="catchError">
		<errorEventDefinition errorRef="error" />
	</startEvent>
	<sequenceFlow id="flow2" sourceRef="catchError" targetRef="taskAfterErrorCatch" />
	<userTask id="taskAfterErrorCatch" name="Provide additional data" />
</subProcess>
----

As already stated, an Event Sub-Process can also be added to an embedded subprocess. If it is added to an embedded subprocess, it becomes an alternative to a boundary event. Consider the two following process diagrams. In both cases the embedded subprocess throws an error event. Both times the error is caught and handled using a user task.

image::images/bpmn.subprocess.eventSubprocess.example.2a.png[align="center"]

as opposed to:

image::images/bpmn.subprocess.eventSubprocess.example.2b.png[align="center"]

In both cases the same tasks are executed. However, there are differences between both modelling alternatives:

* The embedded subprocess is executed using the same execution which executed the scope it is hosted in. This means that an embedded subprocess has access to the variables local to it's scope. When using a boundary event, the execution created for executing the embedded subprocess is deleted by the sequence flow leaving the boundary event. This means that the variables created by the embedded subprocess are not available anymore.
* When using an Event Sub-Process, the event is completely handled by the subprocess it is added to. When using a boundary event, the event is handled by the parent process.

These two differences can help you decide whether a boundary event or an embedded subprocess is better suited for solving a particular process modeling / implementation problem.


[[bpmnTransactionSubprocess]]


==== Transaction subprocess

<<experimental,[EXPERIMENTAL]>>[[bpmnTransactionSubprocessDescription]]


===== Description


A transaction subprocess is an embedded subprocess, which can be used to group multiple activities to a transaction. A transaction is a logical unit of work which allows to group a set of individual activities, such that they either succeed or fail collectively.

*Possible outcomes of a transaction:* A transaction can have three different outcomes:

* A transaction is _successful_, if it is neither cancelled not terminated by a hazard. If a transaction subprocess is successful, it is left using the outgoing sequenceflow(s). A successful transaction might be compensated if a compensation event is thrown later in the process. _Note:_ just as "ordinary" embedded subprocesses, a transaction may be compensated after successful completion using an intermediary throwing compensation event.
* A transaction is _cancelled_, if an execution reaches the cancel end event. In that case, all executions are terminated and removed. A single remaining execution is then set to the cancel boundary event, which triggers compensation. After compensation is completed, the transaction subprocess is left using the outgoing sequence flow(s) of the cancel boundary event.
* A transaction is ended by a _hazard_, if an error event is thrown, that is not caught within the scope of the transaction subprocess. (This also applies if the error is caught on the boundary of the transaction subprocess.) In this case, compensation is not performed.

The following diagram illustrates the three different outcomes:

image::images/bpmn.transaction.subprocess.example.1.png[align="center"]


*Relation to ACID transactions:* it is important not to confuse the bpmn transaction subprocess with technical (ACID) transactions. The bpmn transaction subprocess is not a way to scope technical transactions. In order to understand transaction management in Activiti, read the section on <<bpmnConcurrencyAndTransactions,concurrency and transactions>>. A bpmn transaction is different from a technical transaction in the following ways:

* While an ACID transaction is typically short lived, a bpmn transaction may take hours, days or even months to complete. (Consider the case where one of the activities grouped by a transaction is a usertask, typically people have longer response times than applications. Or, in another situation, a bpmn transaction might wait for some business event to occur, like the fact that a particular order has been fulfilled.) Such operations usually take considerably longer to complete than updating a record in a database, or storing a message using a transactional queue.
* Because it is impossible to scope a technical transaction to the duration of a business activity, a bpmn transaction typically spans multiple ACID transactions.
* Since a bpmn transaction spans multiple ACID transactions, we loose ACID properties. For example, consider the example given above. Let's assume the "book hotel" and the "charge credit card" operations are performed in separate ACID transactions. Let's also assume that the "book hotel" activity is successful. Now we have an intermediary inconsistent state, because we have performed an hotel booking but have not yet charged the credit card. Now, in an ACID transaction, we would also perform different operations sequentially and thus also have an intermediary inconsistent state. What is different here, is that the inconsistent state is visible outside of the scope of the transaction. For example, if the reservations are made using an external booking service, other parties using the same booking service might already see that the hotel is booked. This means, that when implementing business transactions, we completely loose the isolation property (Granted: we usually also relax isolation when working with ACID transactions to allow for higher levels of concurrency, but there we have fine grained control and intermediary inconsistencies are only present for very short periods of times).
* A bpmn business transaction can also not be rolled back in the traditional sense. Since it spans multiple ACID transactions, some of these ACID transactions might already be committed at the time the bpmn transaction is cancelled. At this point, they cannot be rolled back anymore.


Since bpmn transactions are long-running in nature, the lack of isolation and a rollback mechanism need to be dealt with differently. In practice, there is usually no better solution than to deal with these problems in a domain specific way:

* The rollback is performed using compensation. If a cancel event is thrown in the scope of a transaction, the effects of all activities that executed successfully and have a compensation handler are compensated.
* The lack of isolation is also often dealt with using domain specific solutions. For instance, in the example above, an hotel room might appear to be booked to a second customer, before we have actually made sure that the first customer can pay for it. Since this might be undesirable from a business perspective, a booking service might choose to allow for a certain amount of overbooking.
* In addition, since the transaction can be aborted in case of a hazard, the booking service has to deal with the situation where a hotel room is booked but payment is never attempted (since the transaction was aborted). In that case the booking service might choose a strategy where a hotel room is reserved for a maximum period of time and if payment is not received until then, the booking is cancelled.

To sum it up: while ACID transactions offer a generic solution to such problems (rollback, isolation levels and heuristic outcomes), we need to find domain specific solutions to these problems when implementing business transactions.

*Current limitations:*

* The BPMN specification requires that the process engine reacts to events issued by the underlying transaction protocol and for instance that a transaction is cancelled, if a cancel event occurs in the underlying protocol. As an embeddable engine, Activiti does currently not support this. (For some ramifications of this, see paragraph on consistency below.)

*Consistency on top of ACID transactions and optimistic concurrency:* A bpmn transaction guarantees consistency in the sense that either all activities compete successfully, or if some activity cannot be performed, the effects of all other successful activities are compensated. So either way we end up in a consistent state. However, it is important to recognize that in Activiti, the consistency model for bpmn transactions is superposed on top of the consistency model for process execution. Activiti executes processes in a transactional way. Concurrency is addressed using optimistic locking. In Activiti, bpmn error, cancel and compensation events are built on top of the same acid transactions and optimistic locking. For example, a cancel end event can only trigger compensation if it is actually reached. It is not reached if some undeclared exception is thrown by a service task before. Or, the effects of a compensation handler cannot be committed if some other participant in the underlying ACID transaction sets the transaction to the state rollback-only. Or, when two concurrent executions reach a cancel end event, compensation might be triggered twice and fail with an optimistic locking exception. All of this is to say that when implementing bpmn transactions in Activiti, the same set of rules apply as when implementing "ordinary" processes and subprocesses. So to effectively guarantee consistency, it is important to implement processes in a way that does take the optimistic, transactional execution model into consideration.


[[bpmnEventSubprocessGraphicalNotation]]


===== Graphical Notation


An transaction subprocess might be visualized as a an <<bpmnSubProcessGraphicalNotation,embedded subprocess>> with a double outline.

image::images/bpmn.transaction.subprocess.png[align="center"]


[[bpmnEventSubprocessXMLRepresentation]]


===== XML representation


A transaction subprocess is represented using xml using the  +transaction+ tag:

[source,xml,linenums]
----
<transaction id="myTransaction" >
	...
</transaction>
----


[[bpmnEventSubprocessExample]]


===== Example


The following is an example of a transaction subprocess:

image::images/bpmn.transaction.subprocess.example.2.png[align="center"]


[[bpmnCallActivity]]


==== Call activity (subprocess)

[[bpmnCallActivityDescription]]


===== Description

BPMN 2.0 makes a distinction between a regular _<<bpmnSubProcess,subprocess>>_, often also called _embedded subprocess_, and the call activity, which looks very similar. From a conceptual point of view, both will call a subprocess when process execution arrives at the activity.

The difference is that the call activity references a process that is external to the process definition, whereas the _<<bpmnSubProcess,subprocess>>_ is embedded within the original process definition. The main use case for the call activity is to have a reusable process definition that can be called from multiple other process definitions.

When process execution arrives in the _call activity_, a new execution is created that is a sub-execution of the execution that arrives in the call activity. This sub-execution is then used to execute the subprocess, potentially creating parallel child execution as within a regular process. The super-execution waits until the subprocess is completely ended, and continues the original process afterwards.


[[bpmnCallActivityGraphicalNotation]]


===== Graphical Notation


A call activity is visualized the same as a <<bpmnSubProcessGraphicalNotation,subprocess>>, however with a thick border (collapsed and expanded). Depending on the modeling tool, a call activity can also be expanded, but the default visualization is the collapsed subprocess representation.

image::images/bpmn.collapsed.call.activity.png[align="center"]


[[bpmnCallActivityXMLRepresentation]]


===== XML representation

A call activity is a regular activity, that requires a _calledElement_ that references a process definition by its *key*. In practice, this means that the *id of the process* is used in the _calledElement_.

[source,xml,linenums]
----
<callActivity id="callCheckCreditProcess" name="Check credit" calledElement="checkCreditProcess" />
----

Note that the process definition of the subprocess is *resolved at runtime*. This means that the subprocess can be deployed independently from the calling process, if needed.


[[bpmnCallActivityPassVariables]]


===== Passing variables

You can pass process variables to the sub process and vice versa. The data is copied into the subprocess when it is started and copied back into the main process when it ends.

[source,xml,linenums]
----
<callActivity id="callSubProcess" calledElement="checkCreditProcess" >
  <extensionElements>
	  <activiti:in source="someVariableInMainProcess" target="nameOfVariableInSubProcess" />
	  <activiti:out source="someVariableInSubProcess" target="nameOfVariableInMainProcess" />
  </extensionElements>
</callActivity>
----

We use an Activiti Extension as a shortcut for the BPMN standard elements called __dataInputAssociation__ and __dataOutputAssociation__, which only work if you declare process variables in the BPMN 2.0 standard way.

It is possible to use expressions here as well:

[source,xml,linenums]
----
<callActivity id="callSubProcess" calledElement="checkCreditProcess" >
	<extensionElements>
	  <activiti:in sourceExpression="${x+5}" target="y" />
	  <activiti:out source="${y+5}" target="z" />
	</extensionElements>
</callActivity>
----

So in the end z = y+5 = x+5+5


[[bpmnCallActivityExample]]


===== Example

The following process diagram shows a simple handling of an order. Since the checking of the customer's credit could be common to many other processes, the _check credit step_ is modeled here as a call activity.

image::images/bpmn.call.activity.super.process.png[align="center"]

The process looks as follows:

[source,xml,linenums]
----
<startEvent id="theStart" />
<sequenceFlow id="flow1" sourceRef="theStart" targetRef="receiveOrder" />

<manualTask id="receiveOrder" name="Receive Order" />
<sequenceFlow id="flow2" sourceRef="receiveOrder" targetRef="callCheckCreditProcess" />

<callActivity id="callCheckCreditProcess" name="Check credit" calledElement="checkCreditProcess" />
<sequenceFlow id="flow3" sourceRef="callCheckCreditProcess" targetRef="prepareAndShipTask" />

<userTask id="prepareAndShipTask" name="Prepare and Ship" />
<sequenceFlow id="flow4" sourceRef="prepareAndShipTask" targetRef="end" />

<endEvent id="end" />
----

The subprocess looks as follows:

image::images/bpmn.call.activity.sub.process.png[align="center"]

There is nothing special to the process definition of the subprocess. It could as well be used without being called from another process.


[[bpmnConcurrencyAndTransactions]]


=== Transactions and Concurrency

[[asyncContinuations]]


==== Asynchronous Continuations


Activiti executes processes in a transactional way which can be configured to suite your needs. Lets start by looking at how Activiti scopes transactions normally. If you trigger Activiti (i.e. start a process, complete a task, signal an execution), Activiti is going to advance in the process, until it reaches wait states on each active path of execution. More concretely speaking it performs a depth-first search through the process graph and returns if it has reached wait states on every branch of execution. A wait state is a task which is performed "later" which means that Activiti persists the current execution and waits to be triggered again. The trigger can either come from an external source for example if we have a user task or a receive message task, or from Activiti itself, if we have a timer event. This is illustrated in the following picture:

image::images/activiti.async.example.no.async.PNG[align="center"]

We see a segment of a BPMN processes with a usertask, a service task and a timer event. Completing the usertask and validating the address is part of the same unit of work, so it should succeed or fail atomically. That means that if the service task throws an exception we want to rollback the current transaction, such that the execution tracks back to the user task and the user task is still present in the database. This is also the default behavior of Activiti. In (1) an application or client thread completes the task. In that same thread Activiti is now executing the service and advances until it reaches a wait state, in this case the timer event (2). Then it returns the control to the caller (3) potentially committing the transaction (if it was started by Activiti).


In some cases this is not what we want. Sometimes we need custom control over transaction boundaries in a process, in order to be able to scope logical units of work. This is where asynchronous continuations come into play. Consider the following process (fragment):

image::images/activiti.async.example.async.PNG[align="center"]


This time we are completing the user task, generating an invoice and then send that invoice to the customer. This time the generation of the invoice is not part of the same unit of work so we do not want to rollback the completion of the usertask if generating an invoice fails. So what we want Activiti to do is complete the user task (1), commit the transaction and return the control to the calling application. Then we want to generate the invoice asynchronously, in a background thread. This background thread is the Activiti job executor (actually a thread pool) which periodically polls the database for jobs. So behind the scenes, when we reach the "generate invoice" task, we are creating a job "message" for Activiti to continue the process later and persisting it into the database. This job is then picked up by the job executor and executed. We are also giving the local job executor a little hint that there is a new job, to improve performance.

In order to use this feature, we can use the _activiti:async="true"_ extension. So for example, the service task would look like this:

[source,xml,linenums]
----
<serviceTask id="service1" name="Generate Invoice" activiti:class="my.custom.Delegate" activiti:async="true" />
----


_activiti:async_ can be specified on the following BPMN task types: task, serviceTask, scriptTask, businessRuleTask, sendTask, receiveTask, userTask, subProcess, callActivity


On a userTask, receiveTask or other wait states, the async continuation allows us to execute the start execution listeners in a separate  thread/transaction.


[[failRetry]]


==== Fail Retry

Activiti, in its default configuration, reruns a job 3 times in case of any exception in execution of a job. This holds also for asynchronous task jobs. In some cases more flexibility is required. There are two parameters to be configured:

* Number of retries
* Delay between retries These parameters can be configured by +activiti:failedJobRetryTimeCycle+ element. Here is a sample usage:

[source,xml,linenums]
----
<serviceTask id="failingServiceTask" activiti:async="true" activiti:class="org.activiti.engine.test.jobexecutor.RetryFailingDelegate">
	<extensionElements>
		<activiti:failedJobRetryTimeCycle>R5/PT7M</activiti:failedJobRetryTimeCycle>
	</extensionElements>
</serviceTask>
----

Time cycle expression follows ISO 8601 standard, just like timer event expressions. The above example, makes the job executor to retry the job 5 times and wait 7 minutes between before each retry.


[[exclusiveJobs]]


==== Exclusive Jobs

Since Activiti 5.9, the JobExecutor makes sure that jobs from a single process instance are never executed concurrently. Why is this?


===== Why exclusive Jobs?

Consider the following process definition:

image::images/bpmn.why.exclusive.jobs.png[align="center"]

We have a parallel gateway followed by three service tasks which all perform an asynchronous continuation. As a result of this, three jobs are added to the database. Once such a job is present in the database it can be processes by the JobExecutor. The JobExecutor acquires the jobs and delegates them to a thread pool of worker threads which actually process the jobs. This means that using an asynchronous continuation, you can distribute the work to this thread pool (and in a clustered scenario even across multiple thread pools in the cluster). This is usually a good thing. However it also bears an inherent problem: consistency. Consider the parallel join after the service tasks. When execution of a service tasks is completed, we arrive at the parallel join and need to decide whether to wait for the other executions or whether we can move forward. That means, for each branch arriving at the parallel join, we need to take a decision whether we can continue or whether we need to wait for one or more other executions on the other branches.

Why is this a problem? Since the service tasks are configured using an asynchronous continuation, it is possible that the corresponding jobs are all acquired at the same time and delegated to different worker threads by the JobExecutor. The consequence is that the transactions in which the services are executed and in which the 3 individual executions arrive at the parallel join can overlap. And if they do so, each individual transaction will not "see", that another transaction is arriving at the same parallel join concurrently and thus assume that it has to wait for the others. However, if each transaction assumes that it has to wait for the other ones, none will continue the process after the parallel join and the process instance will remain in that state forever.

How does Activiti address this problem? Activiti performs optimistic locking. Whenever we take a decision based on data that might not be current (because another transaction might modify it before we commit, we make sure to increment the version of the same database row in both transactions). This way, whichever transaction commits first wins and the other ones fail with an optimistic locking exception. This solves the problem in the case of the process discussed above: if multiple executions arrive at the parallel join concurrently, they all assume that they have to wait, increment the version of their parent execution (the process instance) and then try to commit. Whichever execution is first will be able to commit and the other ones will fail with an optimistic locking exception. Since the executions are triggered by a job, Activiti will retry to perform the same job after waiting for a certain amount of time and hopefully this time pass the synchronizing gateway.


Is this a good solution? As we have seen, optimistic locking allows Activiti to prevent inconsistencies. It makes sure that we do not "keep stuck at the joining gateway", meaning: either all executions have passed the gateway or, there are jobs in the database making sure that we retry passing it. However, while this is a perfectly fine solution from the point of view of persistence and consistency, this might not always be desirable behavior at an higher level:

* Activiti will retry the same job for a fixed maximum number of times only ('3' in the default configuration). After that, the job will still be present in the database but not be retried actively anymore. That means that an operator would need to trigger the job manually.
* If a job has non-transactional side effects, those will not be rolled back by the failing transaction. For instance, if the "book concert tickets" service does not share the same transaction as Activiti, we might book multiple tickets if we retry the job.


===== What are exclusive jobs?

An exclusive job cannot be performed at the same time as another exclusive job from the same process instance. Consider the process shown above: if we declare the service tasks to be exclusive, the JobExecutor will make sure that the corresponding jobs are not executed concurrently. Instead, it will make sure that whenever it acquires an exclusive job from a certain process instance, it acquires all other exclusive jobs from the same process instance and delegates them to the same worker thread. This ensures sequential execution execution of the jobs.

How can I enable this feature? Since Activiti 5.9, exclusive jobs are the default configuration. All asynchronous continuations and timer events are thus exclusive by default. In addition, if you want a job to be non-exclusive, you can configure it as such using +activiti:exclusive="false"+. For example, the following servicetask would be asynchronous but non-exclusive.

[source,xml,linenums]
----
<serviceTask id="service" activiti:expression="${myService.performBooking(hotel, dates)}" activiti:async="true" activiti:exclusive="false" />
----


Is this a good solution? We had some people asking whether this was a good solution. Their concern was that this would to prevent you from "doing things" in parallel and would thus be a performance problem. Again, two things have to be taken into consideration:

* It can be turned off if you are an expert and know what you are doing (and have understood the section named "Why exclusive Jobs?"). Other than that, it is more intuitive for most users if things like asynchronous continuations and timers just work.
* It is actually not a performance issue. Performance is an issue under heavy load. Heavy load means that all worker threads of the job executor are busy all the time. With exclusive jobs, Activiti will simply distribute the load differently. Exclusive jobs means that jobs from a single process instance are performed by the same thread sequentially. But consider: you have more than one single process instance. And jobs from other process instances are delegated to other threads and executed concurrently. This means that with exclusive jobs Activiti will not execute jobs from the same process instance concurrently, but it will still execute multiple instances concurrently. From an overall throughput perspective this is desirable in most scenarios as it usually leads to individual instances being done more quickly. Furthermore, data that is required for executing subsequent jobs of the same process instance will already be in the cache of the executing cluster node. If the jobs do not have this node affinity, that data might need to be fetched from the database again.


[[security]]


=== Process Initiation Authorization

By default everyone is allowed to start a new process instance of deployed process definitions. The process initiation authorization functionality allows to define users and groups so that web clients can optionally restrict users to start a new process instance. NOTE that the authorization definition is NOT validated by the Activiti Engine in any way. This functionality is only meant for developers to ease the implementation of authorization rules in a web client. The syntax is similar to the syntax of user assignment for a user task. A user or group can be assigned as potential initiator of a process using <activiti:potentialStarter> tag. Here is an example:

[source,xml,linenums]
----
<process id="potentialStarter">
  <extensionElements>
    <activiti:potentialStarter>
       <resourceAssignmentExpression>
         <formalExpression>group2, group(group3), user(user3)</formalExpression>
       </resourceAssignmentExpression>
    </activiti:potentialStarter>
  </extensionElements>

  <startEvent id="theStart"/>
  ...
----

In the above xml excerpt user(user3) refers directly to user user3 and group(group3) to group group3. No indicator will default to a group type. It is also possible to use attributes of the <process> tag, namely <activiti:candidateStarterUsers> and <activiti:candidateStarterGroups>. Here is an example:

[source,xml,linenums]
----
<process id="potentialStarter" activiti:candidateStarterUsers="user1, user2"
                               activiti:candidateStarterGroups="group1">
      ...
----


It is possible to use both attributes simultaneously.


After the process initiation authorizations are defined, a developer can retrieve the authorization definition using the following methods.
This code retrieves the list of process definitions which can be initiated by the given user:

[source,java,linenums]
----
processDefinitions = repositoryService.createProcessDefinitionQuery().startableByUser("userxxx").list();
----

It's also possible to retrieve all identity links that are defined as potential starter for a specific process definition

[source,java,linenums]
----
identityLinks = repositoryService.getIdentityLinksForProcessDefinition("processDefinitionId");
----

The following example shows how to get list of users who can initiate the given process:

[source,java,linenums]
----
List<User> authorizedUsers =  identityService().createUserQuery().potentialStarter("processDefinitionId").list();
----


Exactly the same way, the list of groups that is configured as a potential starter to a given process definition can be retrieved:

[source,java,linenums]
----
List<Group> authorizedGroups =  identityService().createGroupQuery().potentialStarter("processDefinitionId").list();
----


[[dataobjects]]


=== Data objects

<<experimental,[EXPERIMENTAL]>>

BPMN provides the possibility to define data objects as part of a process or sub process element. According to the BPMN specification it's possible to include complex XML structures that might be imported from XSD definitions. As a first start to support data objects in Activiti the following XSD types are supported:

[source,xml,linenums]
----
<dataObject id="dObj1" name="StringTest" itemSubjectRef="xsd:string"/>
<dataObject id="dObj2" name="BooleanTest" itemSubjectRef="xsd:boolean"/>
<dataObject id="dObj3" name="DateTest" itemSubjectRef="xsd:datetime"/>
<dataObject id="dObj4" name="DoubleTest" itemSubjectRef="xsd:double"/>
<dataObject id="dObj5" name="IntegerTest" itemSubjectRef="xsd:int"/>
<dataObject id="dObj6" name="LongTest" itemSubjectRef="xsd:long"/>
----

The data object definitions will be automatically converted to process variables using the 'name' attribute value as the name for the new variable. In addition to the definition of the data object Activiti also provides an extension element to assign a default value to the variable. The following BPMN snippet provides an example:

[source,xml,linenums]
----
<process id="dataObjectScope" name="Data Object Scope" isExecutable="true">
  <dataObject id="dObj123" name="StringTest123" itemSubjectRef="xsd:string">
    <extensionElements>
      <activiti:value>Testing123</activiti:value>
    </extensionElements>
  </dataObject>
  ...
----
