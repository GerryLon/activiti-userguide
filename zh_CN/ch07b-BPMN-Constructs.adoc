[[bpmnConstructs]]

== BPMN 2.0 结构 BPMN 2.0 Constructs

本章节包含了Activiti支持的BPMN 2.0结构，以及对BPMN标准的自定义扩展。

[[bpmnCustomExtensions]]


=== 自定义扩展 Custom extensions


BPMN 2.0标准对流程的所有的参与者都是个好东西。最终用户不需要因为依赖专利解决方案，而被供应商“绑架”。Activiti之类的开源框架，也可以提供与大型供应商的解决方案相同（经常是更好;-）的实现。有了BPMN 2.0标准，从大型供应商解决方案向Activiti的转变，就变得简单平滑。

然而标准的缺点，是它通常是不同公司（不同观点）大量讨论与妥协的结果。作为阅读BPMN 2.0 XML流程定义的开发者，有时会觉得某些结构或做事方法太笨重了。Activiti将开发者的感受放在最高优先，因此引入了一些**'Activiti BPMN extensions（扩展）'**。这些“扩展”并不在BPMN 2.0规格中，有些是新结构，有些是对特定结构的简化。

尽管BPMN 2.0规格明确指出可以支持自定义扩展，我们仍做了如下保证：

* 自定义扩展的前提是，**做事情的标准方式****总**可以进行更简化的改造。因此当你决定使用自定义扩展时，不用担心无路可退（仍然可以用标准方式）。
* 使用自定义扩展时，总是通过为新的XML元素、属性等提供**activiti:**命名空间前缀，明确标识出来。

因此是否使用自定义扩展，完全取决于你自己。有些其他因素会影响选择（图形化编辑器的使用，公司策略，等等）。我们提供扩展，只是因为相信，标准中的某些地方可以用更简单或效率更高的方式处理。请不要吝啬给我们反馈对扩展的评价（正面的和/或负面的），也可以给我们提供关于自定义扩展的新想法。说不定某一天，你的想法会成为规范的一部分！


[[bpmnEvents]]

=== 事件 Events

事件通常用于为流程生命周期中发生的事情建模。事件总是图形化为圆圈。在BPMN 2.0中，有两种主要的事件分类：__捕获（catching）__与__抛出（throwing）__事件。

* **捕获:** 当流程执行到达这个事件时，会等待直到触发器动作。触发器的类型，由其中的图标，或者说XML中的类型声明而定义。捕获事件与抛出事件显示上的区别，是其内部的图标没有填充（也就是说，是白色的）。
* **抛出:** 当流程执行到达这个事件时，会触发一个触发器。触发器的类型，由其中的图标，或者说XML中的类型声明而定义。抛出事件与捕获事件显示上的区别，是其内部的图标填充为黑色。

[[eventDefinitions]]


==== 事件定义 Event Definitions

事件定义，定义了事件的语义。没有事件定义的话，事件就“不做什么特别的事情”。例如一个没有事件定义的开始事件，并不限定具体是什么启动了流程。如果为这个开始事件添加事件定义（例如定时器事件定义），就声明了启动流程的“类型”（例如对于定时器事件定义，就是到达了特定的时间点）。


[[timerEventDefinitions]]


==== 定时器事件定义 Timer Event Definitions

定时器事件，是由定义的定时器触发的事件。可以用于<<bpmnTimerStartEvent,开始事件 start event>>，<<bpmnIntermediateCatchingEvent,中间事件 intermediate event>>，或<<bpmnTimerBoundaryEvent,边界事件 boundary event>>。定时器事件的行为，取决于所使用的业务日历（business calendar）。定时器事件有默认的业务日历，但也可以为每个定时器事件定义，定义业务日历。

[source,xml,linenums]
----
<timerEventDefinition activiti:businessCalendarName="custom">
    ...
</timerEventDefinition>
----
其中businessCalendarName指向流程引擎配置中的业务日历。如果省略业务日历定义，就使用默认业务日历。

定时器定义必须且只能使用下列的一种元素：

* **timeDate**。这个方式指定了link:$$http://en.wikipedia.org/wiki/ISO_8601#Dates$$[ISO 8601]格式的固定时间。
在这个时间点，会触发触发器。例如：


[source,xml,linenums]
----
<timerEventDefinition>
    <timeDate>2011-03-11T12:13:14</timeDate>
</timerEventDefinition>
----


* **timeDuration**。要定义在触发前，定时器需要等待多长时间，可以用__timeDuration__作为__timerEventDefinition__的子元素来指定。使用link:$$http://en.wikipedia.org/wiki/ISO_8601#Durations$$[ISO 8601]格式（BPMN 2.0规范要求）。例如（等待10天）：

[source,xml,linenums]
----
<timerEventDefinition>
    <timeDuration>P10D</timeDuration>
</timerEventDefinition>
----

* **timeCycle**。指定重复周期，可用于周期性启动流程，或者为超期用户任务多次发送提醒。这个元素可以使用两种格式。第一种是按照link:$$http://en.wikipedia.org/wiki/ISO_8601#Repeating_intervals$$[ISO 8601]标准定义的循环时间周期。例如（三次重复间隔，每次间隔为10小时）：

[source,xml,linenums]
----
<timerEventDefinition>
    <timeCycle activiti:endDate="2015-02-25T16:42:11+00:00">R3/PT10H</timeCycle>
</timerEventDefinition>
----

也可以指定__endDate__，作为__timeCycle__的可选属性，或者像这样直接写在时间表达式的结尾：++R3/PT10H/${EndDate}++。
当到达endDate时，应用会停止，并为该任务创建其他作业。
可以使用link:$$http://en.wikipedia.org/wiki/ISO_8601#Dates$$[ISO 8601]标准的静态值，比如__"2015-02-25T16:42:11+00:00"__。也可以使用变量__${EndDate}__

[source,xml,linenums]
----
<timerEventDefinition>
    <timeCycle>R3/PT10H/${EndDate}</timeCycle>
</timerEventDefinition>
----

如果同时使用了两种指定方式，则系统会使用属性方式定义的endDate。

目前只有__BoundaryTimerEvents__与__CatchTimerEvent__支持__EndDate__功能。

另外，也可以使用cron表达式指定定时周期。下面的例子展示了一个整点启动，每5分钟触发的触发器：


----
0 0/5 * * * ?
----


请参考link:$$http://www.quartz-scheduler.org/docs/tutorials/crontrigger.html$$[这个教程]了解如何使用cron表达式。

**请注意:** 与普通的Unix cron不同，第一个符号代表的是秒。

重复时间周期更适用于使用相对时间，也就是从某个特定时间点开始计算（比如用户任务开始的时间）。而cron表达式可以使用绝对时间，因此绝对适合用于<<timerStartEventDescription,定时启动事件 timer start events>>。


可以在定时事件定义中使用表达式，也就是使用流程变量调整定时器定义。这个流程变量必须是包含合适时间格式的字符串，ISO 8601（或者对于循环类型，cron）。

[source,xml,linenums]
----
<boundaryEvent id="escalationTimer" cancelActivity="true" attachedToRef="firstLineSupport">
  <timerEventDefinition>
    <timeDuration>${duration}</timeDuration>
  </timerEventDefinition>
</boundaryEvent>
----

**请注意：**定时器只有在作业或者异步执行器启用时才能触发（也就是说，需要在++activiti.cfg.xml++中，将__jobExecutorActivate__或者__asyncExecutorActivate__设置为++true++。因为默认情况下，作业与异步执行器都是禁用的）。

[[bpmnErrorEventDefinition]]


==== 错误事件定义 Error Event Definitions

**重要提示：** BPMN错误与Java异常**不**是一回事。事实上，这两者毫无共同点。BPMN错误事件是建模__业务异常（business exceptions）__的方式。而Java异常使用<<serviceTaskExceptionHandling,它们自己的方式>>处理。

[source,xml,linenums]
----
<endEvent id="myErrorEndEvent">
  <errorEventDefinition errorRef="myError" />
</endEvent>

----

[[bpmnSignalEventDefinition]]


==== 信号事件定义 Signal Event Definitions


信号事件，是引用具名信号的事件。信号是全局范围（广播）的事件，并会被传递给所有激活的处理器（等待中的流程实例/捕获信号事件 catching signal events）。


信号事件定义使用++signalEventDefinition++元素声明。其++signalRef++属性引用一个++signal++元素，该++signal++元素需要声明为++definitions++根元素的子元素。下面摘录一个流程，使用中间事件（intermediate event）抛出与捕获信号事件。

[source,xml,linenums]
----
<definitions... >
	<!-- 声明信号 -->
	<signal id="alertSignal" name="alert" />

	<process id="catchSignal">
		<intermediateThrowEvent id="throwSignalEvent" name="Alert">
			<!-- 信号事件定义 -->
			<signalEventDefinition signalRef="alertSignal" />
		</intermediateThrowEvent>
		...
		<intermediateCatchEvent id="catchSignalEvent" name="On Alert">
			<!-- 信号事件定义 -->
			<signalEventDefinition signalRef="alertSignal" />
		</intermediateCatchEvent>
		...
	</process>
</definitions>
----


两个++signalEventDefinition++引用同一个++signal++元素。


[[bpmnSignalEventDefinitionThrow]]


===== 抛出信号事件 Throwing a Signal Event

信号可以由流程实例使用BPMN结构抛出，也可以通过编程方式使用Java API抛出。下面++org.activiti.engine.RuntimeService++中的方法可以用于编程方式抛出信号：

[source,java,linenums]
----
RuntimeService.signalEventReceived(String signalName);
RuntimeService.signalEventReceived(String signalName, String executionId);
----

++signalEventReceived(String signalName);++与++signalEventReceived(String signalName, String executionId);++的区别，是前者在全局范围，为所有已订阅处理器抛出信号（广播），而后者只为指定的执行传递信号。


[[bpmnSignalEventDefinitionCatch]]


===== 捕获信号事件 Catching a Signal Event


信号事件可用信号捕获中间事件（intermediate catch signal event）或者信号边界事件（signal boundary event）捕获。


[[bpmnSignalEventDefinitionQuery]]


===== 查询信号事件订阅 Querying for Signal Event subscriptions


可以查询订阅了某一信号事件的所有执行：

[source,java,linenums]
----
 List<Execution> executions = runtimeService.createExecutionQuery()
      .signalEventSubscriptionName("alert")
      .list();
----

可以使用++signalEventReceived(String signalName, String executionId)++方法为这些执行传递这个信号。


[[bpmnSignalEventDefinitionScope]]


===== 信号事件范围 Signal event scope

默认情况下，信号事件在__流程引擎全局广播__。这意味着你可以在一个流程实例中抛出一个信号事件，而不同流程定义的不同流程实例都会响应这个事件。

然而，有时也会希望只在__同一个流程实例__中响应信号事件。例如在流程实例中使用异步机制，而两个或多个活动彼此互斥的时候。

要限制信号事件的__范围（scope）__，在信号事件定义中添加（非BPMN 2.0标准！）__scope属性__：

[source,xml,linenums]
----
<signal id="alertSignal" name="alert" activiti:scope="processInstance"/>
----

这个属性的默认值为__"global（全局）"__。


[[bpmnSignalEventDefinitionExample]]


===== 信号事件示例 Signal Event example(s)

下面是一个关于两个不同的流程通过信号通信的例子。第一个流程在保险政策更新或变更时启动。在变更由人工审核之后，会抛出信号事件，指出政策已经发生了变更：

image::images/bpmn.signal.event.throw.png[align="center"]

这个事件可以被所有感兴趣的流程实例捕获。下面是一个订阅这个事件的流程的例子。

image::images/bpmn.signal.event.catch.png[align="center"]

**请注意：**要理解信号事件会广播给**所有**激活的处理器，这很重要。这意味着在上面的例子中，所有捕获这个信号的流程实例，都会接收这个信号。在这个例子中这就是我们期望的。然而，有的情况下，不希望使用广播方式。考虑下面的流程：

image::images/bpmn.signal.event.warning.1.png[align="center"]


Activiti不支持上面流程中描述的模式。理想情况是，在执行"do something"任务时抛出的错误，由错误边界事件捕获，并通过信号抛出事件传播至执行的并行分支，最终中断"do something in parallel"任务。到目前为止Activiti会按照预期效果执行。**然而，由于信号的广播效应，它也会被传播至所有其他订阅了这个信号事件的流程实例。**这可能并我们希望的效果。

**请注意：**信号事件与特定的流程实例无关，而是会广播给所有流程实例。如果你需要只为某一特定的流程实例传递信号，则需要使用++signalEventReceived(String signalName, String executionId)++手动建立关联，并使用适当的的<<bpmnSignalEventDefinitionQuery,查询机制 query mechanisms>>。


[[bpmnMessageEventDefinition]]


==== 消息事件定义 Message Event Definitions

消息事件，是指引用具名消息的事件。消息具有名字与载荷。与信号不同，消息事件只有一个接收者。

消息事件定义使用++messageEventDefinition++元素声明。其++messageRef++属性引用一个++message++元素，该++message++元素需要声明为++definitions++根元素的子元素。下面摘录一个流程，声明了两个消息事件，并由开始事件与消息捕获中间事件（intermediate catching message event）引用。

[source,xml,linenums]
----
<definitions id="definitions"
  xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL"
  xmlns:activiti="http://activiti.org/bpmn"
  targetNamespace="Examples"
  xmlns:tns="Examples">

  <message id="newInvoice" name="newInvoiceMessage" />
  <message id="payment" name="paymentMessage" />

  <process id="invoiceProcess">

    <startEvent id="messageStart" >
    	<messageEventDefinition messageRef="newInvoice" />
    </startEvent>
    ...
    <intermediateCatchEvent id="paymentEvt" >
    	<messageEventDefinition messageRef="payment" />
    </intermediateCatchEvent>
    ...
  </process>

</definitions>
----




[[bpmnMessageEventDefinitionThrow]]


===== 抛出消息事件 Throwing a Message Event


作为可嵌入的流程引擎，Activiti不关心实际接收消息。因为这可能与环境相关，并需要进行平台定义的操作，例如连接至JMS（Java Messaging Service，Java消息服务）队列（Queue）/主题（Topic），或者处理Webservice或者REST请求。因此接收消息需要作为应用的一部分，或者是流程引擎所嵌入的基础框架中的一部分，由你自行实现。

在应用中接收到消息后，需要决定如何处理它。如果这个消息需要启动新的流程实例，可以选择下面由runtime服务提供的方法中的一种：

[source,java,linenums]
----
ProcessInstance startProcessInstanceByMessage(String messageName);
ProcessInstance startProcessInstanceByMessage(String messageName, Map<String, Object> processVariables);
ProcessInstance startProcessInstanceByMessage(String messageName, String businessKey, Map<String, Object> processVariables);
----

这些方法可以使用引用的消息启动流程实例。

如果需要由已有的流程实例接收消息，需要首先将消息与特定的流程实例关联（查看后续章节），然后触发等待中的执行，让其继续。runtime服务提供了下列方法，根据消息事件的订阅，触发执行：

[source,java,linenums]
----
void messageEventReceived(String messageName, String executionId);
void messageEventReceived(String messageName, String executionId, HashMap<String, Object> processVariables);
----


[[bpmnMessageEventDefinitionQuery]]


===== 查询消息事件订阅 Querying for Message Event subscriptions


* 对于消息启动事件，消息事件的订阅与特定的__流程定义__相关。这种类型的消息订阅，可以使用++ProcessDefinitionQuery++查询：

[source,java,linenums]
----
ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery()
      .messageEventSubscription("newCallCenterBooking")
      .singleResult();
----

因为对于一个消息，只能有一个流程定义订阅，因此这个查询总是返回0或1个结果。如果流程定义更新了，只有该流程定义的最新版本会订阅这个消息事件。

* 对于消息捕获中间事件（intermediate catch message event），消息事件的订阅与特定的__执行__相关。这种类型的消息订阅，可以使用++ExecutionQuery++查询：

[source,java,linenums]
----
Execution execution = runtimeService.createExecutionQuery()
      .messageEventSubscriptionName("paymentReceived")
      .variableValueEquals("orderId", message.getOrderId())
      .singleResult();
----

这种查询通常有关联查询，并且通常需要了解流程（在这个例子里，对于给定的orderId，至多只有一个流程实例）。


[[bpmnMessageEventDefinitionExample]]


===== 消息事件示例 Message Event example(s)


下面是一个流程的例子，可以使用两种不同的消息启动：

image::images/bpmn.start.message.event.example.1.png[align="center"]

在流程需要通过不同的方式响应不同的启动事件，但是后续使用统一的方式处理时，这就很有用。


[[bpmnStartEvents]]


==== 启动事件 Start Events


启动事件指明了流程的起点。启动事件的类型（流程在消息到达时启动，在指定的时间间隔后启动，等等），定义了流程__如何__启动，并显示为启动事件中的小图标。在XML中，类型由子元素声明来定义。

启动事件“随时捕获”：概念上，事件（随时）等候，直到特定的触发器被触发。

在启动事件中，可以使用下列Activiti专用参数：

* *initiator*: 指明保存认证用户（authenticated user）id用的变量名。在流程启动时，该id会使用这个变量名被保存。例如：

[source,xml,linenums]
----
<startEvent id="request" activiti:initiator="initiator" />
----

认证用户必须通过++IdentityService.setAuthenticatedUserId(String)++方法，在try-finally块中设置，像这样：

[source,java,linenums]
----
try {
  identityService.setAuthenticatedUserId("bono");
  runtimeService.startProcessInstanceByKey("someProcessKey");
} finally {
  identityService.setAuthenticatedUserId(null);
}

----

这段代码在集成在Activiti Explorer应用中。因此可以与<<forms,表单>>一起使用。


[[bpmnNoneStartEvent]]


==== 空启动事件 None Start Event

[[noneStartEventDescription]]


===== 描述 Description

“空”启动事件，技术上指的是没有特别指定启动流程实例的触发器。这意味着引擎无法预知何时启动流程实例。空启动事件用于流程实例通过调用下列__startProcessInstanceByXXX__ API方法启动的情况。

[source,java,linenums]
----
ProcessInstance processInstance = runtimeService.startProcessInstanceByXXX();
----

__请注意：__子流程（subprocess）总是有空启动事件。


[[noneStartEventGraphicalNotation]]


===== 图示 Graphical notation

空启动事件用空心圆圈表示，中间没有图标（也就是说没有触发器）。

image::images/bpmn.none.start.event.png[align="center"]



[[noneStartEventXml]]


===== XML表示 XML representation


空启动事件的XML表示格式，就是普通的启动事件声明，而没有任何子元素（其他种类的启动事件都有子元素，用于声明其类型）。

[source,xml,linenums]
----
<startEvent id="start" name="my start event" />
----




[[noneStartEventCustomExtension]]


===== 空启动事件的自定义扩展 Custom extensions for the none start event

*formKey*: 引用表单模板，用户需要在启动新流程实例时填写该表单。可以在<<forms,表单章节>>找到更多信息。例如：

[source,xml,linenums]
----
<startEvent id="request" activiti:formKey="org/activiti/examples/taskforms/request.form" />
----


[[bpmnTimerStartEvent]]


==== 定时器启动事件 Timer Start Event

[[timerStartEventDescription]]


===== 描述 Description

定时器启动事件，用于在指定时间创建流程实例。在流程只需要启动一次，或者流程需要在特定的时间间隔重复启动时，都可以使用。

__请注意：__子流程不能有定时器启动事件。

__请注意：__定时器启动事件，在流程部署的同时就开始计时。不需要调用startProcessInstanceByXXX，尽管也不禁止使用启动流程的方法。调用startProcessInstanceByXXX时也会启动流程。

__请注意：__当部署带有定时器启动事件的流程的新版本时，上一版本的定时器作业会被移除。这是因为通常并不希望旧版本的流程仍然自动启动新的流程实例。


[[timerStartEventGraphicalNotation]]


===== 图示 Graphical notation

定时器启动事件，用其中有一个钟表图标的圆圈来表示。

image::images/bpmn.clock.start.event.png[align="center"]


[[timerStartEventXml]]


===== XML表示 XML representation


定时器启动事件的XML表示格式，是普通的启动事件声明，加上定时器定义子元素。请参考<<timerEventDefinitions,定时器定义>>了解详细配置方法。


示例：流程会启动4次，间隔5分钟，从2011年3月11日，12:13开始

[source,xml,linenums]
----
<startEvent id="theStart">
  <timerEventDefinition>
    <timeCycle>R4/2011-03-11T12:13/PT5M</timeCycle>
</timerEventDefinition>
</startEvent>
----

示例：流程会在选定的时间启动一次

[source,xml,linenums]
----
<startEvent id="theStart">
  <timerEventDefinition>
    <timeDate>2011-03-11T12:13:14</timeDate>
  </timerEventDefinition>
</startEvent>
----


[[bpmnMessageStartEvent]]


==== 消息启动事件 Message Start Event

[[messageStartEventDescription]]


===== 描述 Description


<<bpmnMessageEventDefinition,消息>>启动事件，使用具名消息启动流程实例。它让我们可以使用消息名，有效地在一组可选的启动事件中__选择__正确的启动事件。

当**部署**具有一个或多个消息启动事件的流程定义时，会考虑下列因素：

* 消息启动事件的名字，在给定流程定义中，必须是唯一的。一个流程定义不得包含多个同名的消息启动事件。如果流程定义中有两个或多个消息启动事件引用同一个消息，也即两个或多个消息启动事件引用了具有相同消息名字的消息，则Activiti在部署这个流程定义时，会抛出异常。
* 消息启动事件的名字，在所有已部署的流程定义中，必须是唯一的。如果流程定义中，一个或多个消息启动事件，引用了已经部署的另一流程定义中消息启动事件的消息名，则Activiti在部署这个流程定义时，会抛出异常。
* 流程版本：在部署流程定义的新版本时，会取消上一版本的消息订阅。即使新版本中并没有这个消息事件，仍然如此（取消上版本的消息订阅）。

当**启动**流程实例时，可以使用下列++RuntimeService++中的方法，触发消息启动事件：

[source,java,linenums]
----
ProcessInstance startProcessInstanceByMessage(String messageName);
ProcessInstance startProcessInstanceByMessage(String messageName, Map<String, Object> processVariables);
ProcessInstance startProcessInstanceByMessage(String messageName, String businessKey, Map<String, Object< processVariables);
----


++messageName++是由++message++元素的++name++属性决定的名字。++message++元素被++messageEventDefinition++的++messageRef++属性引用。当**启动**流程实例时，请考虑下列因素：

* 只有顶层流程（top-level process）才支持消息启动事件。嵌入式子流程不支持消息启动事件。
* 如果一个流程定义中有多个消息启动事件，++runtimeService.startProcessInstanceByMessage(...)++允许选择合适的启动事件。
* 如果一个流程定义中有多个消息启动事件，与一个空启动事件，则++runtimeService.startProcessInstanceByKey(...)++与++runtimeService.startProcessInstanceById(...)++会使用空启动事件启动流程实例。
* 如果一个流程定义中有多个消息启动事件，而没有空启动事件，则++runtimeService.startProcessInstanceByKey(...)++与++runtimeService.startProcessInstanceById(...)++会抛出异常。
* 如果一个流程定义中只有一个消息启动事件，则++runtimeService.startProcessInstanceByKey(...)++与++runtimeService.startProcessInstanceById(...)++会使用这个消息启动事件启动新流程实例。
* 如果流程由调用活动（call activity）启动，则消息启动事件只有在下列情况下才被支持
** 除了消息启动事件，流程还有唯一的空启动事件
** 或者流程只有唯一的消息启动事件，而没有其他启动事件。


[[messageStartEventGraphicalNotation]]


===== 图示 Graphical notation


消息启动事件，用其中有一个消息事件标志的圆圈表示。这个标志并未填充，用以表示捕获（接收）行为。

image::images/bpmn.start.message.event.png[align="center"]



[[messageStartEventXml]]


===== XML表示 XML representation


消息启动事件的XML表示格式，为普通启动事件声明，加上messageEventDefinition子元素：

[source,xml,linenums]
----
<definitions id="definitions"
  xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL"
  xmlns:activiti="http://activiti.org/bpmn"
  targetNamespace="Examples"
  xmlns:tns="Examples">

  <message id="newInvoice" name="newInvoiceMessage" />

  <process id="invoiceProcess">

    <startEvent id="messageStart" >
    	<messageEventDefinition messageRef="tns:newInvoice" />
    </startEvent>
    ...
  </process>

</definitions>
----





[[bpmnSignalStartEvent]]


==== 信号启动事件 Signal Start Event

[[bpmnSignalStartEventDescription]]


===== 描述 Description

<<bpmnSignalEventDefinition,信号>>启动事件，使用具名信号启动流程实例。这个信号可以由流程实例中的信号抛出中间事件（intermediary signal throw event），或者API（__runtimeService.signalEventReceivedXXX__方法）触发。这些情况下，所有拥有相同名字信号启动事件的流程定义都会被启动。

请注意这些情况下，都可以选择异步还是同步启动流程实例。

需要为API传递的++signalName++，是由++signal++元素的++name++属性决定的名字。++signal++元素被++signalEventDefinition++的++signalRef++属性所引用。


[[signalStartEventGraphicalNotation]]


===== 图示 Graphical notation


信号启动事件，用其中有一个信号事件标志的圆圈表示。这个标志并未填充，用以表示捕获（接收）行为。

image::images/bpmn.start.signal.event.png[align="center"]



[[signalStartEventXml]]


===== XML表示 XML representation


信号启动事件的XML表示格式，为普通启动事件声明，加上signalEventDefinition子元素：


[source,xml,linenums]
----
<signal id="theSignal" name="The Signal" />

<process id="processWithSignalStart1">
  <startEvent id="theStart">
    <signalEventDefinition id="theSignalEventDefinition" signalRef="theSignal"  />
  </startEvent>
  <sequenceFlow id="flow1" sourceRef="theStart" targetRef="theTask" />
  <userTask id="theTask" name="Task in process A" />
  <sequenceFlow id="flow2" sourceRef="theTask" targetRef="theEnd" />
	  <endEvent id="theEnd" />
</process>
----

[[bpmnErrorStartEvent]]


==== 错误启动事件 Error Start Event

[[errorStartEventDescription]]


===== 描述 Description

<<bpmnErrorEventDefinition,错误>>启动事件，可用于触发事件子流程（Event Sub-Process）。**错误启动事件不能用于启动流程实例**。

错误启动事件总是中断。


[[errorStartEventGraphicalNotation]]


===== 图示 Graphical notation


错误启动事件，用其中有一个错误事件标志的圆圈表示。这个标志并未填充，用以表示捕获（接收）行为。

image::images/bpmn.start.error.event.png[align="center"]



[[errorStartEventXml]]


===== XML表示 XML representation

错误启动事件的XML表示格式，为普通启动事件声明，加上errorEventDefinition子元素：

[source,xml,linenums]
----
<startEvent id="messageStart" >
	<errorEventDefinition errorRef="someError" />
</startEvent>
----





[[bpmnEndEvent]]


==== 结束事件 End Events


结束事件标志着（子）流程的（分支的）结束。结束事件**总是抛出（型）事件**。这意味着当流程执行到达结束事件时，会抛出一个__结果__。结果的类型由事件内部的黑色图标描绘。在XML表示中，类型由子元素声明给出。


[[bpmnNoneEndEvent]]


==== 空结束事件 None End Event

[[noneEndEventDescription]]


===== 描述 Description

“空”结束事件，意味着当到达这个事件时，抛出的__结果__没有特别指定。因此，引擎除了结束当前执行分支之外，不会多做任何事情。


[[bpmnNoneEndEventDescription]]


===== 图示 Graphical notation

空结束事件，用其中没有图标（没有结果类型）的粗圆圈表示。

image::images/bpmn.none.end.event.png[align="center"]



[[bpmnNoneStartEventXml]]


===== XML表示 XML representation

空事件的XML表示格式，为普通结束事件声明，没有任何子元素（其它种类的结束事件都有子元素，用于声明其类型）。


[source,xml,linenums]
----
<endEvent id="end" name="my end event" />
----


[[bpmnErrorEndEvent]]


==== 错误结束事件 Error End Event

[[bpmnErrorEndEventDescription]]


===== 描述 Description

当流程执行到达**错误结束事件**时，结束执行的当前分支，并抛出错误。这个错误可以<<bpmnBoundaryErrorEvent,使用匹配的错误边界中间事件 intermediate boundary error event 捕获>>。如果找不到匹配的错误边界事件，将会抛出异常。


[[bpmnErrorEndEventGraphicalNotation]]


===== 图示 Graphical notation

错误结束事件事件，用内部有一个错误图标的标准结束事件（粗圆圈）表示。错误图标是全黑的，代表抛出的含义。

image::images/bpmn.error.end.event.png[align="center"]


[[bpmnErrorEndEventXml]]


===== XML表示 XML representation

错误结束事件，表示为结束事件，加上__errorEventDefinition__子元素：

[source,xml,linenums]
----
<endEvent id="myErrorEndEvent">
  <errorEventDefinition errorRef="myError" />
</endEvent>

----

__errorRef__属性可以引用在流程外定义的__error__元素：

[source,xml,linenums]
----
<error id="myError" errorCode="123" />
...
<process id="myProcess">
...
----

__error__的**errorCode**用于查找匹配的错误捕获边界事件。如果__errorRef__不匹配任何已定义的__error__，则该__errorRef__会用做__errorCode__的快捷方式。这个快捷方式是Activiti特有的。下面的代码片段在功能上是相同的。

[source,xml,linenums]
----
<error id="myError" errorCode="error123" />
...
<process id="myProcess">
...
  <endEvent id="myErrorEndEvent">
    <errorEventDefinition errorRef="myError" />
  </endEvent>
...
----

与下面的功能相同

[source,xml,linenums]
----
<endEvent id="myErrorEndEvent">
  <errorEventDefinition errorRef="error123" />
</endEvent>
----

请注意__errorRef__必须遵从BPMN 2.0概要（schema），且必须是合法的QName。

[[bpmnCancelEndEvent]]

==== 终止结束事件 Terminate End Event

===== 描述 Description

当到达__终止结束事件__时，当前的流程实例或子流程会被终止。概念上说，当执行到达终止结束事件时，会判断第一个__范围 scope__（流程或子流程）并终止它。请注意在BPMN 2.0中，子流程可以是嵌入式子流程，调用活动，事件子流程，或事务子流程。有一条通用规则：当存在多实例的调用过程或嵌入式子流程时，只会终止一个实例，其他的实例与流程实例不会受影响。

可以添加一个可选属性__terminateAll__。当其为__true__时，无论该终止结束事件在流程定义中的位置，也无论它是否在子流程（甚至是嵌套子流程）中，都会终止（根）流程实例。

===== 图示 Graphical notation

终止结束事件，用内部有一个全黑圆的标准结束事件（粗圆圈）表示。

image::images/bpmn.terminate.end.event.png[align="center"]


===== XML表示 XML representation

终止结束事件，表示为结束事件，加上__terminateEventDefinition__子元素。

请注意__terminateAll__属性是可选的（默认为__false__）。

[source,xml,linenums]
----
<endEvent id="myEndEvent >
  <terminateEventDefinition activiti:terminateAll="true"></terminateEventDefinition>
</endEvent>
----


==== 取消结束事件 Cancel End Event

<<experimental, [EXPERIMENTAL]>>[[bpmnCancelEndEventDescription]]


===== 描述 Description

取消结束事件，只能与bpmn事务子流程（bpmn transaction subprocess）一起使用。当到达取消结束事件时，会抛出取消事件，且必须由取消边界事件（cancel boundary event）捕获。之后这个取消边界事件将取消事务，并触发补偿（compensation）。


[[bpmnCancelEndEventGraphicalNotation]]


===== 图示 Graphical notation

取消结束事件，用内部有一个取消图标的标准结束事件（粗圆圈）表示。取消图标是全黑的，代表抛出的含义。

image::images/bpmn.cancel.end.event.png[align="center"]



[[bpmnCancelEndEventXml]]


===== XML表示 XML representation


取消结束事件，表示为结束事件，加上__cancelEventDefinition__子元素。

[source,xml,linenums]
----
<endEvent id="myCancelEndEvent">
  <cancelEventDefinition />
</endEvent>
----




[[bpmnBoundaryEvent]]


==== 边界事件 Boundary Events

边界事件是__捕获__（型）事件，依附在活动（activity）上（边界事件永远不会抛出）。这意味着当活动运行时，事件在__监听__特定类型的触发器。当事件__捕获__时，活动会被终止，并沿该事件的出口顺序流继续。

所有的边界事件都用相同的方式定义：

[source,xml,linenums]
----
<boundaryEvent id="myBoundaryEvent" attachedToRef="theActivity">
      <XXXEventDefinition/>
</boundaryEvent>
----

边界事件由下列（元素）定义：

* 唯一标识符（流程范围）
* 通过**attachedToRef**属性定义的，对该事件所依附的活动的引用。请注意边界事件，与其所依附的活动，定义在相同级别（也就是说，边界事件并不包含在活动内部）。
* 定义了边界事件的类型的，__XXXEventDefinition__形式的XML子元素（例如__TimerEventDefinition__，__ErrorEventDefinition__，等等）。查阅特定边界事件类型，以了解更多细节。



[[bpmnTimerBoundaryEvent]]


==== 定时器边界事件 Timer Boundary Event

[[timerBoundaryEventDescription]]


===== 描述 Description


定时器边界事件的行为像是跑表与闹钟。当执行到达边界事件所依附的活动时，启动定时器。当定时器触发时（例如在特定事件间隔后），活动会被中断，沿着边界事件继续执行。


[[bpmnTimerBoundaryEventGraphicalNotation]]


===== 图示 Graphical Notation

定时器边界事件，用内部有一个定时器图标的标准边界事件（圆圈）表示。

image::images/bpmn.boundary.timer.event.png[align="center"]



[[bpmnTimerBoundaryEventXml]]


===== XML表示 XML Representation


定时器边界事件与<<bpmnBoundaryEvent,一般边界事件>>一样定义。其中类型子元素为**timerEventDefinition**元素。

[source,xml,linenums]
----
<boundaryEvent id="escalationTimer" cancelActivity="true" attachedToRef="firstLineSupport">
  <timerEventDefinition>
    <timeDuration>PT4H</timeDuration>
  </timerEventDefinition>
</boundaryEvent>
----

请参考<<timerEventDefinitions,定时器事件定义>>了解定时器配置的细节。

上面的例子在图示中，圆圈画为虚线：

image::images/bpmn.non.interrupting.boundary.timer.event.png[align="center"]

其典型使用场景，是发送额外的升级邮件，但不中断正常的流程流向。

在BPMN 2.0中，中断与非中断定时器事件是不同的。默认为中断。非中断意味着最初的活动**不会**被中断，而会保留。并会创建额外的执行，用于处理事件的出口转移（outgoing transition）。在XML表示中，__cancelActivity__属性设置为false。

[source,xml,linenums]
----
<boundaryEvent id="escalationTimer" cancelActivity="false" attachedToRef="firstLineSupport"/>
----

**请注意：**定时器边界事件只有在作业或异步执行器启用时才能触发（也就是说，需要在++activiti.cfg.xml++中，将__jobExecutorActivate__或者__asyncExecutorActivate__设置为++true++。因为默认情况下，作业与异步执行器都是禁用的。）


[[bpmnKnownIssueBoundaryEvent]]


===== 边界事件的已知问题 Known issue with boundary events


所有类型的边界事件，都有一个关于并发的已知问题。不能在边界事件上附加多个出口顺序流（查看问题link:$$https://activiti.atlassian.net/browse/ACT-47$$[ACT-47]）。这个问题的解决方案，是使用一条出口顺序流，指向并行网关。

image::images/bpmn.known.issue.boundary.event.png[align="center"]



[[bpmnBoundaryErrorEvent]]


==== 错误边界事件 Error Boundary Event

[[bpmnBoundaryErrorEventDescription]]


===== 描述 Description


在活动边界上的错误__捕获__中间（事件），或简称**错误边界事件**，捕获其依附的活动范围内抛出的错误。


在<<bpmnSubProcess,嵌入式子流程>>或者<<bpmnCallActivity,调用活动>>上定义错误边界事件最有意义，因为子流程会为其中的所有活动创建范围。错误由<<bpmnErrorEndEvent,错误结束事件>>抛出。这样的错误会逐层向其上级父范围传播，直到找到一个错误边界事件的范围，该范围定义了匹配的错误事件定义。

当错误事件被捕获时，边界事件定义所在的活动会被销毁，同时销毁其中所有的当前执行（例如，并行活动，嵌套子流程，等等）。流程执行沿着边界事件的出口顺序流继续。


[[bpmnBoundaryErrorEventgraphicalNotation]]


===== 图示 Graphical notation

错误边界事件，用内部有一个错误图标的标准中间事件（两层圆圈）表示。错误图标是白色的，代表__捕获__的含义。

image::images/bpmn.boundary.error.event.png[align="center"]

[[bpmnBoundaryErrorEventXml]]


===== XML表示 Xml representation


错误边界事件与标准<<bpmnBoundaryEvent,边界事件>>一样定义：

[source,xml,linenums]
----
<boundaryEvent id="catchError" attachedToRef="mySubProcess">
  <errorEventDefinition errorRef="myError"/>
</boundaryEvent>
----

在<<bpmnBoundaryEvent,边界事件>>中，__errorRef__引用一个流程元素外定义的错误：

[source,xml,linenums]
----
<error id="myError" errorCode="123" />
...
<process id="myProcess">
...

----

**errorCode**用于匹配捕获的错误：

* 如果省略了__errorRef__，错误边界事件会捕获**所有错误事件**，无论__error__的errorCode是什么。
* 如果提供了__errorRef__，并且其引用了存在的__error__，则边界事件**只会捕获相同错误代码的错误**。
* 如果提供了__errorRef__，但BPMN 2.0文件中没有定义__error__，则**errorRef会用作errorCode**（与错误结束事件类似）。


[[bpmnBoundaryErrorEventExample]]


===== 示例 Example


下面的示例流程展示了如何使用错误结束事件。当__'Review profitability (审核盈利能力)'__用户任务完成，并指出提供的信息不足时，会抛出错误。当这个错误被子流程边界捕获时，__'Review sales lead (审核销售线索)'__子流程中的所有运行中活动都会被销毁（即使__'Review customer rating 审核客户等级'__还没有完成），并创建__'Provide additional details (提供更多信息)'__用户任务。

image::images/bpmn.boundary.error.example.png[align="center"]

这个流程作为演示配置的示例提供。可以在__org.activiti.examples.bpmn.event.error__包中找到流程XML与单元测试。


[[bpmnBoundarySignalEvent]]


==== 信号边界事件 Signal Boundary Event

[[bpmnBoundarySignalEventDescription]]


===== 描述 Description


依附在活动边界上的<<bpmnSignalEventDefinition,信号>>捕获中间（事件），或简称**信号边界事件**，捕获与其信号定义具有相同信号名的信号。

**请注意：**与其他事件例如错误边界事件不同的是，信号边界事件不只是捕获其所依附范围抛出的信号。信号边界事件为全局范围（广播）的，意味着信号可以从任何地方抛出，甚至是不同的流程实例。

**请注意：**与其他事件如错误事件不同，信号在被捕获后不会被消耗。如果有两个激活的信号边界事件，捕获相同的信号事件，则两个边界事件都会被触发，哪怕它们不在同一个流程实例里。


[[bpmnBoundarySignalEventGraphicalNotation]]


===== 图示 Graphical notation

信号边界事件，用内部有一个信号图标的标准中间事件（两层圆圈）表示。信号图标是白色的，代表__捕获__的含义。

image::images/bpmn.boundary.signal.event.png[align="center"]


[[bpmnBoundarySignalEventXml]]


===== XML表示 XML representation

信号边界事件与标准<<bpmnBoundaryEvent,边界事件>>一样定义：

[source,xml,linenums]
----
<boundaryEvent id="boundary" attachedToRef="task" cancelActivity="true">
          <signalEventDefinition signalRef="alertSignal"/>
</boundaryEvent>
----




[[bpmnBoundarySignalEventExample]]


===== 示例 Example


查看<<bpmnSignalEventDefinition,信号事件定义>>章节内容。


[[bpmnBoundaryMessageEvent]]


==== 消息边界事件 Message Boundary Event

[[bpmnBoundaryMessageEventDescription]]


===== 描述 Description

在活动边界上的<<bpmnMessageEventDefinition,消息>>__捕获__中间（事件），或简称**消息边界事件**，捕获与其消息定义具有相同消息名的消息。


[[bpmnBoundaryMessageEventGraphicalNotation]]


===== 图示 Graphical notation

消息边界事件，用内部有一个消息图标的标准中间事件（两层圆圈）表示。信号图标是白色的，代表__捕获__的含义。

image::images/bpmn.boundary.message.event.png[align="center"]

请注意消息边界事件既可以是中断型的（右手边），也可以是非中断型的（左手边）。


[[bpmnBoundaryMessageEventXml]]


===== XML表示 XML representation


消息边界事件与标准<<bpmnBoundaryEvent,边界事件>>一样定义：

[source,xml,linenums]
----
<boundaryEvent id="boundary" attachedToRef="task" cancelActivity="true">
          <messageEventDefinition messageRef="newCustomerMessage"/>
</boundaryEvent>
----




[[bpmnBoundaryMessageEventExample]]


===== 示例 Example


查看<<bpmnMessageEventDefinition,消息事件定义>>章节内容。


[[bpmnBoundaryCancelEvent]]


==== 取消边界事件 Cancel Boundary Event

<<experimental, [EXPERIMENTAL]>>[[bpmnBoundaryCancelEventDescription]]


===== 描述 Description


依附在事务子流程边界上的取消__捕获__中间（事件），或简称**取消边界事件**，在事务取消时触发。当取消边界事件触发时，首先会中断当前范围的所有活动执行。接下来，启动事务范围内所有有效的的补偿边界事件（compensation boundary event）。补偿会同步执行，也就是说在离开事务前，边界事件会等待补偿完成。当补偿完成时，使用取消边界事件的出口顺序流，离开事务子流程。


**请注意：**一个事务子流程只允许一个取消边界事件。

**请注意：**如果事务子流程中有嵌套的子流程，只有成功完成的子流程才会触发补偿。

**请注意：**如果取消边界事件放置在具有多实例特性的事务子流程上，如果一个实例触发了取消，则边界事件将取消所有实例。


[[bpmnBoundaryCancelEventGraphicalNotation]]


===== 图示 Graphical notation


取消边界事件，用内部有一个取消图标的标准中间事件（两层圆圈）表示。取消图标是白色的（未填充），代表__捕获__的含义。

image::images/bpmn.boundary.cancel.event.png[align="center"]



[[bpmnBoundarySignalEventXml]]


===== XML表示 XML representation


取消边界事件与标准<<bpmnBoundaryEvent,边界事件>>一样定义：

[source,xml,linenums]
----
<boundaryEvent id="boundary" attachedToRef="transaction" >
          <cancelEventDefinition />
</boundaryEvent>
----

因为取消边界事件总是中断型的，因此不需要++cancelActivity++属性。


[[bpmnBoundaryCompensationEvent]]


==== 补偿边界事件 Compensation Boundary Event

<<experimental, [EXPERIMENTAL]>>[[bpmnBoundaryCompensationEventDescription]]


===== 描述 Description

依附在活动边界上的补偿__捕获__中间（事件），或简称**补偿边界事件**，可以为活动附加补偿处理器。

补偿边界事件必须通过直接关联的方式，引用单个的补偿处理器。

补偿边界事件与其它边界事件的活动策略不同。其它边界事件，例如信号边界事件，当其依附的活动启动时激活；当离开该活动时，会被解除，并取消相应的事件订阅。而补偿边界事件不是这样。补偿边界事件在其依附的活动**成功完成**时激活，同时创建补偿事件的相应订阅。当补偿事件被触发，或者相应的流程实例结束时，才会移除订阅。请考虑下列因素：

* 当补偿被触发时，补偿边界事件关联的补偿处理器会被调用，次数与其依附的活动成功完成的次数相同。
* 如果补偿边界事件依附在具有多实例特性的活动上，则会为每一个实例创建补偿事件订阅。
* 如果补偿边界事件依附在位于循环内部的活动上，则每次该活动执行时，都会创建一个补偿事件订阅。
* 如果流程实例结束，则取消补偿事件的订阅。

**请注意：**嵌入式子流程不支持补偿边界事件。


[[bpmnBoundaryCompensationEventGraphicalNotation]]


===== 图示 Graphical notation


补偿边界事件，用内部有一个补偿图标的标准中间事件（两层圆圈）表示。补偿图标是白色的（未填充），代表__捕获__的含义。另外，补偿边界事件使用单向连接关联补偿处理器，如下图所示：

image::images/bpmn.boundary.compensation.event.png[align="center"]


[[bpmnBoundaryCompensationEventXml]]


===== XML表示 XML representation


补偿边界事件与标准<<bpmnBoundaryEvent,边界事件>>一样定义：

[source,xml,linenums]
----
<boundaryEvent id="compensateBookHotelEvt" attachedToRef="bookHotel" >
          <compensateEventDefinition />
</boundaryEvent>

<association associationDirection="One" id="a1"  sourceRef="compensateBookHotelEvt" targetRef="undoBookHotel" />

<serviceTask id="undoBookHotel" isForCompensation="true" activiti:class="..." />
----

补偿边界事件在活动完成后才激活，因此不支持++cancelActivity++属性。


[[bpmnIntermediateCatchingEvent]]


==== 捕获中间事件 Intermediate Catching Events

所有的捕获中间事件都使用相同方式定义：

[source,xml,linenums]
----
<intermediateCatchEvent id="myIntermediateCatchEvent" >
      <XXXEventDefinition/>
</intermediateCatchEvent>
----

捕获中间事件由下列（元素）定义

* 唯一标识符（流程范围）
* 定义了捕获中间事件类型的，__XXXEventDefinition__形式的XML子元素（例如__TimerEventDefinition__等）。查阅特定中间捕获事件类型，以了解更多细节。


[[bpmnTimerIntermediateEvent]]


==== 定时器捕获中间事件 Timer Intermediate Catching Event

[[bpmnTimerIntermediateEventDescription]]


===== 描述 Description

定时器捕获中间事件的行为像是跑表。当执行到达捕获事件活动（catching event activity）时，启动定时器；当定时器触发时（例如在一段时间间隔后），沿定时器中间事件的出口顺序流继续执行。


[[bpmnTimerIntermediateEventGraphicalNotation]]


===== 图示 Graphical Notation


定时器中间事件，用内部有定时器图标的中间捕获事件表示。

image::images/bpmn.intermediate.timer.event.png[align="center"]

[[bpmnTimerIntermediateEventXml]]


===== XML表示 XML Representation

定时器中间事件与<<bpmnIntermediateCatchingEvent,捕获中间事件>>一样定义。指定类型的子元素为**timerEventDefinition**元素。

[source,xml,linenums]
----
<intermediateCatchEvent id="timer">
  <timerEventDefinition>
    <timeDuration>PT5M</timeDuration>
  </timerEventDefinition>
</intermediateCatchEvent>
----

查看<<timerEventDefinitions,定时器事件定义>>了解详细配置。


[[bpmnIntermediateSignalEvent]]


==== 信号捕获中间事件 Signal Intermediate Catching Event

[[bpmnIntermediateSignalEventDescription]]


===== 描述 Description

<<bpmnSignalEventDefinition,信号>>__捕获__中间事件，捕获与其引用的信号定义具有相同信号名称的信号。

**请注意：**与其他事件如错误事件不同，信号在被捕获后不会被消耗。如果有两个激活的信号中间事件，捕获相同的信号事件，则两个中间事件都会被触发，哪怕它们不在同一个流程实例里。


[[bpmnIntermediateSignalEventGraphicalNotation]]

===== 图示 Graphical notation

信号捕获中间事件，用内部有信号图标的标准中间事件（两层圆圈）表示。信号图标是白色的（未填充），代表__捕获__的含义。

image::images/bpmn.intermediate.signal.catch.event.png[align="center"]


[[bpmnIntermediateSignalEventXml]]

===== XML表示 XML representation

信号中间事件与<<bpmnIntermediateCatchingEvent,捕获中间事件>>一样定义。指定类型的子元素为**signalEventDefinition**元素。

[source,xml,linenums]
----
<intermediateCatchEvent id="signal">
  <signalEventDefinition signalRef="newCustomerSignal" />
</intermediateCatchEvent>
----

[[bpmnIntermediateSignalEventExample]]

===== 示例 Example


查看<<bpmnSignalEventDefinition,信号事件定义>>章节。


[[bpmnIntermediateMessageEvent]]


==== 消息捕获中间事件 Message Intermediate Catching Event

[[bpmnIntermediateMessageEventDescription]]


===== 描述 Description

<<bpmnMessageEventDefinition,消息>>__捕获__中间事件，捕获特定名字的消息。


[[bpmnIntermediateMessageEventGraphicalNotation]]


===== 图示 Graphical notation

消息捕获中间事件，用内部有消息图标的标准中间事件（两层圆圈）表示。消息图标是白色的（未填充），代表__捕获__的含义。

image::images/bpmn.intermediate.message.catch.event.png[align="center"]



[[bpmnIntermediateSignalEventXml]]


===== XML表示 XML representation

消息中间事件与<<bpmnIntermediateCatchingEvent,捕获中间事件>>一样定义。指定类型的子元素为**messageEventDefinition**元素。

[source,xml,linenums]
----
<intermediateCatchEvent id="message">
  <messageEventDefinition signalRef="newCustomerMessage" />
</intermediateCatchEvent>
----




[[bpmnIntermediateMessageEventExample]]


===== 示例 Example

查看<<bpmnMessageEventDefinition,消息事件定义>>章节。


[[bpmnIntermediateThrowEvent]]


==== 抛出中间事件 Intermediate Throwing Event

所有的抛出中间事件都使用相同方式定义：

[source,xml,linenums]
----
<intermediateThrowEvent id="myIntermediateThrowEvent" >
      <XXXEventDefinition/>
</intermediateThrowEvent>
----

抛出中间事件由下列（元素）定义

* 唯一标识符（流程范围）
* 定义了抛出中间事件类型的，__XXXEventDefinition__形式的XML子元素（例如__signalEventDefinition__等）。查阅特定中间抛出事件类型，以了解更多细节。

[[bpmnIntermediateThrowNoneEvent]]


==== 空抛出中间事件 Intermediate Throwing None Event

下面的流程图展示了空中间事件的简单例子，其用于指示流程已经到达了某种状态。

image::images/bpmn.intermediate.none.event.png[align="center"]

基本上添加一个<<executionListeners,执行监听器 execution listener>>后，空中间事件就可以成为很好的监视某些KPI（Key Performance Indicators 关键绩效指标）的钩子。

[source,xml,linenums]
----
<intermediateThrowEvent id="noneEvent">
  <extensionElements>
    <activiti:executionListener class="org.activiti.engine.test.bpmn.event.IntermediateNoneEventTest$MyExecutionListener" event="start" />
  </extensionElements>
</intermediateThrowEvent>

----


你也可以添加一些自己的代码，将部分事件发送给你的BAM（Business Activity Monitoring 业务活动监控）工具，或者DWH（Data Warehouse 数据仓库）。引擎本身不会在事件中做任何事情，只是从中穿过。


[[bpmnIntermediateThrowSignalEvent]]


==== 信号抛出中间事件 Signal Intermediate Throwing Event

[[bpmnIntermediateThrowSignalEventDescription]]


===== 描述 Description


<<bpmnSignalEventDefinition,信号>>__抛出__中间事件，抛出已定义信号的信号事件。

在Activiti中，信号会广播至所有的激活的处理器（也就是说，所有的捕获信号事件）。信号可以同步或异步地发布。

* 在默认配置中，信号**同步地**传递。这意味着抛出（信号的）流程实例会等待，直到信号传递至所有的捕获（信号的）流程实例。所有的捕获流程实例也会在与抛出流程实例相同的事务中，也就是说如果收到通知的流程实例中，有一个实例产生了技术错误（抛出异常），则所有相关的实例都会失败。
* 信号也可以**异步地**传递。这是由到达抛出信号事件时，激活的是哪一个（发送）处理器来决定的。对于每个激活的处理器，JobExecutor会为其存储并传递一个异步通知消息，asynchronous notification message（作业 Job）。


[[bpmnIntermediateThrowSignalEventGraphicalNotation]]


===== 图示 Graphical notation

消息抛出中间事件，用内部有信号图标的标准中间事件（两层圆圈）表示。信号图标是黑色的（已填充），代表__抛出__的含义。

image::images/bpmn.intermediate.signal.throw.event.png[align="center"]



[[bpmnIntermediateThrowSignalEventXml]]


===== XML表示 XML representation


信号中间事件与<<bpmnIntermediateThrowEvent,抛出中间事件>>一样定义。指定类型的子元素为**signalEventDefinition**元素。

[source,xml,linenums]
----
<intermediateThrowEvent id="signal">
  <signalEventDefinition signalRef="newCustomerSignal" />
</intermediateThrowEvent>
----

异步信号事件像这样定义：

[source,xml,linenums]
----
<intermediateThrowEvent id="signal">
  <signalEventDefinition signalRef="newCustomerSignal" activiti:async="true" />
</intermediateThrowEvent>
----




[[bpmnIntermediateSignalEventExample]]


===== 示例 Example


查看<<bpmnSignalEventDefinition,信号事件定义>>章节。


[[bpmnIntermediateThrowCompensationEvent]]


==== 补偿抛出中间事件 Compensation Intermediate Throwing Event

<<experimental, [EXPERIMENTAL]>>[[bpmnIntermediateThrowCompensationEventDescription]]


===== 描述 Description

补偿__抛出__中间事件，可用于触发补偿。


**触发补偿：**补偿既可以为设计的活动触发，也可以为补偿事件所在的范围触发。补偿由活动所关联的补偿处理器执行。

* 抛出补偿时，活动关联的补偿处理器执行的次数，与活动成功完成的次数相同。
* 如果为当前范围抛出了补偿，则当前范围中所有的活动都会被补偿，包括并行分支上的活动。
* 补偿分层触发：如果将要被补偿的活动是一个子流程，则该子流程中所有的活动都会触发补偿。如果该子流程有嵌套的活动，则会递归地抛出补偿。然而，补偿不会传播至流程的**上层**：如果子流程中触发了补偿，该补偿不会传播至子流程范围外的活动。BPMN规范指出，补偿为“与子流程在相同级别”的活动触发。
* 在Activiti中，补偿按照执行的相反顺序运行。这意味着最后完成的活动会第一个补偿，等等。
* 补偿抛出中间事件，可用于补偿已经成功完成的事务子流程。

**请注意：**如果抛出补偿的范围中有一个子流程，而该子流程包含有关联了补偿处理器的活动，则当抛出补偿时，只有当该子流程成功完成的情况，补偿才会传播至该子流程。如果子流程内嵌套的部分活动已经完成，并附加了补偿处理器，则如果包含这些活动的子流程还没有完成，这些补偿处理器不会执行。参考下面的例子：

image::images/bpmn.throw.compensation.example1.png[align="center"]

在这个流程中，有两个并行的执行。一个执行嵌入子流程，另一个执行“charge credit card（信用卡付款）”活动。假定两个执行都已开始，且第一个并行执行正等待用户完成“review bookings（检查预定）”任务。第二个执行进行了“charge credit card（信用卡付款）”活动的操作，抛出了一个错误，导致“cancel reservations（取消预订）”事件触发补偿。这时并行子流程还未完成，意味着补偿不会传播至该子流程，因此不会执行“cancel hotel reservation（取消酒店预订）”补偿处理器。而如果“cancel reservations（取消预订）”运行前，这个用户任务（因此该嵌入式子流程也）已经完成，则补偿会传播至该嵌入式子流程。

**流程变量：**当补偿嵌入式子流程时，用于执行补偿处理器的执行，可以以变量在子流程完成时所处的状态，访问子流程的局部流程变量。围了实现这一点，会为范围执行（为执行子流程所创建的执行）所关联的流程变量，进行快照。意味着：

* 子流程范围内创建的并行执行所添加的变量，补偿执行器无法访问。
* 上层的执行关联的流程变量（例如流程实例的执行关联的流程变量），不在该快照中：补偿处理器（本就）可以以其在抛出补偿时所处的状态，访问这些流程变量。
* 只会为嵌入式子流程，而不会为其他活动，进行变量快照。

**目前的限制：**

* 目前不支持++waitForCompletion="false"++。当补偿抛出中间事件触发补偿时，只有在补偿成功完成时，才会离开该事件。
* 补偿现在由并行执行来运行。该并行执行按照补偿活动完成的逆序启动。Activiti的后续版本可能会添加选项，使补偿可以按（活动完成的）顺序运行。
* 补偿不会传播至调用活动（call activity）生成的子流程。


[[bpmnIntermediateThrowCompensationEventGraphicalNotation]]


===== 图示 Graphical notation

补偿抛出中间事件，用内部有补偿图标的标准中间事件（两层圆圈）表示。补偿图标是黑色的（已填充），代表__抛出__的含义。

image::images/bpmn.intermediate.compensation.throw.event.png[align="center"]



[[bpmnIntermediateThrowSignalEventXml]]


===== Xml representation


补偿中间事件与<<bpmnIntermediateThrowEvent,抛出中间事件>>一样定义。指定类型的子元素为**compensateEventDefinition**元素。

[source,xml,linenums]
----
<intermediateThrowEvent id="throwCompensation">
	<compensateEventDefinition />
</intermediateThrowEvent>
----

另外，++activityRef++可选项可用于为指定的范围/活动触发补偿：

[source,xml,linenums]
----
<intermediateThrowEvent id="throwCompensation">
	<compensateEventDefinition activityRef="bookHotel" />
</intermediateThrowEvent>
----


[[bpmnSequenceFlow]]


=== 顺序流 Sequence Flow

[[sequenceFlowDescription]]


==== 描述 Description

顺序流是流程中两个元素间的连接器。当流程执行中，一个元素被访问后，会沿着所有的出口顺序流继续。这意味着BPMN 2.0的默认性质是并行的：两个出口顺序流，会创建两个独立的，并行的执行路径。


[[sequenceFlowGraphicalNotation]]


==== 图示 Graphical notation

顺序流，用从源元素指向目标元素的箭头表示。箭头总是指向目标元素。

image::images/bpmn.sequence.flow.png[align="center"]

[[sequenceFlowXml]]


==== XML表示 XML representation


顺序流需要有流程唯一的**id**，以及对存在的**源**与**目标**元素的引用。

[source,xml,linenums]
----
<sequenceFlow id="flow1" sourceRef="theStart" targetRef="theTask" />
----

[[bpmnConditionalSequenceFlow]]

==== 条件顺序流 Conditional sequence flow

[[condSeqFlowDescription]]

===== 描述 Description

在顺序流上可以定义条件。当离开BPMN 2.0活动时，默认行为是计算其出口顺序流上的条件。当条件计算为__true__时，选择该出口顺序流。如果该方法选择了多条顺序流，则会生成多个__执行__，流程会以并行方式继续。

**请注意：**上面的介绍对BPMN 2.0活动（与事件）有效，但不适用于网关（gateway）。不同类型的网关，会用不同的方式处理带有条件的顺序流。

[[conditionalSequenceFlowGraphicalNotation]]


===== 图示 Graphical notation

条件顺序流，用起点带有小菱形的一般顺序流表示。条件表达式挨着顺序流显示。

image::images/bpmn.conditional.sequence.flow.png[align="center"]


[[conditionalSequenceFlowXml]]


===== XML表示 XML representation

条件顺序流的XML表示格式，为含有**conditionExpression（条件表达式）**子元素的普通顺序流。请注意目前只支持__tFormalExpressions__。省略__xsi:type=""__定义会默认为唯一支持的表达式类型。

[source,xml,linenums]
----
<sequenceFlow id="flow" sourceRef="theStart" targetRef="theTask">
  <conditionExpression xsi:type="tFormalExpression">
    <![CDATA[${order.price > 100 && order.price < 250}]]>
  </conditionExpression>
</sequenceFlow>
----

目前conditionalExpressions**只能使用UEL**，详细信息可以在<<apiExpressions,表达式>>章节找到。使用的表达式需要能解析为boolean值，否则当计算条件时会抛出异常。

* 下面的例子，通过典型的JavaBean的方式，使用getter引用流程变量的数据。

[source,xml,linenums]
----
<conditionExpression xsi:type="tFormalExpression">
  <![CDATA[${order.price > 100 && order.price < 250}]]>
</conditionExpression>
----

* 这个例子调用了一个解析为boolean值的方法。

[source,xml,linenums]
----
<conditionExpression xsi:type="tFormalExpression">
  <![CDATA[${order.isStandardOrder()}]]>
</conditionExpression>
----


Activiti发行版中包含了下列示例流程，展示值表达式与方法表达式的使用（参见__org.activiti.examples.bpmn.expression__）。

image::images/bpmn.uel-expression.on.seq.flow.png[align="center"]


[[bpmnDefaultSequenceFlow]]


==== 默认顺序流 Default sequence flow

[[bpmnDefaultSequenceFlowDescription]]


===== 描述 Description


所有的BPMN 2.0任务与网关，都可以使用**默认顺序流**。这种顺序流只有当没有其他顺序流可以选择时，才会被选择为活动的出口顺序流。默认顺序流上的条件会被忽略。


[[bpmnDefaultSequenceFlowGraphicalNotation]]


===== 图示 Graphical notation

默认顺序流，用起点带有“斜线”标记的一般顺序流表示。

image::images/bpmn.default.sequence.flow.png[align="center"]


[[bpmnDefaultSequenceFlowXmlRepresentation]]


===== XML表示 XML representation

活动的默认顺序流，由该活动的**default属性**定义。下面的XML片段展示了一个排他网关（exclusive gateway），带有默认顺序流__flow 2__。只有当__conditionA__与__conditionB__都计算为false时，默认顺序流才会被选择为网关的出口顺序流。

[source,xml,linenums]
----
<exclusiveGateway id="exclusiveGw" name="Exclusive Gateway" default="flow2" />
<sequenceFlow id="flow1" sourceRef="exclusiveGw" targetRef="task1">
  <conditionExpression xsi:type="tFormalExpression">${conditionA}</conditionExpression>
</sequenceFlow>
<sequenceFlow id="flow2" sourceRef="exclusiveGw" targetRef="task2"/>
<sequenceFlow id="flow3" sourceRef="exclusiveGw" targetRef="task3">
  <conditionExpression xsi:type="tFormalExpression">${conditionB}</conditionExpression>
</sequenceFlow>
----


对应下面的图示：

（原图缺失）


[[bpmnGateways]]


=== 网关 Gateways


网关用于控制执行的流向（或者按BPMN 2.0描述的，执行的__token 标志__）。网关可以__消耗__与__生成__标志。

网关用其中带有图标的菱形表示。该图标显示了网关的类型。

image::images/bpmn.gateway.png[align="center"]


[[bpmnExclusiveGateway]]


==== 排他网关 Exclusive Gateway

[[exclusiveGatewayDescription]]


===== 描述 Description

排他网关（也叫__异或网关 XOR gateway__，或者更专业的，__基于数据的排他网关 exclusive data-based gateway__），用于为流程中的**决策**建模。当执行到达这个网关时，所有出口顺序流会按照它们定义的顺序进行计算。条件计算为true的顺序流（当没有设置条件时，认为顺序流定义为__true__）会被选择用于继续流程。

**请注意这里出口顺序流的含义与BPMN 2.0中的一般情况不一样。一般情况下，所有条件计算为true的顺序流，都会被选择继续，并行执行。而使用排他网关时，只会选择一条顺序流。当多条顺序流的条件都计算为true时，其中在XML中定义的第一条（也只有这条）会被选择，用于继续流程。如果没有可选的顺序流，会抛出异常。**


[[exclusiveGatewayGraphNotation]]


===== 图示 Graphical notation

排他网关，用内部带有'X'图标的标准网关（菱形）表示，'X'图标代表__异或（XOR）__的含义。请注意内部没有图标的网关默认为排他网关。BPMN 2.0规范不允许在同一个流程中，混合使用带有及没有X的菱形标志。

image::images/bpmn.exclusive.gateway.notation.png[align="center"]


[[exclusiveGatewayXML]]


===== XML表示 XML representation


排他网关的XML表示格式很直接：一行定义网关的XML，而条件表达式定义在出口顺序流上。查看<<bpmnConditionalSequenceFlow,条件顺序流>>章节了解这种表达式的可用选项。

以下面的模型为例：

image::images/bpmn.exclusive.gateway.png[align="center"]

用XML表示如下：

[source,xml,linenums]
----
<exclusiveGateway id="exclusiveGw" name="Exclusive Gateway" />

<sequenceFlow id="flow2" sourceRef="exclusiveGw" targetRef="theTask1">
  <conditionExpression xsi:type="tFormalExpression">${input == 1}</conditionExpression>
</sequenceFlow>

<sequenceFlow id="flow3" sourceRef="exclusiveGw" targetRef="theTask2">
  <conditionExpression xsi:type="tFormalExpression">${input == 2}</conditionExpression>
</sequenceFlow>

<sequenceFlow id="flow4" sourceRef="exclusiveGw" targetRef="theTask3">
  <conditionExpression xsi:type="tFormalExpression">${input == 3}</conditionExpression>
</sequenceFlow>
----


[[bpmnParallelGateway]]


==== 并行网关 Parallel Gateway

[[bpmnParallelGatewayDescription]]


===== 描述 Description


网关也可以用于对流程中并行的建模。在流程模型中引入并行的最简单的网关，就是**并行网关**。它可以将执行__分支（fork）__为多条路径，也可以__合并（join）__执行的多条入口路径。

并行网关的功能，基于其入口与出口顺序流：

* **分支：**所有的出口顺序流都并行执行，为每一条顺序流创建一个并行执行。
* **合并：**所有到达并行网关的并行执行，都在网关处等待，直到每一条入口顺序流都有一个执行到达。然后流程经过该合并网关继续。


请注意，如果并行网关同时具有多条入口与出口顺序流，可以**同时具有分支与合并的行为**。在这种情况下，网关首先合并所有入口顺序流，然后分裂为多条并行执行路径。

**与其他网关类型的重要区别，是并行网关不计算条件。如果连接到并行网关的顺序流上定义了条件，条件会被简单地忽略。**


[[bpmnParallelGatewayGraphicalNotation]]


===== 图示 Graphical Notation

并行网关，用内部带有'加号'图标的网关（菱形）表示，代表__与（AND）__的含义。

image::images/bpmn.parallel.gateway.png[align="center"]

[[bpmnParallelGatewayXML]]


===== XML表示 XML representation


定义并行网关需要一行XML：

[source,xml,linenums]
----
<parallelGateway id="myParallelGateway" />
----


实际行为（分支，合并或两者皆有），由连接到该并行网关的顺序流定义。

例如，上面的模型表现为下面的XML：

[source,xml,linenums]
----
<startEvent id="theStart" />
<sequenceFlow id="flow1" sourceRef="theStart" targetRef="fork" />

<parallelGateway id="fork" />
<sequenceFlow sourceRef="fork" targetRef="receivePayment" />
<sequenceFlow sourceRef="fork" targetRef="shipOrder" />

<userTask id="receivePayment" name="Receive Payment" />
<sequenceFlow sourceRef="receivePayment" targetRef="join" />

<userTask id="shipOrder" name="Ship Order" />
<sequenceFlow sourceRef="shipOrder" targetRef="join" />

<parallelGateway id="join" />
<sequenceFlow sourceRef="join" targetRef="archiveOrder" />

<userTask id="archiveOrder" name="Archive Order" />
<sequenceFlow sourceRef="archiveOrder" targetRef="theEnd" />

<endEvent id="theEnd" />
----


在上面的例子中，当流程启动后，会创建两个任务：

[source,java,linenums]
----
ProcessInstance pi = runtimeService.startProcessInstanceByKey("forkJoin");
TaskQuery query = taskService.createTaskQuery()
                         .processInstanceId(pi.getId())
                         .orderByTaskName()
                         .asc();

List<Task> tasks = query.list();
assertEquals(2, tasks.size());

Task task1 = tasks.get(0);
assertEquals("Receive Payment", task1.getName());
Task task2 = tasks.get(1);
assertEquals("Ship Order", task2.getName());
----


当这两个任务完成后，第二个并行网关会合并这两个执行，并且由于只有一条出口顺序流，不会再创建并行执行路径，只会激活__Archive Order(存档订单)__任务。

请注意并行网关不需要“平衡”（也就是说，对应的并行网关，其入口/出口顺序流的数量不需要匹配）。并行网关会简单地等待所有入口顺序流，并为每一条出口顺序流创建并行执行，不受流程模型中的其他结构影响。因此，下面的流程在BPMN 2.0中是合法的：

image::images/bpmn.unbalanced.parallel.gateway.png[align="center"]

[[bpmnInclusiveGateway]]


==== 包容网关 Inclusive Gateway

[[bpmnInclusiveGatewayDescription]]


===== 描述 Description


**包容网关**可被视作排他网关与并行网关的组合。与排他网关一样，可以在出口顺序流上定义条件，包容网关会计算它们。然而主要的区别是，包容网关与并行网关一样，可以选择多于一条（出口）顺序流。

包容网关的功能，基于其入口与出口顺序流：

* **分支：**所有出口顺序流的条件都会被计算，对于条件计算为true的顺序流，流程会并行地沿其继续，为每一条顺序流创建一个并行执行。
* **合并：**所有到达包容网关的并行执行，都会在网关处等待，直到每一条具有流程标志的入口顺序流，都有一个执行到达。这是与并行网关的重要区别。换句话说，包容网关只会等待将会被执行的入口顺序流。在合并后，流程穿过合并并行网关继续。

请注意，如果包容网关同时具有多条入口与出口顺序流，可以**同时具有分支与合并的行为**。在这种情况下，网关首先合并所有具有流程标志的入口顺序流，然后为条件计算为true的出口顺序流，分裂为多条并行执行路径。


[[bpmnInclusiveGatewayGraphicalNotation]]


===== 图示 Graphical Notation

包容网关，用内部带有'圆圈'图标的网关（菱形）表示。

image::images/bpmn.inclusive.gateway.png[align="center"]

[[bpmnInclusiveGatewayXML]]


===== XML表示 XML representation

定义包容网关需要一行XML：

[source,xml,linenums]
----
<inclusiveGateway id="myInclusiveGateway" />
----

实际行为（分支，合并或两者皆有），由连接到该包容网关的顺序流定义。

例如，上面的模型表现为下面的XML：

[source,xml,linenums]
----
<startEvent id="theStart" />
<sequenceFlow id="flow1" sourceRef="theStart" targetRef="fork" />

<inclusiveGateway id="fork" />
<sequenceFlow sourceRef="fork" targetRef="receivePayment" >
  <conditionExpression xsi:type="tFormalExpression">${paymentReceived == false}</conditionExpression>
</sequenceFlow>
<sequenceFlow sourceRef="fork" targetRef="shipOrder" >
  <conditionExpression xsi:type="tFormalExpression">${shipOrder == true}</conditionExpression>
</sequenceFlow>

<userTask id="receivePayment" name="Receive Payment" />
<sequenceFlow sourceRef="receivePayment" targetRef="join" />

<userTask id="shipOrder" name="Ship Order" />
<sequenceFlow sourceRef="shipOrder" targetRef="join" />

<inclusiveGateway id="join" />
<sequenceFlow sourceRef="join" targetRef="archiveOrder" />

<userTask id="archiveOrder" name="Archive Order" />
<sequenceFlow sourceRef="archiveOrder" targetRef="theEnd" />

<endEvent id="theEnd" />
----


在上面的例子中，当流程启动后，如果流程变量paymentReceived == false且shipOrder == true，将会创建两个任务。如果只有一个流程变量等于true，则只会创建一个任务。如果没有条件计算为true，会抛出异常，并可通过指定默出口顺序流避免。在下面的例子中，只有ship order（传递订单）一个任务会被创建：

[source,java,linenums]
----
HashMap<String, Object> variableMap = new HashMap<String, Object>();
          variableMap.put("receivedPayment", true);
          variableMap.put("shipOrder", true);
          ProcessInstance pi = runtimeService.startProcessInstanceByKey("forkJoin");
TaskQuery query = taskService.createTaskQuery()
                         .processInstanceId(pi.getId())
                         .orderByTaskName()
                         .asc();

List<Task> tasks = query.list();
assertEquals(1, tasks.size());

Task task = tasks.get(0);
assertEquals("Ship Order", task.getName());
----


当这个任务完成后，第二个包容网关会合并这两个执行，并且由于只有一条出口顺序流，不会再创建并行执行路径，只会激活__Archive Order(存档订单)__任务。


请注意包容网关不需要“平衡”（也就是说，对应的包容网关，其入口/出口顺序流的数量不需要匹配）。包容网关会简单地等待所有入口顺序流，并为每一条出口顺序流创建并行执行，不受流程模型中的其他结构影响。


[[bpmnEventbasedGateway]]


==== 基于事件的网关 Event-based Gateway

[[eventBasedGatewayDescription]]


===== 描述 Description


基于事件的网关，允许基于事件做选择。网关的每一条出口顺序流，都需要连接至一个捕获中间事件。当流程执行到达基于事件的网关时，网关类似等待状态地动作：执行被暂停。并且，为每一条出口顺序流，创建一个事件订阅。

请注意基于事件的网关，其出口顺序流与一般的顺序流不同。这些顺序流从不实际**被执行**。相反，它们允许流程引擎决定，当执行到达一个基于事件的网关时，需要订阅什么事件。基于下列约束：

* 一个基于事件的网关，必须有两条或更多的出口顺序流。
* 基于事件的网关，只能连接至++intermediateCatchEvent（捕获中间事件）++类型的元素（Activiti不支持基于事件的网关后，连接接收任务，Receive Task）。
* 连接至基于事件的网关的++intermediateCatchEvent++，必须只有一个入口顺序流。



[[eventBasedGatewayGraphNotation]]


===== 图示 Graphical notation

基于事件的网关，用内部带有特殊图标的网关（菱形）表示。

image::images/bpmn.event.based.gateway.notation.png[align="center"]

[[eventBasedGatewayXML]]


===== XML表示 XML representation


用于定义基于事件的网关的XML元素为++eventBasedGateway++。


[[eventBasedGatewayExample]]


===== 示例 Example(s)

下面的流程，是带有基于事件的网关的流程的例子。当执行到达基于事件的网关时，流程执行被暂停。并且，流程实例订阅alert信号事件，并创建一个10分钟后触发的定时器。这使得流程引擎等待10分钟，并等待信号事件。如果信号在10分钟内触发，则定时器会被取消，执行沿着信号继续。如果信号未被触发，执行会在定时器到时后继续，并取消信号订阅。

image::images/bpmn.event.based.gateway.example.png[align="center"]


[source,xml,linenums]
----
<definitions id="definitions"
	xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL"
	xmlns:activiti="http://activiti.org/bpmn"
	targetNamespace="Examples">

	<signal id="alertSignal" name="alert" />

	<process id="catchSignal">

		<startEvent id="start" />

		<sequenceFlow sourceRef="start" targetRef="gw1" />

		<eventBasedGateway id="gw1" />

		<sequenceFlow sourceRef="gw1" targetRef="signalEvent" />
		<sequenceFlow sourceRef="gw1" targetRef="timerEvent" />

		<intermediateCatchEvent id="signalEvent" name="Alert">
			<signalEventDefinition signalRef="alertSignal" />
		</intermediateCatchEvent>

		<intermediateCatchEvent id="timerEvent" name="Alert">
			<timerEventDefinition>
				<timeDuration>PT10M</timeDuration>
			</timerEventDefinition>
		</intermediateCatchEvent>

		<sequenceFlow sourceRef="timerEvent" targetRef="exGw1" />
		<sequenceFlow sourceRef="signalEvent" targetRef="task" />

		<userTask id="task" name="Handle alert"/>

		<exclusiveGateway id="exGw1" />

		<sequenceFlow sourceRef="task" targetRef="exGw1" />
		<sequenceFlow sourceRef="exGw1" targetRef="end" />

		<endEvent id="end" />
</process>
</definitions>
----




[[bpmnTask]]


=== 任务 Tasks

[[bpmnUserTask]]


==== 用户任务 User Task

[[bpmnUserTaskDescription]]


===== 描述 Description


“用户任务”用于建模需要人工执行的任务。当流程执行到达用户任务时，会为指派至该任务的用户或组的任务列表创建一个新任务。


[[bpmnUserTaskGraphicalNotation]]


===== 图示 Graphical notation

用户任务，用左上角有一个小用户图标的标准任务（圆角矩形）表示。

image::images/bpmn.user.task.png[align="center"]

[[bpmnUserTaskXml]]


===== XML表示 XML representation

用户任务在XML中如下定义。__id__是必须属性，__name__是可选属性。

[source,xml,linenums]
----
<userTask id="theTask" name="Important task" />
----

一个用户任务也可以有一个描述（description）。事实上任何BPMN 2.0元素都可以有一个描述。描述使用附加的**documentation**元素定义。

[source,xml,linenums]
----

<userTask id="theTask" name="Schedule meeting" >
  <documentation>
	  Schedule an engineering meeting for next week with the new hire.
  </documentation>
----

描述文本可以从任务中，使用标准Java方式获取：

[source,java,linenums]
----
task.getDescription()
----


[[bpmnUserTaskDueDate]]


===== 到期日期 Due Date

每个任务都有一个字段，标志该任务的到期日期。可以使用查询API，查询在给定日期前或后到期的任务。

有一个Activiti的扩展，可以在任务定义中指定表达式，以在任务创建时，设定初始到期日期。该表达式**必须解析为++java.util.Date++，++java.util.String (ISO8601格式)++，ISO8601时间长度（例如PT50M），或者++null++**。例如，可以使用在流程里前一个表单中输入的日期，或者由前一个服务任务计算出的日期。如果使用的是时间长度，则到期日期基于当前时间加上给定长度计算。例如当dueDate使用“PT30M”时，任务在从现在起30分钟后到期。

[source,xml,linenums]
----
<userTask id="theTask" name="Important task" activiti:dueDate="${dateVariable}"/>
----

任务的到期日期，也可以使用++TaskService++，或者在++TaskListener++中使用传递的++DelegateTask++修改。


[[bpmnUserTaskAssignment]]


===== 用户指派 User assignment


一个用户任务可以直接指派给一个用户。可以通过定义**humanPerformer**子元素实现。这个__humanPerformer__定义需要**resourceAssignmentExpression**来实际定义用户。目前，只支持**formalExpressions**。

[source,xml,linenums]
----
<process >

  ...

  <userTask id='theTask' name='important task' >
    <humanPerformer>
      <resourceAssignmentExpression>
        <formalExpression>kermit</formalExpression>
      </resourceAssignmentExpression>
    </humanPerformer>
  </userTask>
----

**只有一个**用户可被指定为任务的__humanPerformer__。在Activiti术语中，这个用户被称作**办理人（assignee）**。拥有办理人的任务，在其他人的任务列表中不可见，而可以在该办理人的**个人任务列表**中看到。

特定用户办理的任务，可以通过TaskService如下获取：

[source,java,linenums]
----
List<Task> tasks = taskService.createTaskQuery().taskAssignee("kermit").list();
----

任务也可以放在用户的**候选任务列表**中。在这个情况下，需要使用**potentialOwner（潜在用户）**结构。用法与__humanPerformer__结构类似。请注意需要为表达式中的每一个元素指定其为用户还是组（引擎无法自行判断）。

[source,xml,linenums]
----
<process >

  ...

  <userTask id='theTask' name='important task' >
    <potentialOwner>
      <resourceAssignmentExpression>
        <formalExpression>user(kermit), group(management)</formalExpression>
      </resourceAssignmentExpression>
    </potentialOwner>
  </userTask>
----

定义了__potential owner__结构的任务，可用如下方法获取（或类似于指派用户任务，使用__TaskQuery__查询）：

[source,java,linenums]
----
 List<Task> tasks = taskService.createTaskQuery().taskCandidateUser("kermit");
----

将获取所有kermit作为**候选用户**的任务，也就是说，表达式含有__user(kermit)__的任务，也将获取所有**指派给kermit为其成员的组**的任务（例如__group(management)__，如果kermit是这个组的成员，并且使用Activiti身份组件）。组会在运行时解析，并可通过<<apiEngine,IdentityService（身份服务）>>管理。

如果并未指定给定字符串是用户还是组，引擎默认其为组。因此下列代码与__声明了group(accountancy)__一样。

[source,xml,linenums]
----
<formalExpression>accountancy</formalExpression>
----


[[bpmnUserTaskUserAssignmentExtension]]


===== 用于任务指派的Activiti扩展 Activiti extensions for task assignment

很明显，当指派关系不复杂时，这种用户与组的指派方式十分笨重。为避免这种复杂性，可以在用户任务上使用<<bpmnCustomExtensions,自定义扩展>>。

* **assignee（办理人）属性**：这个自定义扩展用于直接将一个用户任务指派至一个给定用户。

[source,xml,linenums]
----
<userTask id="theTask" name="my task" activiti:assignee="kermit" />
----

与使用<<bpmnUserTaskAssignment,上面>>定义的**humanPerformer**结构完全相同。

* **candidateUsers（候选用户）属性**：这个自定义扩展用于为一个任务指定候选用户。

[source,xml,linenums]
----
<userTask id="theTask" name="my task" activiti:candidateUsers="kermit, gonzo" />
----

与使用<<bpmnUserTaskAssignment,上面>>定义的**potentialOwner**结构完全相同。请注意不需要像在__potential owner__中一样，使用__user(kermit)__的声明，因为这个属性只能用于用户。

* **candidateGroups（候选组）attribute**：这个自定义扩展用于为一个任务指定候选组。

[source,xml,linenums]
----
<userTask id="theTask" name="my task" activiti:candidateGroups="management, accountancy" />
----

与使用<<bpmnUserTaskAssignment,上面>>定义的**potentialOwner**结构完全相同。请注意不需要像在__potential owner__中一样，使用__group(management)__的声明，因为这个属性只能用于组。

* __candidateUsers__与__candidateGroups__可以定义在同一个用户任务上。

请注意：尽管Activiti提供了身份管理组件，通过<<apiEngine,IdentityService>>暴露，但并不会检查给定的用户是否在身份组件中存在。这样Activiti在嵌入应用时，可以与已有的身份管理解决方案集成。


[[bpmnUserTaskUserCustomIdentityLinkAssignmentExtension]]


===== 自定义身份联系类型（试验特性） Custom identity link types (Experimental)

<<experimental,[EXPERIMENTAL]>>

在<<bpmnUserTaskAssignment,用户指派>>中定义过，BPMN标准支持单个指派用户即**hunamPerformer**，或者一组用户构成**potentialOwners**潜在用户池。另外，Activiti为用户任务定义了<<bpmnUserTaskUserAssignmentExtension,扩展属性元素>>，代表任务的**办理人**或者**候选用户**。

Activiti支持的身份联系类型有：

[source,java,linenums]
----
public class IdentityLinkType {
  /* Activiti原生角色 Activiti native roles */
  public static final String ASSIGNEE = "assignee";
  public static final String CANDIDATE = "candidate";
  public static final String OWNER = "owner";
  public static final String STARTER = "starter";
  public static final String PARTICIPANT = "participant";
}
----

BPMN标准与Activiti示例身份认证是**用户**与**组**。在前一章节提到过，Activiti的身份管理实现并不适用于生产环境，而需要在支持的认证概要下扩展。

如果需要添加额外的联系类型，可按照下列语法，使用自定义资源作为扩展元素：

[source,xml,linenums]
----
<userTask id="theTask" name="make profit">
  <extensionElements>
    <activiti:customResource activiti:name="businessAdministrator">
      <resourceAssignmentExpression>
        <formalExpression>user(kermit), group(management)</formalExpression>
      </resourceAssignmentExpression>
    </activiti:customResource>
  </extensionElements>
</userTask>
----

自定义联系表达式添加至__TaskDefinition__类：

[source,java,linenums]
----

protected Map<String, Set<Expression>> customUserIdentityLinkExpressions =
      new HashMap<String, Set<Expression>>();
protected Map<String, Set<Expression>> customGroupIdentityLinkExpressions =
      new HashMap<String, Set<Expression>>();

public Map<String,
         Set<Expression>> getCustomUserIdentityLinkExpressions() {
  return customUserIdentityLinkExpressions;
}

public void addCustomUserIdentityLinkExpression(String identityLinkType,
      Set<Expression> idList)
  customUserIdentityLinkExpressions.put(identityLinkType, idList);
}

public Map<String,
       Set<Expression>> getCustomGroupIdentityLinkExpressions() {
  return customGroupIdentityLinkExpressions;
}

public void addCustomGroupIdentityLinkExpression(String identityLinkType,
       Set<Expression> idList) {
  customGroupIdentityLinkExpressions.put(identityLinkType, idList);
}
----

并将会在运行时，由__UserTaskActivityBehavior handleAssignments__方法填写。

最后，需要扩展__IdentityLinkType__类，以支持自定义身份联系类型：

[source,java,linenums]
----
package com.yourco.engine.task;

public class IdentityLinkType
    extends org.activiti.engine.task.IdentityLinkType
{
    public static final String ADMINISTRATOR = "administrator";

    public static final String EXCLUDED_OWNER = "excludedOwner";
}
----


[[bpmnUserTaskUserCustomAssignmentTaskListeners]]


===== 通过任务监听器自定义指派 Custom Assignment via task listeners

如果上面的方式仍不能满足要求，可以在创建事件（create event）上使用<<taskListeners,任务监听器>>，代理自定义指派逻辑：

[source,xml,linenums]
----
<userTask id="task1" name="My task" >
  <extensionElements>
    <activiti:taskListener event="create" class="org.activiti.MyAssignmentHandler" />
  </extensionElements>
</userTask>
----

传递至++TaskListener++实现的++DelegateTask++，可用于设置办理人与候选用户/组：

[source,java,linenums]
----
public class MyAssignmentHandler implements TaskListener {

  public void notify(DelegateTask delegateTask) {
    // Execute custom identity lookups here

    // and then for example call following methods:
    delegateTask.setAssignee("kermit");
    delegateTask.addCandidateUser("fozzie");
    delegateTask.addCandidateGroup("management");
    ...
  }

}
----

当使用Spring时，可以按上面章节的介绍使用自定义指派属性，并代理至使用<<taskListeners,任务监听器>>、带有<<springExpressions,表达式>>的Spring bean，监听任务__创建__事件。在下面的例子中，通过调用++ldapService++ Spring bean的++findManagerOfEmployee++方法，设置办理人。传递的__emp__参数是一个流程变量。

[source,xml,linenums]
----
<userTask id="task" name="My Task" activiti:assignee="${ldapService.findManagerForEmployee(emp)}"/>
----

也可以用于候选用户与组：

[source,xml,linenums]
----
<userTask id="task" name="My Task" activiti:candidateUsers="${ldapService.findAllSales()}"/>
----

请注意调用方法的返回类型必须是++String++或++Collection<String>++（候选用户与组）：

[source,java,linenums]
----
public class FakeLdapService {

  public String findManagerForEmployee(String employee) {
    return "Kermit The Frog";
  }

  public List<String> findAllSales() {
    return Arrays.asList("kermit", "gonzo", "fozzie");
  }

}
----



[[bpmnScriptTask]]


==== 脚本任务 Script Task

[[bpmnScriptTaskDescription]]


===== 描述 Description


脚本任务是自动化的活动。当流程执行到达脚本任务时，会执行相应的脚本。


[[bpmnScriptTaskGraphicalNotation]]


===== 图示 Graphical Notation

脚本任务，用左上角有一个小“脚本”图标的标准BPMN 2.0任务（圆角矩形）表示。

image::images/bpmn.scripttask.png[align="center"]


[[bpmnScriptTaskXml]]


===== XML representation

脚本任务动过指定**script**与**scriptFormat**定义。

[source,xml,linenums]
----
<scriptTask id="theScriptTask" name="Execute script" scriptFormat="groovy">
  <script>
    sum = 0
    for ( i in inputArray ) {
      sum += i
    }
  </script>
</scriptTask>
----

**scriptFormat**属性的值，必须是兼容link:$$http://jcp.org/en/jsr/detail?id=223$$[JSR-223]（Java平台脚本）的名字。默认情况下，JavaScript包含在每一个JDK中，因此不需要添加任何jar。如果想使用其它（兼容JSR-223的）脚本引擎，需要在classpath中添加相应的jar，并使用适当的名字。例如，Activiti单元测试经常使用Groovy，因为其语法与Java十分相似。

请注意Groovy脚本引擎与groovy-all jar捆绑在一起。在2.0版本以前，脚本引擎是Groovy jar的一部分。因此，现在必须添加如下依赖：

[source,xml,linenums]
----
<dependency>
      <groupId>org.codehaus.groovy</groupId>
      <artifactId>groovy-all</artifactId>
      <version>2.x.x<version>
</dependency>
----


[[bpmnScriptTaskVariables]]


===== 脚本中的变量 Variables in scripts

到达脚本引擎的执行可以访问的所有流程变量，都可以在脚本中使用。在这个例子里，脚本变量__'inputArray'__实际上就是一个流程变量（integer数组）。

[source,xml,linenums]
----
<script>
    sum = 0
    for ( i in inputArray ) {
      sum += i
    }
</script>
----

也可以简单地调用__execution.setVariable("variableName", variableValue)__，在脚本中设置流程变量。默认情况下，变量不会自动储存（**请注意，在Activiti 5.12以前是这样的！**）。可以将++scriptTask++的++autoStoreVariables++参数设置为++true++，以自动保存任何在脚本中定义的变量（例如上例中的__sum__）。然而，**最佳实践不是这么做，而是直接调用execution.setVariable()**，因为在JDK近期的一些版本中，某些脚本语言不能自动保存变量。查看link:$$http://www.jorambarrez.be/blog/2013/03/25/bug-on-jdk-1-7-0_17-when-using-scripttask-in-activiti/$$[这个链接]了解更多信息。

[source,xml,linenums]
----
<scriptTask id="script" scriptFormat="JavaScript" activiti:autoStoreVariables="false">
----

这个参数的默认值为++false++，意味着这个参数将在脚本任务定义中忽略，所有声明的变量将只在脚本执行期间有效。

在脚本中设置变量的例子：

[source,xml,linenums]
----
<script>
    def scriptVar = "test123"
    execution.setVariable("myVar", scriptVar)
</script>
----

请注意：下列名字被保留，**不能用于**变量名：**out，out:print，lang:import，context，elcontext**。

[[bpmnScriptTaskResultValue]]


===== 脚本结果 Script results

脚本任务的返回值，可以通过为脚本任务定义的__'activiti:resultVariable'__属性设置流程变量名，指定为已经存在的，或者新的流程变量。指定的已有值的流程变量，会被脚本执行的结果值覆盖。当不指定结果变量名时，脚本结果值将被忽略。

[source,xml,linenums]
----
<scriptTask id="theScriptTask" name="Execute script" scriptFormat="juel" activiti:resultVariable="myVar">
  <script>#{echo}</script>
</scriptTask>
----

在上面的例子中，脚本执行的结果（解析变量__'#{echo}'__的值），将在脚本完成后，设置为名为__'myVar'__的流程变量。

===== 安全性 Security

当使用__javascript__作为脚本语言时，可以使用__“安全脚本（secure scripting）”__。参见<<advancedSecureScripting, 安全脚本章节>>。


[[bpmnJavaServiceTask]]


==== Java服务任务 Java Service Task

[[bpmnJavaServiceTaskDescription]]


===== 描述 Description

Java服务任务用于执行外部的Java类。

[[bpmnJavaServiceTaskGraphicalNotation]]


===== 图示 Graphical Notation

服务任务，用左上角有一个小齿轮图标的圆角矩形表示。

image::images/bpmn.java.service.task.png[align="center"]

[[bpmnJavaServiceTaskXML]]


===== XML表示 XML representation


有四种方法声明如何调用Java逻辑：


* 指定实现了JavaDelegate或ActivityBehavior的类
* 对解析为代理对象的表达式求值
* 调用方法表达式
* 对值表达式求值

要指定流程执行时调用的类，需要使用**'activiti:class'**属性提供全限定类名（fully qualified classname）。

[source,xml,linenums]
----
<serviceTask id="javaService"
             name="My Java Service Task"
             activiti:class="org.activiti.MyJavaDelegate" />
----


查看<<bpmnJavaServiceTaskImplementation,实现章节>>，了解关于如何使用这种类的更多信息。

也可以使用解析为对象的表达式。该对象必须遵循的规则，与使用++activiti:class++创建的对象规则相同（查看<<bpmnJavaServiceTaskImplementation,更多>>）。

[source,xml,linenums]
----
<serviceTask id="serviceTask" activiti:delegateExpression="${delegateExpressionBean}" />
----

这里，++delegateExpressionBean++是一个实现了++JavaDelegate++接口的bean，在Spring容器中定义。

要指定需要计算的UEL方法表达式，使用**activiti:expression**属性。

[source,xml,linenums]
----
<serviceTask id="javaService"
             name="My Java Service Task"
             activiti:expression="#{printer.printMessage()}" />
----

将在名为++printer++的对象上调用++printMessage++方法（不带参数）。

也可以为表达式中使用的方法传递变量。

[source,xml,linenums]
----
<serviceTask id="javaService"
             name="My Java Service Task"
             activiti:expression="#{printer.printMessage(execution, myVar)}" />
----

将在名为++printer++的对象上调用++printMessage++方法。传递的第一个参数为++DelegateExecution++，名为++execution++，在表达式上下文中默认可用。传递的第二个参数，是当前执行中，名为++myVar++变量的值。

可以使用**activiti:expression**属性指定需要计算的UEL值表达式。

[source,xml,linenums]
----
<serviceTask id="javaService"
             name="My Java Service Task"
             activiti:expression="#{split.ready}" />
----

会调用名为++split++的bean的++ready++参数的getter方法，++getReady++（不带参数）。该对象会被解析为执行的流程变量或（如果可用的话）Spring上下文中的bean。


[[bpmnJavaServiceTaskImplementation]]


===== 实现 Implementation

要实现可以在流程执行中调用的类，需要实现__org.activiti.engine.delegate.JavaDelegate__接口，并在__execute__方法中提供所需逻辑。当流程执行到达该活动时，会执行方法中定义的逻辑，并按照BPMN 2.0的默认方法离开活动。

让我们创建一个Java类的示例，可用于将流程变量String改为大写。这个类需要实现__org.activiti.engine.delegate.JavaDelegate__接口，因此需要实现__execute(DelegateExecution)__方法。这个方法就是引擎将调用的方法，需要实现业务逻辑。可以通过link:$$http://activiti.org/javadocs/org/activiti/engine/delegate/DelegateExecution.html$$[DelegateExecution]接口（点击链接获取该接口操作的详细Javadoc）访问流程实例信息，如流程变量等。

[source,java,linenums]
----
public class ToUppercase implements JavaDelegate {

  public void execute(DelegateExecution execution) throws Exception {
    String var = (String) execution.getVariable("input");
    var = var.toUpperCase();
    execution.setVariable("input", var);
  }

}
----

请注意：**只会为serviceTask上定义的Java类创建一个实例**。所有流程实例共享同一个类实例，用于调用__execute(DelegateExecution)__。这意味着该类不能有任何成员变量，并需要是线程安全的，因为它可能会在不同线程中同时执行。这也影响了<<serviceTaskFieldInjection,字段注入>>的使用方法。（译者注：原文可能较老，不正确。5.21中，activiti:class指定的类，会在流程实例启动时，为每个活动，分别进行实例化。不过，当该活动在流程中重复执行，或者为多实例时，使用的都会是同一个类实例。）

在流程定义中（如通过++activiti:class++）引用的类，**不会在部署时实例化**。只有当流程执行第一次到达该类使用的地方时，才会创建该类的实例。如果找不到这个类，会抛出++ActivitiException++。这是因为部署时的环境（更准确的说__classpath__），与实际运行的环境经常不一样。例如当使用__ant__或者Activiti Explorer中业务存档上传的方式部署的流程，其classpath中并没有流程引用的类。

<<internal,[内部：非公有实现类]>>也可以使用实现了__org.activiti.engine.impl.pvm.delegate.ActivityBehavior__接口的类。该实现可以访问更强大的__ActivityExecution__，可以例如影响流程的控制流程。请注意这并不是很好的实践，需要避免这么使用。因此，建议只有在高级使用场景下，并且你确知在做什么的时候，才使用__ActivityBehavior__接口。


[[serviceTaskFieldInjection]]


===== 字段注入 Field Injection

可以为代理类的字段注入值。支持下列注入方式：

* 字符串常量
* 表达式

如果可以的话，会按照Java Bean命名约定（例如，++firstName++成员使用setter ++setFirstName(...)++），通过代理类的公有setter方法，注入变量。如果该字段没有可用的setter，会直接设置该代理类的私有成员的值。有的环境中，SecurityManagers不允许修改私有字段，因此为想要注入的字段，暴露一个公有setter方法，是更安全的做法。

**不论在流程定义中声明的是什么类型的值，注入对象的setter/私有字段的类型，总是+org.activiti.engine.delegate.Expression+。当表达式解析后，可以被转型为合适的类型。**

当使用__'actviiti:class'__属性时，支持字段注入。也可以在使用__activiti:delegateExpression__属性时，进行字段注入，然而因为线程安全的考虑，需要有特殊的规则（参见下一章节）。

下面的代码片段展示了如何为类中声明的字段注入常量值。请注意按照BPMN 2.0 XML概要的要求，**在实际字段注入声明前，需要先声明'extensionElements'XML元素**。

[source,xml,linenums]
----
<serviceTask id="javaService"
    name="Java service invocation"
    activiti:class="org.activiti.examples.bpmn.servicetask.ToUpperCaseFieldInjected">
    <extensionElements>
      <activiti:field name="text" stringValue="Hello World" />
  </extensionElements>
</serviceTask>
----

++ToUpperCaseFieldInjected++类有一个字段++text++，为++org.activiti.engine.delegate.Expression++类型。当调用++text.getValue(execution)++时，会返回配置的字符串++Hello World++：

[source,java,linenums]
----
public class ToUpperCaseFieldInjected implements JavaDelegate {

  private Expression text;

  public void execute(DelegateExecution execution) {
    execution.setVariable("var", ((String)text.getValue(execution)).toUpperCase());
  }

}
----

另外，对于较长文本（例如e-mail），可以使用__'activiti:string'__子元素：

[source,xml,linenums]
----
<serviceTask id="javaService"
    name="Java service invocation"
    activiti:class="org.activiti.examples.bpmn.servicetask.ToUpperCaseFieldInjected">
  <extensionElements>
    <activiti:field name="text">
        <activiti:string>
          This is a long string with a lot of words and potentially way longer even!
      </activiti:string>
    </activiti:field>
  </extensionElements>
</serviceTask>
----

要在运行时动态解析注入的值，可以使用表达式。这种表达式可以使用流程变量，或者Spring定义的bean（如果使用Spring）。像<<bpmnJavaServiceTaskImplementation,服务任务实现>>中提到的，当服务任务中使用__activiti:class__属性时，该Java类的实例在所有流程实例中共享。要动态地为字段注入值，可以在+org.activiti.engine.delegate.Expression+中注入值或方法表达式，它们会通过++execute++方法传递的++DelegateExecution++计算/调用。

下面的示例类，使用了注入的表达式，并使用当前的++DelegateExecution++解析它们。调用__generBean__方法时传递的是__gender__变量。完整的代码与测试可以在++org.activiti.examples.bpmn.servicetask.JavaServiceTaskTest.testExpressionFieldInjection++中找到

[source,xml,linenums]
----
<serviceTask id="javaService" name="Java service invocation"
  activiti:class="org.activiti.examples.bpmn.servicetask.ReverseStringsFieldInjected">

  <extensionElements>
    <activiti:field name="text1">
      <activiti:expression>${genderBean.getGenderString(gender)}</activiti:expression>
    </activiti:field>
    <activiti:field name="text2">
       <activiti:expression>Hello ${gender == 'male' ? 'Mr.' : 'Mrs.'} ${name}</activiti:expression>
    </activiti:field>
  </ extensionElements>
</ serviceTask>
----

[source,java,linenums]
----
public class ReverseStringsFieldInjected implements JavaDelegate {

  private Expression text1;
  private Expression text2;

  public void execute(DelegateExecution execution) {
    String value1 = (String) text1.getValue(execution);
    execution.setVariable("var1", new StringBuffer(value1).reverse().toString());

    String value2 = (String) text2.getValue(execution);
    execution.setVariable("var2", new StringBuffer(value2).reverse().toString());
  }
}
----

另外，为避免XML太过冗长，可以将表达式设置为属性，而不是子元素。

[source,xml,linenums]
----
<activiti:field name="text1" expression="${genderBean.getGenderString(gender)}" />
<activiti:field name="text1" expression="Hello ${gender == 'male' ? 'Mr.' : 'Mrs.'} ${name}" />
----

[[serviceTaskFieldInjectionThreadSafety]]

===== 字段注入与线程安全 Field injection and thread safety

总的来说，在服务任务中使用Java代理与字段注入是线程安全的。然而，有些情况下不能保证线程安全，取决于设置，或Activiti运行所在的环境。

当使用__activiti:class__属性时，使用字段注入总是线程安全的（译者注：仍不完全安全，如对于多实例服务任务，使用的是同一个类实例）。对于引用了某个类的每一个服务任务，都会实例化新的实例，并且在创建实例时注入一次字段。在不同的任务或流程定义中多次使用同一个类没有问题。

当使用__activiti:expression__属性时，不能使用字段注入。只能通过方法调用传递变量，并且这总是线程安全的。

当使用__activiti:delegateExpression__属性时，代理实例的线程安全性，取决于表达式解析的方式。如果该代理表达式在多个任务与/或流程定义中重复使用，并且表达式总是返回相同的示例，则字段注入**不是线程安全的**。让我们看几个例子。

假设表达式为__${factory.createDelegate(someVariable)}__，其中factory为引擎可用的Java bean（例如使用Spring集成时的Spring bean），并在每次表达式解析时，创建新的实例。这种情况下，使用字段注入时，没有线程安全性问题：每次表达式解析时，新实例的字段都会注入。

然而，如果表达式为__${someJavaDelegateBean}__，解析为JavaDelegate的实现，并且在创建单例的环境（如Spring）中运行。当在不同的任务和/或流程定义中使用这个表达式时，表达式总会解析为相同的实例。这种情况下，使用字段注入不是线程安全的。例如：

[source,xml,linenums]
----
<serviceTask id="serviceTask1" activiti:delegateExpression="${someJavaDelegateBean}">
    <extensionElements>
        <activiti:field name="someField" expression="${input * 2}"/>
    </extensionElements>
</serviceTask>

<!-- other process definition elements -->

<serviceTask id="serviceTask2" activiti:delegateExpression="${someJavaDelegateBean}">
    <extensionElements>
        <activiti:field name="someField" expression="${input * 2000}"/>
    </extensionElements>
</serviceTask>
----

这段示例代码有两个服务任务，使用同一个代理表达式，但是__expression__字段填写不同的值。**如果该表达式解析为相同的实例，就会在并发场景下，注入__someField__字段时出现竞争条件**。

最简单的解决方案，为

* 重写Java代理，以使用表达式，并将所需数据通过方法参数传递给代理。
* 或者，在每次代理表达式解析时，返回代理类的新实例。这意味着这个bean的scope（范围）必须是**prototype（原型）**（例如在代理类上加上@Scope(SCOPE_PROTOTYPE)注解）。

在Activiti 5.21版本中，可以通过配置流程引擎配置，禁用在代理表达式上使用字段注入。需要设置__delegateExpressionFieldInjectionMode__参数（取__org.activiti.engine.imp.cfg.DelegateExpressionFieldInjectionMode__枚举中的值）。

可使用下列选项：

* **DISABLED（禁用）**：当使用代理表达式时，完全禁用字段注入。不会再尝试进行字段注入。这是最安全的方式，保证线程安全。
* **COMPATIBILITY（兼容）**：在这个模式下，行为与5.21版本之前完全一样：可以在代理表达式中使用字段注入，如果代理类中没有定义该字段，会抛出异常。这是最不线程安全的模式，但可以保证历史版本兼容性，也可以在代理表达式只在一个任务中使用的时候（因此不会产生并发竞争条件），安全使用。
* **MIXED（混合）**：可以在使用代理表达式时注入，但当代理中没有定义字段时，不会抛出异常。这样可以在部分代理中使用注入（例如不是单例时），而在部分代理中不使用注入。

* **Activiti 5.x版本的默认模式为COMPATIBILITY（兼容）**。
* **Activiti 6.x版本的默认模式为MIXED（混合）**。

例如，假设使用__MIXED__模式，并使用Spring集成，在Spring配置中定义了如下bean：

[source,xml,linenums]
----
<bean id="singletonDelegateExpressionBean"
  class="org.activiti.spring.test.fieldinjection.SingletonDelegateExpressionBean" />

<bean id="prototypeDelegateExpressionBean"
  class="org.activiti.spring.test.fieldinjection.PrototypeDelegateExpressionBean"
  scope="prototype" />
----

第一个bean是一般的Spring bean，因此是单例的。第二个的scope为__prototype__，因此每次请求这个bean时，Spring容器都会返回一个新实例。

在以下流程定义中：

[source,xml,linenums]
----
<serviceTask id="serviceTask1" activiti:delegateExpression="${prototypeDelegateExpressionBean}">
  <extensionElements>
    <activiti:field name="fieldA" expression="${input * 2}"/>
    <activiti:field name="fieldB" expression="${1 + 1}"/>
    <activiti:field name="resultVariableName" stringValue="resultServiceTask1"/>
  </extensionElements>
</serviceTask>

<serviceTask id="serviceTask2" activiti:delegateExpression="${prototypeDelegateExpressionBean}">
  <extensionElements>
    <activiti:field name="fieldA" expression="${123}"/>
    <activiti:field name="fieldB" expression="${456}"/>
    <activiti:field name="resultVariableName" stringValue="resultServiceTask2"/>
  </extensionElements>
</serviceTask>

<serviceTask id="serviceTask3" activiti:delegateExpression="${singletonDelegateExpressionBean}">
  <extensionElements>
    <activiti:field name="fieldA" expression="${input * 2}"/>
    <activiti:field name="fieldB" expression="${1 + 1}"/>
    <activiti:field name="resultVariableName" stringValue="resultServiceTask1"/>
  </extensionElements>
</serviceTask>

<serviceTask id="serviceTask4" activiti:delegateExpression="${singletonDelegateExpressionBean}">
  <extensionElements>
    <activiti:field name="fieldA" expression="${123}"/>
    <activiti:field name="fieldB" expression="${456}"/>
    <activiti:field name="resultVariableName" stringValue="resultServiceTask2"/>
  </extensionElements>
</serviceTask>
----

有四个服务任务，第一、二个使用__${prototypeDelegateExpressionBean}__代理表达式，第三、四个使用__${singletonDelegateExpressionBean}__代理表达式。

先看原型bean：

[source,java,linenums]
----
public class PrototypeDelegateExpressionBean implements JavaDelegate {

  public static AtomicInteger INSTANCE_COUNT = new AtomicInteger(0);

  private Expression fieldA;
  private Expression fieldB;
  private Expression resultVariableName;

  public PrototypeDelegateExpressionBean() {
    INSTANCE_COUNT.incrementAndGet();
  }

  @Override
  public void execute(DelegateExecution execution) throws Exception {

    Number fieldAValue = (Number) fieldA.getValue(execution);
    Number fieldValueB = (Number) fieldB.getValue(execution);

    int result = fieldAValue.intValue() + fieldValueB.intValue();
    execution.setVariable(resultVariableName.getValue(execution).toString(), result);
  }

}
----

在运行上面流程定义的一个流程实例后，检查__INSTANCE_COUNT__，会得到__2__。这是因为每次__${prototypeDelegateExpressionBean}__解析时，都会创建新实例。可以看到三个__Expression__成员字段的注入没有任何问题。

而在原型bean中，有一点区别：

[source,java,linenums]
----
public class SingletonDelegateExpressionBean implements JavaDelegate {

  public static AtomicInteger INSTANCE_COUNT = new AtomicInteger(0);

  public SingletonDelegateExpressionBean() {
    INSTANCE_COUNT.incrementAndGet();
  }

  @Override
  public void execute(DelegateExecution execution) throws Exception {

    Expression fieldAExpression = DelegateHelper.getFieldExpression(execution, "fieldA");
    Number fieldA = (Number) fieldAExpression.getValue(execution);

    Expression fieldBExpression = DelegateHelper.getFieldExpression(execution, "fieldB");
    Number fieldB = (Number) fieldBExpression.getValue(execution);

    int result = fieldA.intValue() + fieldB.intValue();

    String resultVariableName = DelegateHelper.getFieldExpression(execution, "resultVariableName").getValue(execution).toString();
    execution.setVariable(resultVariableName, result);
  }

}
----

__INSTANCE_COUNT__总是__1__，因为是单例模式。在这个代理中，没有__Expression__成员字段。因为我们使用的是__MIXED__模式，可以这样用。而在__COMPATIBILITY__模式下，就会抛出异常，因为需要有成员字段。这个bean也可以使用__DISABLED__模式，但会禁用上面进行了字段注入的原型bean。

在代理的代码里，使用了**org.activiti.engine.delegate.DelegateHelper**。它提供了一些有用的工具方法，用于执行相同的逻辑，并且在单例中是线程安全的。与注入__Expression__不同，它通过__getFieldExpression__读取。这意味着在服务任务的XML里，字段定义与单例bean完全相同。查看上面的XML代码，可以看到定义是相同的，只是实现逻辑不同。

（技术提示：__getFieldExpression__直接读取BpmnModel，并在方法执行时创建表达式，因此是线程安全的）。


* 在Activiti 5.x版本中，（由于架构缺陷）不能在__ExecutionListener__或__TaskListener__中使用DelegateHelper。要保证监听器的线程安全，仍需使用表达式，或确保每次解析代理表达式时，都创建新实例。
* 在Activiti 6.x版本中，在__ExecutionListener__或__TaskListener__中可以使用DelegateHelper。例如在6.x版本中，下列代码可以使用**DelegateHelper**：

[source,xml,linenums]
----
<extensionElements>
  <activiti:executionListener
      delegateExpression="${testExecutionListener}" event="start">
    <activiti:field name="input" expression="${startValue}" />
    <activiti:field name="resultVar" stringValue="processStartValue" />
  </activiti:executionListener>
</extensionElements>
----

其中__testExecutionListener__解析为ExecutionListener接口的一个实现的实例：

[source,java,linenums]
----
@Component("testExecutionListener")
public class TestExecutionListener implements ExecutionListener {

  @Override
  public void notify(DelegateExecution execution) {
    Expression inputExpression = DelegateHelper.getFieldExpression(execution, "input");
    Number input = (Number) inputExpression.getValue(execution);

    int result = input.intValue() * 100;

    Expression resultVarExpression = DelegateHelper.getFieldExpression(execution, "resultVar");
    execution.setVariable(resultVarExpression.getValue(execution).toString(), result);
  }

}
----



[[serviceTaskResultValue]]


===== 服务任务的结果 Service task results

服务执行的返回值（仅对使用表达式的服务任务），可以通过为脚本任务定义的__'activiti:resultVariable'__属性设置流程变量名，指定为已经存在的，或者新的流程变量。指定的已有值的流程变量，会被服务执行的结果值覆盖。当不指定结果变量名时，服务执行的结果值将被忽略。

[source,xml,linenums]
----
<serviceTask id="aMethodExpressionServiceTask"
    activiti:expression="#{myService.doSomething()}"
    activiti:resultVariable="myVar" />
----

在上例中，服务执行的结果（使用流程变量或Spring bean，使用__'myService'__名字获取的对象，调用__'doSomething()'__方法的返回值），在服务执行完成后，会设置为名为__'myVar'__的流程变量。


[[serviceTaskExceptionHandling]]


===== 处理异常 Handling exceptions

当执行自定义逻辑时，通常需要捕获特定的业务异常，并在流程中处理。Activiti提供了不同的方法。


[[serviceTaskBpmnErrors]]


====== 抛出BPMN错误 Throwing BPMN Errors

可以在服务任务或脚本任务的用户代码中抛出BPMN错误。要这么做，可以在Java代理、脚本、表达式与代理表达式中，抛出特殊的ActivitiException，叫做__BpmnError__。引擎会捕获这个异常，并将其转发至合适的错误处理器，例如异常边界事件，或者错误事件子程序。

[source,java,linenums]
----
public class ThrowBpmnErrorDelegate implements JavaDelegate {

  public void execute(DelegateExecution execution) throws Exception {
    try {
      executeBusinessLogic();
    } catch (BusinessException e) {
      throw new BpmnError("BusinessExceptionOccurred");
    }
  }

}
----

构造函数的参数是错误代码，将被用于决定处理这个错误的错误处理器。参见<<bpmnBoundaryErrorEvent,错误边界事件>>了解如何捕获BPMN错误。

这个机制**只应该用于业务错误**，需要通过流程中定义的错误边界事件或错误事件子流程处理。技术错误应该通过其他异常类型表现，并且通常不在流程内部处理。

[[exceptionMapping]]

====== 异常映射 Exception mapping

也可以使用++mapException++扩展，直接将Java异常映射至业务异常（错误）。单一映射是最简单的格式：

[source,xml,linenums]
----
<serviceTask id="servicetask1" name="Service Task" activiti:class="...">
  <extensionElements>
    <activiti:mapException
          errorCode="myErrorCode1">org.activiti.SomeException</activiti:mapException>
  </extensionElements>
</serviceTask>

----

在上面的代码中，如果服务任务抛出了++org.activiti.SomeException++的实例，则会被捕获，并被转换为带有给定errorCode的BPMN异常（错误）。从这里开始，可以与普通BPMN异常（错误）完全一样地处理。

其他异常会依照没有映射被处理，将传播至API调用者。

也可以在一行中，使用++includeChildExceptions++属性，映射特定异常的所有子异常。

[source,xml,linenums]
----
<serviceTask id="servicetask1" name="Service Task" activiti:class="...">
  <extensionElements>
    <activiti:mapException errorCode="myErrorCode1"
           includeChildExceptions="true">org.activiti.SomeException</activiti:mapException>
  </extensionElements>
</serviceTask>

----

上面的代码中，Activiti会将任何直接或间接的++SomeException++的子类，转换为带有给定错误代码的BPMN错误。当未指定++includeChildExceptions++时，视为“false”。

最普通的是默认映射。默认映射是一个没有类的映射，可以匹配任何Java异常：

[source,xml,linenums]
----
<serviceTask id="servicetask1" name="Service Task" activiti:class="...">
  <extensionElements>
    <activiti:mapException errorCode="myErrorCode1"/>
  </extensionElements>
</serviceTask>
----

映射会按照顺序检查，从上至下，使用第一个匹配的映射，除了默认映射。默认映射将只在所有映射都不能成功匹配时使用。只有第一个没有类的映射会当做默认映射处理。默认映射忽略++includeChildExceptions++。


[[serviceTaskExceptionSequenceFlow]]


====== 异常顺序流 Exception Sequence Flow


<<internal, [内部：非公有实现类]>>

也可以选择在发生异常时，将流程执行路由至另一条路径。下面的例子展示了如何做。

[source,xml,linenums]
----
<serviceTask id="javaService"
  name="Java service invocation"
  activiti:class="org.activiti.ThrowsExceptionBehavior">
</serviceTask>

<sequenceFlow id="no-exception" sourceRef="javaService" targetRef="theEnd" />
<sequenceFlow id="exception" sourceRef="javaService" targetRef="fixException" />
----

在这里，这个服务任务具有两条出口顺序流，分别称为++exception++与++no-exception++。这些顺序流id会在发生异常时，用于控制流程流向：

[source,java,linenums]
----
public class ThrowsExceptionBehavior implements ActivityBehavior {

  public void execute(ActivityExecution execution) throws Exception {
    String var = (String) execution.getVariable("var");

    PvmTransition transition = null;
    try {
      executeLogic(var);
      transition = execution.getActivity().findOutgoingTransition("no-exception");
    } catch (Exception e) {
      transition = execution.getActivity().findOutgoingTransition("exception");
    }
    execution.take(transition);
  }

}
----


[[serviceTaskCallActivitiService]]


===== 在JavaDelegate中使用Activiti服务 Using an Activiti service from within a JavaDelegate

有的时候，需要在Java服务任务中使用Activiti服务（例如当调用活动不符合需求时，通过RuntimeService启动流程实例）。__org.activiti.engine.delegate.DelegateExecution__可以方便地通过__org.activiti.engine.EngineServices__接口使用这些服务：

[source,java,linenums]
----
public class StartProcessInstanceTestDelegate implements JavaDelegate {

  public void execute(DelegateExecution execution) throws Exception {
    RuntimeService runtimeService = execution.getEngineServices().getRuntimeService();
    runtimeService.startProcessInstanceByKey("myProcess");
  }

}
----

通过这个接口可以访问所有Activiti服务API。

使用这些API调用造成的所有数据变更，都处在当前事务中。在具有依赖注入的环境，如Spring或CDI中，使用或不使用激活JTA的数据源，也都可以使用。例如，下面的代码片段与上面的代码具有相同功能，但RuntimeService是通过注入而不是通过__org.activiti.engine.EngineServices__接口获得的。

[source,java,linenums]
----
@Component("startProcessInstanceDelegate")
public class StartProcessInstanceTestDelegateWithInjection {

    @Autowired
    private RuntimeService runtimeService;

    public void startProcess() {
      runtimeService.startProcessInstanceByKey("oneTaskProcess");
    }

}
----

**重要技术提示：**在当前事务中进行的服务调用，产生或修改的数据是在服务任务执行__前__完成的，因此更改还未刷入数据库。所有API调用都通过处理数据库数据而生效，这意味着这些未提交的修改在服务任务的API调用中“不可见”。


[[bpmnWebserviceTask]]


==== Web服务任务 Web Service Task

<<experimental,[EXPERIMENTAL]>>[[bpmnWebserviceTaskDescription]]


===== 描述 Description

Web服务任务用于同步调用外部的Web服务。


[[bpmnWebserviceTaskGraphicalNotation]]


===== 图示 Graphical Notation

Web服务任务，与Java服务任务显示地一样。

image::images/bpmn.web.service.task.png[align="center"]


[[bpmnWebserviceTaskXML]]


===== XML表示 XML representation

要使用Web服务，需要导入其操作，以及复杂的类型。通过使用指向Web服务的WSDL的导入标签（import tag），可以自动完成这些：

[source,xml,linenums]
----
<import importType="http://schemas.xmlsoap.org/wsdl/"
	location="http://localhost:63081/counter?wsdl"
	namespace="http://webservice.activiti.org/" />
----

上面的声明告知Activiti导入定义，但并不创建条目定义（item definition）与消息。假设我们需要调用一个名为'prettyPrint'的方法，我们需要为请求与回复消息，创建相应的消息与条目定义：

[source,xml,linenums]
----
<message id="prettyPrintCountRequestMessage" itemRef="tns:prettyPrintCountRequestItem" />
<message id="prettyPrintCountResponseMessage" itemRef="tns:prettyPrintCountResponseItem" />

<itemDefinition id="prettyPrintCountRequestItem" structureRef="counter:prettyPrintCount" />
<itemDefinition id="prettyPrintCountResponseItem" structureRef="counter:prettyPrintCountResponse" />
----

在声明服务任务前，需要定义实际引用Web服务的BPMN接口与操作。基本上，是定义“接口”与所需的“操作”。我们对每一个操作都重复使用之前定义的传入与传出消息。例如，下面的声明定义了“counter”接口，与“prettyPrintCountOperation”操作：

[source,xml,linenums]
----
<interface name="Counter Interface" implementationRef="counter:Counter">
	<operation id="prettyPrintCountOperation" name="prettyPrintCount Operation"
			implementationRef="counter:prettyPrintCount">
		<inMessageRef>tns:prettyPrintCountRequestMessage</inMessageRef>
		<outMessageRef>tns:prettyPrintCountResponseMessage</outMessageRef>
	</operation>
</interface>
----

现在可以通过使用##WebService实现，声明Web服务任务，并引用Web服务操作。

[source,xml,linenums]
----
<serviceTask id="webService"
	name="Web service invocation"
	implementation="##WebService"
	operationRef="tns:prettyPrintCountOperation">
----

[[bpmnWebserviceTaskIOSpecification]]


===== Web服务任务IO规格 Web Service Task IO Specification

除非使用简化方法处理输入与输出数据关联（见下），否则需要为每个Web服务任务声明IO规格，指出任务的输入与输出是什么。这个方法很简单，也兼容BPMN 2.0。在prettyPrint例子中，根据之前声明的条目定义，定义输入与输出：

[source,xml,linenums]
----
<ioSpecification>
	<dataInput itemSubjectRef="tns:prettyPrintCountRequestItem" id="dataInputOfServiceTask" />
	<dataOutput itemSubjectRef="tns:prettyPrintCountResponseItem" id="dataOutputOfServiceTask" />
	<inputSet>
		<dataInputRefs>dataInputOfServiceTask</dataInputRefs>
	</inputSet>
	<outputSet>
		<dataOutputRefs>dataOutputOfServiceTask</dataOutputRefs>
	</outputSet>
</ioSpecification>
----

[[bpmnWebserviceTaskDataInputAssociation]]


===== Web服务任务数据输入关联 Web Service Task data input associations

有两种指定数据输入关联的方式：


* 使用表达式
* 使用简化方法

要使用表达式指定数据输入关联，需要定义条目的源与目标，并指定每个条目字段的关联。下面的例子中我们指定了条目的prefix与suffix字段：

[source,xml,linenums]
----
<dataInputAssociation>
	<sourceRef>dataInputOfProcess</sourceRef>
	<targetRef>dataInputOfServiceTask</targetRef>
	<assignment>
		<from>${dataInputOfProcess.prefix}</from>
		<to>${dataInputOfServiceTask.prefix}</to>
	</assignment>
	<assignment>
		<from>${dataInputOfProcess.suffix}</from>
		<to>${dataInputOfServiceTask.suffix}</to>
	</assignment>
</dataInputAssociation>
----

另一方面，也可以使用简化方法。'sourceRef'元素是一个Activiti变量名，而'targetRef'是条目定义的参数。在下面的例子里，将'PrefixVariable'变量的值关联至'prefix'字段，并将'SuffixVariable'变量的值关联至'suffix'字段。

[source,xml,linenums]
----
<dataInputAssociation>
	<sourceRef>PrefixVariable</sourceRef>
	<targetRef>prefix</targetRef>
</dataInputAssociation>
<dataInputAssociation>
	<sourceRef>SuffixVariable</sourceRef>
	<targetRef>suffix</targetRef>
</dataInputAssociation>
----

[[bpmnWebserviceTaskDataOutputAssociation]]


===== Web服务任务数据输出关联 Web Service Task data output associations

有两种指定数据输出关联的方式：


* 使用表达式
* 使用简化方法

要使用表达式指定数据输出关联，需要定义目标变量与源表达式。这种方法很直接，与数据输入关联类似：

[source,xml,linenums]
----
<dataOutputAssociation>
	<targetRef>dataOutputOfProcess</targetRef>
	<transformation>${dataOutputOfServiceTask.prettyPrint}</transformation>
</dataOutputAssociation>
----

另一方面，也可以使用简化方法。'sourceRef'是条目定义的参数，而'targetRef'元素是一个Activiti变量名。这种方法很直接，与数据输入关联类似：

[source,xml,linenums]
----
<dataOutputAssociation>
	<sourceRef>prettyPrint</sourceRef>
	<targetRef>OutputVariable</targetRef>
</dataOutputAssociation>
----

[[bpmnBusinessRuleTask]]


==== 业务规则任务 Business Rule Task

<<experimental,[EXPERIMENTAL]>>[[bpmnBusinessRuleTaskDescription]]


===== 描述 Description

业务规则任务用于同步执行一条或多条规则。Activiti使用名为Drools Expert的Drools规则引擎执行业务规则。目前，业务规则中包含的.drl文件，必须与定义了业务规则服务，并执行规则的流程定义一起部署。这意味着流程中使用的所有.drl文件都需要打包在流程BAR文件中，与任务表单类似。要了解为Drools Expert创建业务规则的更多信息，请访问位于link:$$http://www.jboss.org/drools/documentation$$[JBoss Drools]的Drools文档。

如果想要插入自己的规则任务实现，例如，希望通过不同方法使用Drools，或者想使用完全不同的规则引擎，则可以使用BusinessRuleTask的class或expression属性。这样它会与link:$$#bpmnJavaServiceTask$$[服务任务]的行为完全相同。


[[bpmnBusinessRuleTaskGraphicalNotation]]


===== 图示 Graphical Notation

业务规则任务，显示为带有表格图表的圆角矩形。

image::images/bpmn.business.rule.task.png[align="center"]


[[bpmnBusinessRuleTaskXML]]


===== XML表示 XML representation

要执行一条或多条，与流程定义在同一个BAR文件中部署的，业务规则，需要定义输入与结果变量。输入变量可以用流程变量的列表定义，使用逗号分隔。输出变量只能有一个变量名，将执行业务规则数处对象存储至流程变量。请注意结果变量会包含对象的list。如果没有指定结果变量名，会使用默认的org.activiti.engine.rules.OUTPUT。

下面的业务规则任务，执行与流程定义一起部署的所有业务规则：

[source,xml,linenums]
----
<process id="simpleBusinessRuleProcess">

  <startEvent id="theStart" />
  <sequenceFlow sourceRef="theStart" targetRef="businessRuleTask" />

  <businessRuleTask id="businessRuleTask" activiti:ruleVariablesInput="${order}"
      activiti:resultVariable="rulesOutput" />

  <sequenceFlow sourceRef="businessRuleTask" targetRef="theEnd" />

  <endEvent id="theEnd" />

</process>
----

也可以将业务规则任务配置为只执行部署的.drl文件中的一组规则。要做到这一点，需要指定规则名字的列表，用逗号分隔。

[source,xml,linenums]
----
<businessRuleTask id="businessRuleTask" activiti:ruleVariablesInput="${order}"
      activiti:rules="rule1, rule2" />
----

这个例子中只会执行rule1与rule2。

也可以定义需要从执行中排除的规则列表。 execution.

[source,xml,linenums]
----
<businessRuleTask id="businessRuleTask" activiti:ruleVariablesInput="${order}"
      activiti:rules="rule1, rule2" exclude="true" />
----

这个例子中与流程定义一起部署在同一个BAR文件中的所有规则都会被执行，除了rule1与rule2.

前面提到过，还可以自行处理BusinessRuleTask的实现：

[source,xml,linenums]
----
<businessRuleTask id="businessRuleTask" activiti:class="${MyRuleServiceDelegate}" />
----

这样业务规则任务与服务任务的行为完全一样，但仍保持业务规则任务的图标，显示在这里处理业务规则。


[[bpmnEmailTask]]


==== 邮件任务 Email Task

Activiti可以通过自动邮件服务任务，增强业务流程。可以向一个或多个收信人发送邮件，支持cc，bcc，HTML内容，等等。请注意邮件任务**不是**BPMN 2.0规范的“官方”任务（因此也没有专用图标）。因此，在Activiti中，邮件任务实现为一种特殊的服务任务。


[[bpmnEmailTaskServerConfiguration]]


===== 邮件服务器配置 Mail server configuration

Activiti引擎通过支持SMTP的外部邮件服务器发送邮件。要发送邮件，引擎需要了解如何连接邮件服务器。可以在__activiti.cfg.xml__配置文件中设置下面的参数：

[options="header"]
|===============
|参数|必填?|描述
|mailServerHost|否|邮件服务器的主机名（如mail.mycorp.com）。默认为++localhost++
|mailServerPort|是，如果不使用默认端口|邮件服务器的SMTP端口。默认值为__25__
|mailServerDefaultFrom|否|若用户没有提供地址，默认使用的邮件发件人地址。默认为__activiti@activiti.org__
|mailServerUsername|若服务器需要|部分邮件服务器发信时需要进行认证。默认为空。
|mailServerPassword|若服务器需要|部分邮件服务器发信时需要进行认证。默认为空。
|mailServerUseSSL|若服务器需要|部分邮件服务器要求ssl通信。默认设置为false。
|mailServerUseTLS|若服务器需要|部分邮件服务器要求TLS通信（例如gmail）。默认设置为false。

|===============


[[bpmnEmailTaskUsage]]


===== 定义邮件任务 Defining an Email Task

邮件任务实现为特殊的<<bpmnJavaServiceTask,服务任务>>，通过将服务任务的__type__定义为__'mail'__设置。

[source,xml,linenums]
----
<serviceTask id="sendMail" activiti:type="mail">
----

邮件任务通过<<serviceTaskFieldInjection,字段注入>>配置。这些参数的值可以使用EL表达式，将在流程执行运行时解析。可以设置下列参数：

[options="header"]
|===============
|参数|必填?|描述
|to|是|邮件的收信人。可以使用逗号分隔的列表定义多个接收人
|from|否|邮件的发信人地址。如果不设置，会使用<<bpmnEmailTaskServerConfiguration,默认配置>>的地址
|cc|否|邮件的抄送人。可以使用逗号分隔的列表定义多个接收人
|bcc|否|邮件的密送人。可以使用逗号分隔的列表定义多个接收人
|charset|否|可以修改邮件的字符集，对许多非英语语言很必要。
|html|否|邮件的HTML内容
|text|否|邮件的内容，普通非富文本的邮件。对于不支持富文本内容的客户端，可以与__html__一起使用。客户端会退回为纯文本格式。
|htmlVar|否|存储邮件HTML内容的流程变量名。与html参数的最大区别，是这个参数会在邮件任务发送前，使用其内容进行表达式替换。
|textVar|否|存储邮件纯文本内容的流程变量名。与text参数的最大区别，是这个参数会在邮件任务发送前，使用其内容进行表达式替换。
|ignoreException|否|处理邮件时的失败，是否抛出ActivitiException。默认设置为false。
|exceptionVariableName|否|当处理邮件时的失败，由于__ignoreException = true__设置而不会抛出异常，则使用给定名字的变量保存失败信息

|===============



[[bpmnEmailTaskExampleUsage]]


===== 使用示例 Example usage

下面的XML代码片段展示了使用邮件任务的示例。

[source,xml,linenums]
----
<serviceTask id="sendMail" activiti:type="mail">
  <extensionElements>
    <activiti:field name="from" stringValue="order-shipping@thecompany.com" />
    <activiti:field name="to" expression="${recipient}" />
    <activiti:field name="subject" expression="Your order ${orderId} has been shipped" />
    <activiti:field name="html">
      <activiti:expression>
        <![CDATA[
          <html>
            <body>
              Hello ${male ? 'Mr.' : 'Mrs.' } ${recipientName},<br/><br/>

              As of ${now}, your order has been <b>processed and shipped</b>.<br/><br/>

              Kind regards,<br/>

              TheCompany.
            </body>
          </html>
        ]]>
      </activiti:expression>
    </activiti:field>
  </extensionElements>
</serviceTask>

----

产生如下结果：

image::images/email.task.result.png[align="center"]


[[bpmnMuleTask]]


==== Mule任务 Mule Task


Mule任务可以向Mule发送消息，增强Activiti的集成特性。请注意Mule任务**不是**BPMN 2.0规范的“官方”任务（因此也没有专用图标）。因此，在Activiti中，Mule任务实现为一种特殊的服务任务。

[[bpmnMuleTaskUsage]]


===== 定义Mule任务 Defining an Mule Task

Mule任务实现为特殊的<<bpmnJavaServiceTask,服务任务>>，通过将服务任务的__type__定义为__'mule'__设置。

[source,xml,linenums]
----
<serviceTask id="sendMule" activiti:type="mule">
----

Mule任务通过<<serviceTaskFieldInjection,字段注入>>配置。这些参数的值可以使用EL表达式，将在流程执行运行时解析。可以设置下列参数：

[options="header"]
|===============
|参数|必填?|描述
|endpointUrl|是|希望调用的Mule端点（endpoint）。
|language|是|计算payloadExpression字段所用的语言。
|payloadExpression|是|消息的载荷表达式
|resultVariable|否|存储调用结果的变量名。

|===============

[[bpmnMuleTaskExampleUsage]]


===== 使用示例 Example usage

下面的XML代码片段展示了使用Mule任务的示例。

[source,xml,linenums]
----
<extensionElements>
  <activiti:field name="endpointUrl">
    <activiti:string>vm://in</activiti:string>
  </activiti:field>
  <activiti:field name="language">
    <activiti:string>juel</activiti:string>
  </activiti:field>
  <activiti:field name="payloadExpression">
    <activiti:string>"hi"</activiti:string>
  </activiti:field>
  <activiti:field name="resultVariable">
    <activiti:string>theVariable</activiti:string>
  </activiti:field>
</extensionElements>
----

[[bpmnCamelTask]]


==== Camel任务 Camel Task

Camel任务可以向Mule发送与接收消息，增强Activiti的集成特性。请注意Camel任务**不是**BPMN 2.0规范的“官方”任务（因此也没有专用图标）。因此，在Activiti中，Camel任务实现为一种特殊的服务任务。还请注意要使用Camel任务功能，需要在项目中包含Activiti Camel模块。

[[bpmnCamelTaskUsage]]


===== 定义Camel任务 Defining a Camel Task

Camel任务实现为特殊的<<bpmnJavaServiceTask,服务任务>>，通过将服务任务的__type__定义为__'camel'__设置。

[source,xml,linenums]
----
<serviceTask id="sendCamel" activiti:type="camel">
----

流程定义本身只需要在服务任务上定义Camel类型。集成逻辑都通过Camel容器代理。默认情况下Activiti引擎在Spring容器中查找camelContext bean。camelContext bean定义了由Camel容器装载的Camel路由。在下面的例子中，路由通过给定的Java包装载，但也可以自己直接在Spring配置中定义路由。

[source,xml,linenums]
----
<camelContext id="camelContext" xmlns="http://camel.apache.org/schema/spring">
  <packageScan>
    <package>org.activiti.camel.route</package>
  </packageScan>
</camelContext>
----

可以在link:$$http://camel.apache.org/$$[Camel网站]找到关于Camel路由的更多文档。这篇文档中只通过几个小例子展示基本概念。在第一个例子中，在Activiti工作流中进行最简单的Camel调用。叫做SimpleCamelCall。

如果想要定义多个Camel上下文bean，并且/或想使用不同的bean名字，可以在Camel任务定义中像这样覆盖：

[source,xml,linenums]
----
<serviceTask id="serviceTask1" activiti:type="camel">
  <extensionElements>
    <activiti:field name="camelContext" stringValue="customCamelContext" />
  </extensionElements>
</serviceTask>
----


[[bpmnCamelTaskSimpleCamelCall]]


===== 简单Camel调用示例 Simple Camel Call example

这个例子相关的所有文件，都可以在activiti-camel模块的org.activiti.camel.examples.simpleCamelCall包中找到。目的是简单启动一个camel路由。首先需要一个配置了上面提到的路由的Spring上下文。下面的代码用做这个目的：

[source,xml,linenums]
----
<camelContext id="camelContext" xmlns="http://camel.apache.org/schema/spring">
  <packageScan>
    <package>org.activiti.camel.examples.simpleCamelCall</package>
  </packageScan>
</camelContext>
----

[source,java,linenums]
----
public class SimpleCamelCallRoute extends RouteBuilder {

  @Override
  public void configure() throws Exception {
    from("activiti:SimpleCamelCallProcess:simpleCall").to("log:org.activiti.camel.examples.SimpleCamelCall");
  }
}
----

路由只是记录消息体，不做更多事情。请注意from端点的格式。包含三个部分：


[options="header"]
|===============
|端点Url组件|描述
|activiti|引用Activiti端点
|SimpleCamelCallProcess|流程名
|simpleCall|流程中Camel服务的名字

|===============

现在路由已经正确配置，可以访问Camel。下面需要像这样定义工作流：

[source,xml,linenums]
----
<process id="SimpleCamelCallProcess">
  <startEvent id="start"/>
  <sequenceFlow id="flow1" sourceRef="start" targetRef="simpleCall"/>

  <serviceTask id="simpleCall" activiti:type="camel"/>

  <sequenceFlow id="flow2" sourceRef="simpleCall" targetRef="end"/>
  <endEvent id="end"/>
</process>
----


[[bpmnCamelTaskPingPong]]


===== 连通性测试 Ping Pong example

示例已经可以工作，但实际上Camel与Activiti之间并没有通信，因此没有太多价值。在这个例子里，将试着从Camel接收与发送消息。将发送一个字符串，Camel在其上连接一些东西，并返回作为结果。发送部分比较普通，以变量的格式将信息发送给Camel服务。这是我们的调用代码：

[source,java,linenums]
----
@Deployment
public void testPingPong() {
  Map<String, Object> variables = new HashMap<String, Object>();

  variables.put("input", "Hello");
  Map<String, String> outputMap = new HashMap<String, String>();
  variables.put("outputMap", outputMap);

  runtimeService.startProcessInstanceByKey("PingPongProcess", variables);
  assertEquals(1, outputMap.size());
  assertNotNull(outputMap.get("outputValue"));
  assertEquals("Hello World", outputMap.get("outputValue"));
}
----

“input”变量是实际上是Camel路由的输入，而outputMap用于捕获Camel传回的结果。流程像是这样：

[source,xml,linenums]
----
<process id="PingPongProcess">
  <startEvent id="start"/>
  <sequenceFlow id="flow1" sourceRef="start" targetRef="ping"/>
  <serviceTask id="ping" activiti:type="camel"/>
  <sequenceFlow id="flow2" sourceRef="ping" targetRef="saveOutput"/>
  <serviceTask id="saveOutput"  activiti:class="org.activiti.camel.examples.pingPong.SaveOutput" />
  <sequenceFlow id="flow3" sourceRef="saveOutput" targetRef="end"/>
  <endEvent id="end"/>
</process>

----

请注意SaveOutput服务任务，将“Output”变量从上下文中取出，存储至上面提到的OutputMap。现在需要了解变量如何发送至Camel，以及如何返回。这就需要了解Camel行为的概念。变量与Camel通信的方式可以通过CamelBehavior配置。在这个例子里使用默认配置，其它配置在后面会进行简短介绍。下面的代码配置了期望的Camel行为：

[source,xml,linenums]
----
<serviceTask id="serviceTask1" activiti:type="camel">
  <extensionElements>
    <activiti:field name="camelBehaviorClass" stringValue="org.activiti.camel.impl.CamelBehaviorCamelBodyImpl" />
  </extensionElements>
</serviceTask>
----

如果不指定行为，则会设置为org.activiti.camel.impl.CamelBehaviorDefaultImpl。这个行为将以相同名字，将变量复制到Camel参数。对于返回值，无论选择什么行为，如果Camel消息体是一个map，则其中的每个元素都将复制为变量，否则整个对象将复制为名为"camelBody"的特定变量。了解这些后，Camel路由总结为第二个例子：

[source,java,linenums]
----
@Override
public void configure() throws Exception {
  from("activiti:PingPongProcess:ping").transform().simple("${property.input} World");
}
----

在这个路由中，字符串"world"会在结尾连接上名为“input”的参数，结果作为消息体。可以通过Java服务任务检查"camelBody"变量，并复制到“outputMap”，并可通过测试用例检查。既然这个例子使用默认行为，就让我们看看还有什么其他选择。在每个Camel路由的开始处，流程实例id会复制为名为"PROCESS_ID_PROPERTY"的Camel参数。之后会用于将流程实例与Camel路由相关联，也可以在Camel路由中使用。

Activiti中有已经可以使用三种不同的行为。可以通过修改路由URL中特定的部分，覆写行为。这里有个在URL中重载已有行为的例子：

[source,java,linenums]
----
from("activiti:asyncCamelProcess:serviceTaskAsync2?copyVariablesToProperties=true").

----

下表展示了三种可用的Camel行为：

[options="header"]
|===============
|行为|Url中|描述
|CamelBehaviorDefaultImpl|copyVariablesToProperties|将Activiti变量复制为Camel参数
|CamelBehaviorCamelBodyImpl|copyCamelBodyToBody|只将名为"camelBody"的Activiti变量复制为Camel消息体
|CamelBehaviorBodyAsMapImpl|copyVariablesToBodyAsMap|将一个map中的所有Activiti变量复制为Camel消息体

|===============

上表解释了Activiti变量如何传递给Camel。下表解释了Camel变量如何返回至Activiti。只能在路由URL中配置。

[options="header"]
|===============
|Url|描述
|Default|如果Camel消息体是一个map，则将其中每一对象复制为Activiti变量；否则将整个Camel消息体复制为"camelBody" Activiti变量
|copyVariablesFromProperties|将Camel参数以同名复制为Activiti变量
|copyCamelBodyToBodyAsString|与default相同，但如果Camel消息体不是map，则首先将其转换为字符串，然后再复制为"camelBody"
|copyVariablesFromHeader|额外将Camel头复制为Activiti的同名变量

|===============

===== 返回变量 Returning back the variables

上面提到的传递变量，不论是从Camel到Activiti还是反过来，都只用于变量传递的开始侧。要特别注意，由于Activiti的非阻塞行为，Activiti不会自动向Camel返回变量。因此，提供了特殊的语法。可以在Camel路由URL中，以++var.return.someVariableName++的格式，使用一个或多个参数。与这些参数同名，但没有++var.return++部分的变量，会被认为是输出变量，因此将会以相同的名字复制回Camel参数。例如在如下路由中：

----
from("direct:start").to("activiti:process?var.return.exampleVar").to("mock:result");
----

名为++exampleVar++的Activiti变量，将被认为是输出变量，因此会以同名复制回Camel参数。


[[bpmnCamelTaskAsyncPingPong]]


===== 异步连通性测试 Asynchronous Ping Pong example

上面的例子都是同步的。工作流停止，直到Camel路由结束并返回。有时，需要Activiti工作流继续运行。为了这个目的，Camel服务任务的异步功能就很有用。可以通过将Camel服务任务的异步参数设置为true，启用这个功能。

[source,xml,linenums]
----
<serviceTask id="serviceAsyncPing" activiti:type="camel" activiti:async="true"/>
----

设置这个特性后，Camel路由会由Activiti作业执行器异步启动。如果定义了Camel路由队列，Activiti流程会继续执行Camel服务任务之后的活动。Camel路由会与流程执行完全异步地执行。如果需要在流程定义的某处等待Camel服务任务的响应，可以使用接收任务（receive task）。

[source,xml,linenums]
----
<receiveTask id="receiveAsyncPing" name="Wait State" />
----

流程实例会等待，直到接收到信号，例如来自Camel。在Camel中，可以通过向合适的Activiti端点发送消息，来为流程实例发送信号。

[source,java,linenums]
----
 from("activiti:asyncPingProcess:serviceAsyncPing").to("activiti:asyncPingProcess:receiveAsyncPing");
----

（译者注：原文如此。可能为缺失了的 to 端点的定义：）

* “activiti”字符串常量
* 流程名
* 接收任务名


[[bpmnCamelTaskAsyncPingPong]]


===== 从Camel路由实例化工作流 Instantiate workflow from Camel route

上面的所有例子，都是先启动Activiti工作流，然后在工作流中启动Camel路由。也可以反过来。可以在已经启动的Camel路由中实例化工作流。与为接收任务发送消息很类似，除了最后一部分。这是一个简单的路由：

[source,java,linenums]
----
from("direct:start").to("activiti:camelProcess");
----

可以看到url有两部分，第一部分是“activiti”字符串常量，第二个名字是流程的名字。很明显流程需要已经部署，并且可以通过引擎配置启动。

也可以在Camel头中，将流程起动人设置为某个已认证用户id。要这么做，首先需要在流程定义中指定启动人变量：

[source,xml,linenums]
----
<startEvent id="start" activiti:initiator="initiator" />
----

然后在Camel头中的__CamelProcessInitiatorHeader__指定用户id。Camel路由会如下定义：

[source,java,linenums]
----
from("direct:startWithInitiatorHeader")
    .setHeader("CamelProcessInitiatorHeader", constant("kermit"))
    .to("activiti:InitiatorCamelCallProcess?processInitiatorHeaderName=CamelProcessInitiatorHeader");
----


[[bpmnManualTask]]


==== 手动任务 Manual Task

[[bpmnManualTaskDescription]]


===== 描述 Description

A _Manual Task_ defines a task that is external to the BPM engine. It is used to model work that is done by somebody, which the engine does not need to know of, nor is there a system or UI interface. For the engine, a manual task is handled as a *pass-through activity*, automatically continuing the process from the moment process execution arrives into it.


[[bpmnManualTaskGraphicalNotation]]


===== Graphical Notation

A manual task is visualized as a rounded rectangle, with a little 'hand' icon in the upper left corner

image::images/bpmn.manual.task.png[align="center"]



[[bpmnManualTaskXml]]


===== XML representation

[source,xml,linenums]
----
<manualTask id="myManualTask" name="Call client for more information" />
----


[[bpmnReceiveTask]]


==== Java Receive Task

[[bpmnReceiveTaskDescription]]


===== Description


A Receive Task is a simple task that waits for the arrival of a certain message. Currently, we have only implemented Java semantics for this task. When process execution arrives at a Receive Task, the process state is committed to the persistence store. This means that the process will stay in this wait state, until a specific message is received by the engine, which triggers the continuation of the process past the Receive Task.


===== Graphical notation

A Receive Task is visualized as a task (rounded rectangle) with a message icon in the top left corner. The message is white (a black message icon would have send semantics)

image::images/bpmn.receive.task.png[align="center"]


===== XML representation

[source,xml,linenums]
----
<receiveTask id="waitState" name="wait" />
----

To continue a process instance that is currently waiting at such a Receive Task, the _runtimeService.signal(executionId)_ must be called using the id of the execution that arrived in the Receive Task. The following code snippet shows how this works in practice:

[source,java,linenums]
----
ProcessInstance pi = runtimeService.startProcessInstanceByKey("receiveTask");
Execution execution = runtimeService.createExecutionQuery()
  .processInstanceId(pi.getId())
  .activityId("waitState")
  .singleResult();
assertNotNull(execution);

runtimeService.signal(execution.getId());
----


[[bpmnShellTask]]


==== Shell Task

[[bpmnShellTaskDescription]]


===== Description

The shell task allows to run shell scripts and commands. Note that the Shell task is *not* an 'official' task of BPMN 2.0 spec (and it does not have a dedicated icon as a consequence).


[[bpmnShellTaskUsage]]


===== Defining a shell task

The shell task is implemented as a dedicated <<bpmnJavaServiceTask,Service Task>> and is defined by setting _'shell'_ for the _type_ of the service task.

[source,xml,linenums]
----
<serviceTask id="shellEcho" activiti:type="shell">
----

The Shell task is configured by <<serviceTaskFieldInjection,field injection>>. All the values for these properties can contain EL expression, which are resolved at runtime during process execution. Following properties could be set:

[options="header"]
|===============
|Property|Required?|Type|Description|Default
|command|yes|String|Shell command to execute.|
|arg0-5|no|String|Parameter 0 to Parameter 5|
|wait|no|true/false|wait if necessary, until the shell process has terminated.|true
|redirectError|no|true/false|Merge standard error with the standard output.|false
|cleanEnv|no|true/false|Shell process does not inherit current environment.|false
|outputVariable|no|String|Name of variable to contain the output|Output is not recorded.
|errorCodeVariable|no|String|Name of variable to contain result error code|Error level is not registered.
|directory|no|String|Default directory of shell process|Current directory

|===============



[[bpmnShellTaskExampleUsage]]


===== Example usage

The following XML snippet shows an example of using the shell Task. It runs shell script "cmd /c echo EchoTest", waits for it to be terminated and puts the result in resultVar

[source,xml,linenums]
----
<serviceTask id="shellEcho" activiti:type="shell" >
  <extensionElements>
    <activiti:field name="command" stringValue="cmd" />
    <activiti:field name="arg1" stringValue="/c" />
    <activiti:field name="arg2" stringValue="echo" />
    <activiti:field name="arg3" stringValue="EchoTest" />
    <activiti:field name="wait" stringValue="true" />
    <activiti:field name="outputVariable" stringValue="resultVar" />
  </extensionElements>
</serviceTask>

----


[[executionListeners]]


==== Execution listener

*Compatibility note*: After releasing 5.3, we discovered that execution listeners and task listeners and expressions were still in non-public API. Those classes were in subpackages of +org.activiti.engine.impl...+,  which has +impl+ in it). +org.activiti.engine.impl.pvm.delegate.ExecutionListener+, +org.activiti.engine.impl.pvm.delegate.TaskListener+ and +org.activiti.engine.impl.pvm.el.Expression+ have been deprecated. From now on, you should use +org.activiti.engine.delegate.ExecutionListener+, +org.activiti.engine.delegate.TaskListener+ and +org.activiti.engine.delegate.Expression+. In the new publicly available API, access to +ExecutionListenerExecution.getEventSource()+ has been removed.  Apart from the deprecation compiler warning, the existing code should run fine.  But consider switching to the new public API interfaces (without .impl. in the package name).

Execution listeners allow you to execute external Java code or evaluate an expression when certain events occur during process execution. The events that can be captured are:

* Start and ending of a process instance.
* Taking a transition.
* Start and ending of an activity.
* Start and ending of a gateway.
* Start and ending of intermediate events.
* Ending a start event or starting an end event.

The following process definition contains 3 execution listeners:

[source,xml,linenums]
----
<process id="executionListenersProcess">

  <extensionElements>
    <activiti:executionListener class="org.activiti.examples.bpmn.executionlistener.ExampleExecutionListenerOne" event="start" />
  </extensionElements>

  <startEvent id="theStart" />
  <sequenceFlow sourceRef="theStart" targetRef="firstTask" />

  <userTask id="firstTask" />
  <sequenceFlow sourceRef="firstTask" targetRef="secondTask">
    <extensionElements>
      <activiti:executionListener class="org.activiti.examples.bpmn.executionListener.ExampleExecutionListenerTwo" />
    </extensionElements>
  </sequenceFlow>

  <userTask id="secondTask" >
    <extensionElements>
      <activiti:executionListener expression="${myPojo.myMethod(execution.event)}" event="end" />
    </extensionElements>
  </userTask>
  <sequenceFlow sourceRef="secondTask" targetRef="thirdTask" />

  <userTask id="thirdTask" />
  <sequenceFlow sourceRef="thirdTask" targetRef="theEnd" />

  <endEvent id="theEnd" />

</process>
----


The first execution listener is notified when the process starts. The listener is an external Java-class (like ++ExampleExecutionListenerOne++) and should implement +org.activiti.engine.delegate.ExecutionListener+ interface. When the event occurs (in this case +end+ event) the method +notify(ExecutionListenerExecution execution)+ is called.

[source,java,linenums]
----
public class ExampleExecutionListenerOne implements ExecutionListener {

  public void notify(ExecutionListenerExecution execution) throws Exception {
    execution.setVariable("variableSetInExecutionListener", "firstValue");
    execution.setVariable("eventReceived", execution.getEventName());
  }
}
----

It is also possible to use a delegation class that implements the +org.activiti.engine.delegate.JavaDelegate+ interface. These delegation classes can then be reused in other constructs, such as a delegation for a serviceTask.

The second execution listener is called when the transition is taken. Note that the +listener+ element doesn't define an +event+, since only +take+ events are fired on transitions. *Values in the +event+ attribute are ignored when a listener is defined on a transition.*

The last execution listener is called when activity +secondTask+ ends. Instead of using the +class+ on the listener declaration, a +expression+ is defined instead which is evaluated/invoked when the event is fired.

[source,xml,linenums]
----
<activiti:executionListener expression="${myPojo.myMethod(execution.eventName)}" event="end" />
----

As with other expressions, execution variables are resolved and can be used. Because the execution implementation object has a property that exposes the event name, it's possible to pass the event-name to your methods using +execution.eventName+.

Execution listeners also support using a +delegateExpression+, <<bpmnJavaServiceTaskXML,similar to a service task>>.

[source,xml,linenums]
----
<activiti:executionListener event="start" delegateExpression="${myExecutionListenerBean}" />
----


In Activiti 5.12 we also introduced a new type of execution listener, the org.activiti.engine.impl.bpmn.listener.ScriptExecutionListener. This script execution listener allows you to execute a piece of script logic for an execution listener event.

[source,xml,linenums]
----
<activiti:executionListener event="start" class="org.activiti.engine.impl.bpmn.listener.ScriptExecutionListener" >
  <activiti:field name="script">
    <activiti:string>
      def bar = "BAR";  // local variable
      foo = "FOO"; // pushes variable to execution context
      execution.setVariable("var1", "test"); // test access to execution instance
      bar // implicit return value
    </activiti:string>
  </activiti:field>
  <activiti:field name="language" stringValue="groovy" />
  <activiti:field name="resultVariable" stringValue="myVar" />
<activiti:executionListener>
----


[[executionListenerFieldInjection]]


===== Field injection on execution listeners

When using an execution listener that is configured with the +class+ attribute, field injection can be applied. This is exactly the same mechanism as used <<serviceTaskFieldInjection,Service task field injection>>, which contains an overview of the possibilities provided by field injection.

The fragment below shows a simple example process with an execution listener with fields injected.

[source,xml,linenums]
----
<process id="executionListenersProcess">
  <extensionElements>
    <activiti:executionListener class="org.activiti.examples.bpmn.executionListener.ExampleFieldInjectedExecutionListener" event="start">
      <activiti:field name="fixedValue" stringValue="Yes, I am " />
      <activiti:field name="dynamicValue" expression="${myVar}" />
    </activiti:executionListener>
  </extensionElements>

  <startEvent id="theStart" />
  <sequenceFlow sourceRef="theStart" targetRef="firstTask" />

  <userTask id="firstTask" />
  <sequenceFlow sourceRef="firstTask" targetRef="theEnd" />

  <endEvent id="theEnd" />
</process>
----

[source,java,linenums]
----
public class ExampleFieldInjectedExecutionListener implements ExecutionListener {

  private Expression fixedValue;

  private Expression dynamicValue;

  public void notify(ExecutionListenerExecution execution) throws Exception {
    execution.setVariable("var", fixedValue.getValue(execution).toString() + dynamicValue.getValue(execution).toString());
  }
}
----

The class +ExampleFieldInjectedExecutionListener+ concatenates the 2 injected fields (one fixed an the other dynamic) and stores this in the process variable '++var++'.

[source,java,linenums]
----
@Deployment(resources = {"org/activiti/examples/bpmn/executionListener/ExecutionListenersFieldInjectionProcess.bpmn20.xml"})
public void testExecutionListenerFieldInjection() {
  Map<String, Object> variables = new HashMap<String, Object>();
  variables.put("myVar", "listening!");

  ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("executionListenersProcess", variables);

  Object varSetByListener = runtimeService.getVariable(processInstance.getId(), "var");
  assertNotNull(varSetByListener);
  assertTrue(varSetByListener instanceof String);

  // Result is a concatenation of fixed injected field and injected expression
  assertEquals("Yes, I am listening!", varSetByListener);
}
----

Note that the same rules with regards to thread-safety apply as for service task. Please read the <<serviceTaskFieldInjectionThreadSafety, relevant section>> for more information.

[[taskListeners]]


==== Task listener

A _task listener_ is used to execute custom Java logic or an expression upon the occurrence of a certain task-related event.

A task listener can only be added in the process definition as a child element of a <<bpmnUserTask,user task>>. Note that this also must happen as a child of the _BPMN 2.0 extensionElements_ and in the _activiti_ namespace, since a task listener is an Activiti-specific construct.


[source,xml,linenums]
----
<userTask id="myTask" name="My Task" >
  <extensionElements>
    <activiti:taskListener event="create" class="org.activiti.MyTaskCreateListener" />
  </extensionElements>
</userTask>
----

A _task listener_ supports following attributes:

* *event* (required): the type of task event on which the task listener will be invoked. Possible events are
** *create*: occurs when the task has been created an *all task properties are set*.
** *assignment*: occurs when the task is assigned to somebody. Note: when process execution arrives in a userTask, first an _assignment_ event will be fired, *before* the _create_ event is fired. This might seem an unnatural order, but the reason is pragmatic: when receiving the _create_ event, we usually want to inspect all properties of the task including the assignee.
** *complete*: occurs when the task is completed and just before the task is deleted from the runtime data.
** *delete*: occurs just before the task is going to be deleted. Notice that it will also be executed when task is normally finished via completeTask.
* *class*: the delegation class that must be called. This class must implement the +org.activiti.engine.delegate.TaskListener+ interface.

[source,java,linenums]
----
public class MyTaskCreateListener implements TaskListener {

  public void notify(DelegateTask delegateTask) {
    // Custom logic goes here
  }

}
----

It is also possible to use <<serviceTaskFieldInjection,field injection>> to pass process variables or the execution to the delegation class. Note that an instance of the delegation class is created upon process deployment (as is the case with any class delegation in Activiti), which means that the instance is shared between all process instance executions.

* *expression*: (cannot be used together with the _class_ attribute): specifies an expression that will be executed when the event happens. It is possible to pass the +DelegateTask+ object and the name of the event (using ++task.eventName++) as parameter to the called object.

[source,java,linenums]
----
<activiti:taskListener event="create" expression="${myObject.callMethod(task, task.eventName)}" />
----

* *delegateExpression* allows to specify an expression that resolves to an object implementing the +TaskListener+ interface, <<bpmnJavaServiceTaskXML,similar to a service task>>.

[source,xml,linenums]
----
<activiti:taskListener event="create" delegateExpression="${myTaskListenerBean}" />
----

* In Activiti 5.12 we also introduced a new type of task listener, the org.activiti.engine.impl.bpmn.listener.ScriptTaskListener. This script task listener allows you to execute a piece of script logic for an task listener event.

[source,xml,linenums]
----
<activiti:taskListener event="complete" class="org.activiti.engine.impl.bpmn.listener.ScriptTaskListener" >
  <activiti:field name="script">
    <activiti:string>
      def bar = "BAR";  // local variable
      foo = "FOO"; // pushes variable to execution context
      task.setOwner("kermit"); // test access to task instance
      bar // implicit return value
    </activiti:string>
  </activiti:field>
  <activiti:field name="language" stringValue="groovy" />
  <activiti:field name="resultVariable" stringValue="myVar" />
<activiti:taskListener>
----


[[bpmnMultiInstance]]


==== Multi-instance (for each)

[[bpmnMultiInstanceDescription]]


===== Description


A _multi-instance activity_ is a way of defining repetition for a certain step in a business process. In programming concepts, a multi-instance matches the *for each* construct: it allows to execute a certain step or even a complete subprocess for each item in a given collection, *sequentially or in parallel*.

A _multi-instance_ is a regular activity that has extra properties defined (so-called _'multi-instance_ characteristics'') which will cause the activity to be executed multiple times at runtime. Following activities can become a _multi-instance activity:_

* <<bpmnUserTask,User Task>>
* <<bpmnScriptTask,Script Task>>
* <<bpmnJavaServiceTask,Java Service Task>>
* <<bpmnWebserviceTask,Web Service Task>>
* <<bpmnBusinessRuleTask,Business Rule Task>>
* <<bpmnEmailTask,Email Task>>
* <<bpmnManualTask,Manual Task>>
* <<bpmnReceiveTask,Receive Task>>
* <<bpmnSubProcess,(Embedded) Sub-Process>>
* <<bpmnCallActivity,Call Activity>>

A <<bpmnGateways,Gateway>> or <<bpmnEvents,Event>> *cannot* become multi-instance.

As required by the spec, each parent execution of the created executions for each instance will have following variables:

* *nrOfInstances*: the total number of instances
* *nrOfActiveInstances*: the number of currently active, i.e. not yet finished, instances. For a sequential multi-instance, this will always be 1.
* *nrOfCompletedInstances*: the number of already completed instances.

These values can be retrieved by calling the +execution.getVariable(x)+ method.

Additionally, each of the created executions will have an execution-local variable (i.e. not visible for the other executions, and not stored on process instance level) :

* *loopCounter*: indicates the _index in the for-each loop_ of that particular instance. loopCounter variable can be renamed by Activiti *elementIndexVariable* attribute.


[[bpmnMultiInstanceGraphicalNotation]]


===== Graphical notation

If an activity is multi-instance, this is indicated by three short lines at the bottom of that activity. Three _vertical_ lines indicates that the instances will be executed in parallel, while three _horizontal_ lines indicate sequential execution.

image::images/bpmn.multi.instance.png[align="center"]



[[bpmnMultiInstanceXml]]


===== Xml representation

To make an activity multi-instance, the activity xml element must have a +multiInstanceLoopCharacteristics+ child element.

[source,xml,linenums]
----
<multiInstanceLoopCharacteristics isSequential="false|true">
 ...
</multiInstanceLoopCharacteristics>
----

The *isSequential* attribute indicates if the instances of that activity are executed sequentially or parallel.

The number of instances are *calculated once, when entering the activity*. There are a few ways of configuring this. On way is directly specifying a number, by using the *loopCardinality* child element.

[source,xml,linenums]
----
<multiInstanceLoopCharacteristics isSequential="false|true">
  <loopCardinality>5</loopCardinality>
</multiInstanceLoopCharacteristics>
----

Expressions that resolve to a positive number are also possible:

[source,xml,linenums]
----
<multiInstanceLoopCharacteristics isSequential="false|true">
  <loopCardinality>${nrOfOrders-nrOfCancellations}</loopCardinality>
</multiInstanceLoopCharacteristics>
----

Another way to define the number of instances, is to specify the name of a process variable which is a collection using the +loopDataInputRef+ child element. For each item in the collection, an instance will be created. Optionally, it is possible to set that specific item of the collection for the instance using the +inputDataItem+ child element. This is shown in the following XML example:

[source,xml,linenums]
----
<userTask id="miTasks" name="My Task ${loopCounter}" activiti:assignee="${assignee}">
  <multiInstanceLoopCharacteristics isSequential="false">
    <loopDataInputRef>assigneeList</loopDataInputRef>
    <inputDataItem name="assignee" />
  </multiInstanceLoopCharacteristics>
</userTask>
----

Suppose the variable +assigneeList+ contains the values +\[kermit, gonzo, fozzie\]+. In the snippet above, three user tasks will be created in parallel. Each of the executions will have a process variable named +assignee+ containing one value of the collection, which is used to assign the user task in this example.

The downside of the +loopDataInputRef+ and +inputDataItem+ is that 1) the names are pretty hard to remember and 2) due to the BPMN 2.0 schema restrictions they can't contain expressions. Activiti solves this by offering the *collection* and *elementVariable* attributes on the ++multiInstanceCharacteristics++:

[source,xml,linenums]
----
<userTask id="miTasks" name="My Task" activiti:assignee="${assignee}">
  <multiInstanceLoopCharacteristics isSequential="true"
     activiti:collection="${myService.resolveUsersForTask()}" activiti:elementVariable="assignee" >
  </multiInstanceLoopCharacteristics>
</userTask>
----

A multi-instance activity ends when all instances are finished. However, it is possible to specify an expression that is evaluated every time one instance ends. When this expression evaluates to true, all remaining instances are destroyed and the multi-instance activity ends, continuing the process. Such an expression must be defined in the *completionCondition* child element.

[source,xml,linenums]
----
<userTask id="miTasks" name="My Task" activiti:assignee="${assignee}">
  <multiInstanceLoopCharacteristics isSequential="false"
     activiti:collection="assigneeList" activiti:elementVariable="assignee" >
    <completionCondition>${nrOfCompletedInstances/nrOfInstances >= 0.6 }</completionCondition>
  </multiInstanceLoopCharacteristics>
</userTask>
----

In this example, there will be parallel instances created for each element of the +assigneeList+ collection. However, when 60% of the tasks are completed, the other tasks are deleted and the process continues.


[[bpmnMultiInstanceBoundaryEvent]]


===== Boundary events and multi-instance

Since a multi-instance is a regular activity, it is possible to define a <<bpmnBoundaryEvent,boundary event>> on its boundary. In case of an interrupting boundary event, when the event is caught, *all instances* that are still active will be destroyed. Take for example following multi-instance subprocess:

image::images/bpmn.multi.instance.boundary.event.png[align="center"]

Here, all instances of the subprocess will be destroyed when the timer fires, regardless of how many instances there are or which inner activities are currently not yet completed.


[[bpmnCompensationHandlers]]

===== Multi instance and execution listeners

(Valid for Activiti 5.18 and up)

There is a caveat when using execution listeners in combination with multi instance. Take for example the following snippet of BPMN 2.0 xml, which is defined on the same level as the _multiInstanceLoopCharacteristics_ xml element is set:

[source,xml,linenums]
----
<extensionElements>
    <activiti:executionListener event="start" class="org.activiti.MyStartListener"/>
		<activiti:executionListener event="end" class="org.activiti.MyEndListener"/>
</extensionElements>
----

For a normal BPMN activity, there would be an invocation of these listeners when the activity is started and ended.

However, when the activity is multi instance, the behavior is different:

* When the multi instance activity is entered, before any of the _inner_ activities is executed, a start event is thrown. The _loopCounter_ variable is not yet set (is null).
* For each of the actual activities visited, a start event is thrown. The _loopCounter_ variable is set.

The same reasoning applies for the end event:

* When the actual activity is left, an end even is thrown. The _loopCounter_ variable is set.
* When the multi instance activity has finished as a whole, an end event is thrown. The _loopCounter_ variable is not set.

For example:

[source,xml,linenums]
----
<subProcess id="subprocess1" name="Sub Process">
  <extensionElements>
    <activiti:executionListener event="start" class="org.activiti.MyStartListener"/>
    <activiti:executionListener event="end" class="org.activiti.MyEndListener"/>
  </extensionElements>
  <multiInstanceLoopCharacteristics isSequential="false">
    <loopDataInputRef>assignees</loopDataInputRef>
    <inputDataItem name="assignee"></inputDataItem>
  </multiInstanceLoopCharacteristics>
  <startEvent id="startevent2" name="Start"></startEvent>
  <endEvent id="endevent2" name="End"></endEvent>
  <sequenceFlow id="flow3" name="" sourceRef="startevent2" targetRef="endevent2"></sequenceFlow>
</subProcess>
----

In this example, suppose the _assignees_ list has three items. The following happens at runtime:

* A start event is thrown for the multi instance as a whole. The _start_ execution listener is invoked. The _loopCounter_ nor the _assignee_ variable will not be set (i.e. they will be null).
* A start event is thrown for each activity instance. The _start_ execution listener is invoked three times. The _loopCounter_ nor the _assignee_ variable will be set (i.e. different from null).
* So in total, the start execution listener is invoked four times.

Note that the same applies when the _multiInstanceLoopCharacteristics_ are defined on something else than a subprocess too. For example in case the example above would be a simple userTask, the same reasoning still applies.



==== Compensation Handlers

[[bpmnCompensationHandlerDescription]]


===== Description

<<experimental,[EXPERIMENTAL]>>

If an activity is used for compensating the effects of another activity, it can be declared to be a compensation handler. Compensation handlers are not contained in normal flow and are only executed when a compensation event is thrown.

Compensation handlers must not have incoming or outgoing sequence flows.

A compensation handler must be associated with a compensation boundary event using a directed association.


[[bpmnCompensationHandlerGraphicalNotation]]


===== Graphical notation

If an activity is a compensation handler, the compensation event icon is displayed in the center bottom area. The following excerpt from a process diagram shows a service task with an attached compensation boundary event which is associated to a compensation handler. Notice the compensation handler icon in the bottom canter area of the "cancel hotel reservation" service task.

image::images/bpmn.boundary.compensation.event.png[align="center"]


[[bpmnCompensationHandlerXml]]


===== XML representation

In order to declare an activity to be a compensation handler, we need to set the attribute isForCompensation to true:

[source,xml,linenums]
----
<serviceTask id="undoBookHotel" isForCompensation="true" activiti:class="...">
</serviceTask>
----

[[bpmnSubprocessAndCallActivity]]


=== Sub-Processes and Call Activities

[[bpmnSubProcess]]


==== Sub-Process

[[bpmnSubProcessDescription]]


===== Description


A _Sub-Process_ is an activity that contains other activities, gateways, events, etc. which on itself form a process that is part of the bigger process. A _Sub-Process_ is completely defined inside a parent process (that's why it's often called an _embedded_ Sub-Process).

Sub-Processes have two major use cases:

* Sub-Processes allow *hierarchical modeling*. Many modeling tools allow that Sub-Processes can be _collapsed_, hiding all the details of the Sub-Process and displaying a high-level end-to-end overview of the business process.
* A Sub-Process creates a new *scope for events*. Events that are thrown during execution of the Sub-Process, can be caught by <<bpmnBoundaryEvent,a boundary event>> on the boundary of the Sub-Process, thus creating a scope for that event limited to the Sub-Process.

Using a Sub-Process does impose some constraints:

* A Sub-Process can only have *one none start event*, no other start event types are allowed. A Sub-Process must *at least have one end event*. Note that the BPMN 2.0 specification allows to omit the start and end events in a Sub-Process, but the current Activiti implementation does not support this.
* *Sequence flow cannot cross Sub-Process boundaries.*


[[bpmnSubProcessGraphicalNotation]]


===== Graphical Notation

A Sub-Process is visualized as a typical activity, i.e. a rounded rectangle. In case the Sub-Process is _collapsed_, only the name and a plus-sign are displayed, giving a high-level overview of the process:

image::images/bpmn.collapsed.subprocess.png[align="center"]

In case the Sub-Process is _expanded_, the steps of the Sub-Process are displayed within the Sub-Process boundaries:

image::images/bpmn.expanded.subprocess.png[align="center"]

One of the main reasons to use a Sub-Process, is to define a scope for a certain event. The following process model shows this: both the _investigate software/investigate hardware_ tasks need to be done in parallel, but both tasks need to be done within a certain time, before _Level 2 support_ is consulted. Here, the scope of the timer (i.e. which activities must be done in time) is constrained by the Sub-Process.

image::images/bpmn.subprocess.with.boundary.timer.png[align="center"]


[[bpmnSubProcessXML]]


===== XML representation

A Sub-Process is defined by the _subprocess_ element. All activities, gateways, events, etc. that are part of the Sub-Process, need to be enclosed within this element.

[source,xml,linenums]
----
<subProcess id="subProcess">

  <startEvent id="subProcessStart" />

  ... other Sub-Process elements ...

  <endEvent id="subProcessEnd" />

 </subProcess>
----


[[bpmnEventSubprocess]]


==== Event Sub-Process

[[bpmnEventSubprocessDescription]]


===== Description


The Event Sub-Process is new in BPMN 2.0. An Event Sub-Process is a subprocess that is triggered by an event. An Event Sub-Process can be added at the process level or at any subprocess level. The event used to trigger an event subprocess is configured using a start event. From this, it follows that none start events are not supported for Event Sub-Processes. An Event Sub-Process might be triggered using events like message events, error events, signal events, timer events, or compensation events. The subscription to the start event is created when the scope (process instance or subprocess) hosting the Event Sub-Process is created. The subscription is removed when the scope is destroyed.

An Event Sub-Process may be interrupting or non-interrupting. An interrupting subprocess cancels any executions in the current scope. A non-interrupting Event Sub-Process spawns a new concurrent execution. While an interrupting Event Sub-Process can only be triggered once for each activation of the scope hosting it, a non-interrupting Event Sub-Process can be triggered multiple times. The fact whether the subprocess is interrupting is configured using the start event triggering the Event Sub-Process.

An Event Sub-Process must not have any incoming or outgoing sequence flows. Since an Event Sub-Process is triggered by an event, an incoming sequence flow makes no sense. When an Event Sub-Process is ended, either the current scope is ended (in case of an interrupting Event Sub-Process), or the concurrent execution spawned for the non-interrupting subprocess is ended.

*Current limitations:*

* Activiti only supports interrupting Event Sub-Processes.
* Activiti only supports Event Sub-Process triggered using an Error Start Event or Message Start Event.


[[bpmnEventSubprocessGraphicalNotation]]


===== Graphical Notation

An Event Sub-Process might be visualized as a an <<bpmnSubProcessGraphicalNotation,embedded subprocess>> with a dotted outline.

image::images/bpmn.subprocess.eventSubprocess.png[align="center"]


[[bpmnEventSubprocessXMLRepresentation]]


===== XML representation

An Event Sub-Process is represented using XML in the same way as a an embedded subprocess. In addition the attribute +triggeredByEvent+ must have the value ++true++:

[source,xml,linenums]
----
<subProcess id="eventSubProcess" triggeredByEvent="true">
	...
</subProcess>
----


[[bpmnEventSubprocessExample]]


===== Example

The following is an example of an Event Sub-Process triggered using an Error Start Event. The Event Sub-Process is located at the "process level", i.e. is scoped to the process instance:

image::images/bpmn.subprocess.eventSubprocess.example.1.png[align="center"]

This is how the Event Sub-Process would look like in XML:

[source,xml,linenums]
----
<subProcess id="eventSubProcess" triggeredByEvent="true">
	<startEvent id="catchError">
		<errorEventDefinition errorRef="error" />
	</startEvent>
	<sequenceFlow id="flow2" sourceRef="catchError" targetRef="taskAfterErrorCatch" />
	<userTask id="taskAfterErrorCatch" name="Provide additional data" />
</subProcess>
----

As already stated, an Event Sub-Process can also be added to an embedded subprocess. If it is added to an embedded subprocess, it becomes an alternative to a boundary event. Consider the two following process diagrams. In both cases the embedded subprocess throws an error event. Both times the error is caught and handled using a user task.

image::images/bpmn.subprocess.eventSubprocess.example.2a.png[align="center"]

as opposed to:

image::images/bpmn.subprocess.eventSubprocess.example.2b.png[align="center"]

In both cases the same tasks are executed. However, there are differences between both modelling alternatives:

* The embedded subprocess is executed using the same execution which executed the scope it is hosted in. This means that an embedded subprocess has access to the variables local to it's scope. When using a boundary event, the execution created for executing the embedded subprocess is deleted by the sequence flow leaving the boundary event. This means that the variables created by the embedded subprocess are not available anymore.
* When using an Event Sub-Process, the event is completely handled by the subprocess it is added to. When using a boundary event, the event is handled by the parent process.

These two differences can help you decide whether a boundary event or an embedded subprocess is better suited for solving a particular process modeling / implementation problem.


[[bpmnTransactionSubprocess]]


==== Transaction subprocess

<<experimental,[EXPERIMENTAL]>>[[bpmnTransactionSubprocessDescription]]


===== Description


A transaction subprocess is an embedded subprocess, which can be used to group multiple activities to a transaction. A transaction is a logical unit of work which allows to group a set of individual activities, such that they either succeed or fail collectively.

*Possible outcomes of a transaction:* A transaction can have three different outcomes:

* A transaction is _successful_, if it is neither cancelled not terminated by a hazard. If a transaction subprocess is successful, it is left using the outgoing sequenceflow(s). A successful transaction might be compensated if a compensation event is thrown later in the process. _Note:_ just as "ordinary" embedded subprocesses, a transaction may be compensated after successful completion using an intermediary throwing compensation event.
* A transaction is _cancelled_, if an execution reaches the cancel end event. In that case, all executions are terminated and removed. A single remaining execution is then set to the cancel boundary event, which triggers compensation. After compensation is completed, the transaction subprocess is left using the outgoing sequence flow(s) of the cancel boundary event.
* A transaction is ended by a _hazard_, if an error event is thrown, that is not caught within the scope of the transaction subprocess. (This also applies if the error is caught on the boundary of the transaction subprocess.) In this case, compensation is not performed.

The following diagram illustrates the three different outcomes:

image::images/bpmn.transaction.subprocess.example.1.png[align="center"]


*Relation to ACID transactions:* it is important not to confuse the bpmn transaction subprocess with technical (ACID) transactions. The bpmn transaction subprocess is not a way to scope technical transactions. In order to understand transaction management in Activiti, read the section on <<bpmnConcurrencyAndTransactions,concurrency and transactions>>. A bpmn transaction is different from a technical transaction in the following ways:

* While an ACID transaction is typically short lived, a bpmn transaction may take hours, days or even months to complete. (Consider the case where one of the activities grouped by a transaction is a usertask, typically people have longer response times than applications. Or, in another situation, a bpmn transaction might wait for some business event to occur, like the fact that a particular order has been fulfilled.) Such operations usually take considerably longer to complete than updating a record in a database, or storing a message using a transactional queue.
* Because it is impossible to scope a technical transaction to the duration of a business activity, a bpmn transaction typically spans multiple ACID transactions.
* Since a bpmn transaction spans multiple ACID transactions, we loose ACID properties. For example, consider the example given above. Let's assume the "book hotel" and the "charge credit card" operations are performed in separate ACID transactions. Let's also assume that the "book hotel" activity is successful. Now we have an intermediary inconsistent state, because we have performed an hotel booking but have not yet charged the credit card. Now, in an ACID transaction, we would also perform different operations sequentially and thus also have an intermediary inconsistent state. What is different here, is that the inconsistent state is visible outside of the scope of the transaction. For example, if the reservations are made using an external booking service, other parties using the same booking service might already see that the hotel is booked. This means, that when implementing business transactions, we completely loose the isolation property (Granted: we usually also relax isolation when working with ACID transactions to allow for higher levels of concurrency, but there we have fine grained control and intermediary inconsistencies are only present for very short periods of times).
* A bpmn business transaction can also not be rolled back in the traditional sense. Since it spans multiple ACID transactions, some of these ACID transactions might already be committed at the time the bpmn transaction is cancelled. At this point, they cannot be rolled back anymore.


Since bpmn transactions are long-running in nature, the lack of isolation and a rollback mechanism need to be dealt with differently. In practice, there is usually no better solution than to deal with these problems in a domain specific way:

* The rollback is performed using compensation. If a cancel event is thrown in the scope of a transaction, the effects of all activities that executed successfully and have a compensation handler are compensated.
* The lack of isolation is also often dealt with using domain specific solutions. For instance, in the example above, an hotel room might appear to be booked to a second customer, before we have actually made sure that the first customer can pay for it. Since this might be undesirable from a business perspective, a booking service might choose to allow for a certain amount of overbooking.
* In addition, since the transaction can be aborted in case of a hazard, the booking service has to deal with the situation where a hotel room is booked but payment is never attempted (since the transaction was aborted). In that case the booking service might choose a strategy where a hotel room is reserved for a maximum period of time and if payment is not received until then, the booking is cancelled.

To sum it up: while ACID transactions offer a generic solution to such problems (rollback, isolation levels and heuristic outcomes), we need to find domain specific solutions to these problems when implementing business transactions.

*Current limitations:*

* The BPMN specification requires that the process engine reacts to events issued by the underlying transaction protocol and for instance that a transaction is cancelled, if a cancel event occurs in the underlying protocol. As an embeddable engine, Activiti does currently not support this. (For some ramifications of this, see paragraph on consistency below.)

*Consistency on top of ACID transactions and optimistic concurrency:* A bpmn transaction guarantees consistency in the sense that either all activities compete successfully, or if some activity cannot be performed, the effects of all other successful activities are compensated. So either way we end up in a consistent state. However, it is important to recognize that in Activiti, the consistency model for bpmn transactions is superposed on top of the consistency model for process execution. Activiti executes processes in a transactional way. Concurrency is addressed using optimistic locking. In Activiti, bpmn error, cancel and compensation events are built on top of the same acid transactions and optimistic locking. For example, a cancel end event can only trigger compensation if it is actually reached. It is not reached if some undeclared exception is thrown by a service task before. Or, the effects of a compensation handler cannot be committed if some other participant in the underlying ACID transaction sets the transaction to the state rollback-only. Or, when two concurrent executions reach a cancel end event, compensation might be triggered twice and fail with an optimistic locking exception. All of this is to say that when implementing bpmn transactions in Activiti, the same set of rules apply as when implementing "ordinary" processes and subprocesses. So to effectively guarantee consistency, it is important to implement processes in a way that does take the optimistic, transactional execution model into consideration.


[[bpmnEventSubprocessGraphicalNotation]]


===== Graphical Notation


An transaction subprocess might be visualized as a an <<bpmnSubProcessGraphicalNotation,embedded subprocess>> with a double outline.

image::images/bpmn.transaction.subprocess.png[align="center"]


[[bpmnEventSubprocessXMLRepresentation]]


===== XML representation


A transaction subprocess is represented using xml using the  +transaction+ tag:

[source,xml,linenums]
----
<transaction id="myTransaction" >
	...
</transaction>
----


[[bpmnEventSubprocessExample]]


===== Example


The following is an example of a transaction subprocess:

image::images/bpmn.transaction.subprocess.example.2.png[align="center"]


[[bpmnCallActivity]]


==== Call activity (subprocess)

[[bpmnCallActivityDescription]]


===== Description

BPMN 2.0 makes a distinction between a regular _<<bpmnSubProcess,subprocess>>_, often also called _embedded subprocess_, and the call activity, which looks very similar. From a conceptual point of view, both will call a subprocess when process execution arrives at the activity.

The difference is that the call activity references a process that is external to the process definition, whereas the _<<bpmnSubProcess,subprocess>>_ is embedded within the original process definition. The main use case for the call activity is to have a reusable process definition that can be called from multiple other process definitions.

When process execution arrives in the _call activity_, a new execution is created that is a sub-execution of the execution that arrives in the call activity. This sub-execution is then used to execute the subprocess, potentially creating parallel child execution as within a regular process. The super-execution waits until the subprocess is completely ended, and continues the original process afterwards.


[[bpmnCallActivityGraphicalNotation]]


===== Graphical Notation


A call activity is visualized the same as a <<bpmnSubProcessGraphicalNotation,subprocess>>, however with a thick border (collapsed and expanded). Depending on the modeling tool, a call activity can also be expanded, but the default visualization is the collapsed subprocess representation.

image::images/bpmn.collapsed.call.activity.png[align="center"]


[[bpmnCallActivityXMLRepresentation]]


===== XML representation

A call activity is a regular activity, that requires a _calledElement_ that references a process definition by its *key*. In practice, this means that the *id of the process* is used in the _calledElement_.

[source,xml,linenums]
----
<callActivity id="callCheckCreditProcess" name="Check credit" calledElement="checkCreditProcess" />
----

Note that the process definition of the subprocess is *resolved at runtime*. This means that the subprocess can be deployed independently from the calling process, if needed.


[[bpmnCallActivityPassVariables]]


===== Passing variables

You can pass process variables to the sub process and vice versa. The data is copied into the subprocess when it is started and copied back into the main process when it ends.

[source,xml,linenums]
----
<callActivity id="callSubProcess" calledElement="checkCreditProcess" >
  <extensionElements>
	  <activiti:in source="someVariableInMainProcess" target="nameOfVariableInSubProcess" />
	  <activiti:out source="someVariableInSubProcess" target="nameOfVariableInMainProcess" />
  </extensionElements>
</callActivity>
----

We use an Activiti Extension as a shortcut for the BPMN standard elements called __dataInputAssociation__ and __dataOutputAssociation__, which only work if you declare process variables in the BPMN 2.0 standard way.

It is possible to use expressions here as well:

[source,xml,linenums]
----
<callActivity id="callSubProcess" calledElement="checkCreditProcess" >
	<extensionElements>
	  <activiti:in sourceExpression="${x+5}" target="y" />
	  <activiti:out source="${y+5}" target="z" />
	</extensionElements>
</callActivity>
----

So in the end z = y+5 = x+5+5


[[bpmnCallActivityExample]]


===== Example

The following process diagram shows a simple handling of an order. Since the checking of the customer's credit could be common to many other processes, the _check credit step_ is modeled here as a call activity.

image::images/bpmn.call.activity.super.process.png[align="center"]

The process looks as follows:

[source,xml,linenums]
----
<startEvent id="theStart" />
<sequenceFlow id="flow1" sourceRef="theStart" targetRef="receiveOrder" />

<manualTask id="receiveOrder" name="Receive Order" />
<sequenceFlow id="flow2" sourceRef="receiveOrder" targetRef="callCheckCreditProcess" />

<callActivity id="callCheckCreditProcess" name="Check credit" calledElement="checkCreditProcess" />
<sequenceFlow id="flow3" sourceRef="callCheckCreditProcess" targetRef="prepareAndShipTask" />

<userTask id="prepareAndShipTask" name="Prepare and Ship" />
<sequenceFlow id="flow4" sourceRef="prepareAndShipTask" targetRef="end" />

<endEvent id="end" />
----

The subprocess looks as follows:

image::images/bpmn.call.activity.sub.process.png[align="center"]

There is nothing special to the process definition of the subprocess. It could as well be used without being called from another process.


[[bpmnConcurrencyAndTransactions]]


=== Transactions and Concurrency

[[asyncContinuations]]


==== Asynchronous Continuations


Activiti executes processes in a transactional way which can be configured to suite your needs. Lets start by looking at how Activiti scopes transactions normally. If you trigger Activiti (i.e. start a process, complete a task, signal an execution), Activiti is going to advance in the process, until it reaches wait states on each active path of execution. More concretely speaking it performs a depth-first search through the process graph and returns if it has reached wait states on every branch of execution. A wait state is a task which is performed "later" which means that Activiti persists the current execution and waits to be triggered again. The trigger can either come from an external source for example if we have a user task or a receive message task, or from Activiti itself, if we have a timer event. This is illustrated in the following picture:

image::images/activiti.async.example.no.async.PNG[align="center"]

We see a segment of a BPMN processes with a usertask, a service task and a timer event. Completing the usertask and validating the address is part of the same unit of work, so it should succeed or fail atomically. That means that if the service task throws an exception we want to rollback the current transaction, such that the execution tracks back to the user task and the user task is still present in the database. This is also the default behavior of Activiti. In (1) an application or client thread completes the task. In that same thread Activiti is now executing the service and advances until it reaches a wait state, in this case the timer event (2). Then it returns the control to the caller (3) potentially committing the transaction (if it was started by Activiti).


In some cases this is not what we want. Sometimes we need custom control over transaction boundaries in a process, in order to be able to scope logical units of work. This is where asynchronous continuations come into play. Consider the following process (fragment):

image::images/activiti.async.example.async.PNG[align="center"]


This time we are completing the user task, generating an invoice and then send that invoice to the customer. This time the generation of the invoice is not part of the same unit of work so we do not want to rollback the completion of the usertask if generating an invoice fails. So what we want Activiti to do is complete the user task (1), commit the transaction and return the control to the calling application. Then we want to generate the invoice asynchronously, in a background thread. This background thread is the Activiti job executor (actually a thread pool) which periodically polls the database for jobs. So behind the scenes, when we reach the "generate invoice" task, we are creating a job "message" for Activiti to continue the process later and persisting it into the database. This job is then picked up by the job executor and executed. We are also giving the local job executor a little hint that there is a new job, to improve performance.

In order to use this feature, we can use the _activiti:async="true"_ extension. So for example, the service task would look like this:

[source,xml,linenums]
----
<serviceTask id="service1" name="Generate Invoice" activiti:class="my.custom.Delegate" activiti:async="true" />
----


_activiti:async_ can be specified on the following BPMN task types: task, serviceTask, scriptTask, businessRuleTask, sendTask, receiveTask, userTask, subProcess, callActivity


On a userTask, receiveTask or other wait states, the async continuation allows us to execute the start execution listeners in a separate  thread/transaction.


[[failRetry]]


==== Fail Retry

Activiti, in its default configuration, reruns a job 3 times in case of any exception in execution of a job. This holds also for asynchronous task jobs. In some cases more flexibility is required. There are two parameters to be configured:

* Number of retries
* Delay between retries These parameters can be configured by +activiti:failedJobRetryTimeCycle+ element. Here is a sample usage:

[source,xml,linenums]
----
<serviceTask id="failingServiceTask" activiti:async="true" activiti:class="org.activiti.engine.test.jobexecutor.RetryFailingDelegate">
	<extensionElements>
		<activiti:failedJobRetryTimeCycle>R5/PT7M</activiti:failedJobRetryTimeCycle>
	</extensionElements>
</serviceTask>
----

Time cycle expression follows ISO 8601 standard, just like timer event expressions. The above example, makes the job executor to retry the job 5 times and wait 7 minutes between before each retry.


[[exclusiveJobs]]


==== Exclusive Jobs

Since Activiti 5.9, the JobExecutor makes sure that jobs from a single process instance are never executed concurrently. Why is this?


===== Why exclusive Jobs?

Consider the following process definition:

image::images/bpmn.why.exclusive.jobs.png[align="center"]

We have a parallel gateway followed by three service tasks which all perform an asynchronous continuation. As a result of this, three jobs are added to the database. Once such a job is present in the database it can be processes by the JobExecutor. The JobExecutor acquires the jobs and delegates them to a thread pool of worker threads which actually process the jobs. This means that using an asynchronous continuation, you can distribute the work to this thread pool (and in a clustered scenario even across multiple thread pools in the cluster). This is usually a good thing. However it also bears an inherent problem: consistency. Consider the parallel join after the service tasks. When execution of a service tasks is completed, we arrive at the parallel join and need to decide whether to wait for the other executions or whether we can move forward. That means, for each branch arriving at the parallel join, we need to take a decision whether we can continue or whether we need to wait for one or more other executions on the other branches.

Why is this a problem? Since the service tasks are configured using an asynchronous continuation, it is possible that the corresponding jobs are all acquired at the same time and delegated to different worker threads by the JobExecutor. The consequence is that the transactions in which the services are executed and in which the 3 individual executions arrive at the parallel join can overlap. And if they do so, each individual transaction will not "see", that another transaction is arriving at the same parallel join concurrently and thus assume that it has to wait for the others. However, if each transaction assumes that it has to wait for the other ones, none will continue the process after the parallel join and the process instance will remain in that state forever.

How does Activiti address this problem? Activiti performs optimistic locking. Whenever we take a decision based on data that might not be current (because another transaction might modify it before we commit, we make sure to increment the version of the same database row in both transactions). This way, whichever transaction commits first wins and the other ones fail with an optimistic locking exception. This solves the problem in the case of the process discussed above: if multiple executions arrive at the parallel join concurrently, they all assume that they have to wait, increment the version of their parent execution (the process instance) and then try to commit. Whichever execution is first will be able to commit and the other ones will fail with an optimistic locking exception. Since the executions are triggered by a job, Activiti will retry to perform the same job after waiting for a certain amount of time and hopefully this time pass the synchronizing gateway.


Is this a good solution? As we have seen, optimistic locking allows Activiti to prevent inconsistencies. It makes sure that we do not "keep stuck at the joining gateway", meaning: either all executions have passed the gateway or, there are jobs in the database making sure that we retry passing it. However, while this is a perfectly fine solution from the point of view of persistence and consistency, this might not always be desirable behavior at an higher level:

* Activiti will retry the same job for a fixed maximum number of times only ('3' in the default configuration). After that, the job will still be present in the database but not be retried actively anymore. That means that an operator would need to trigger the job manually.
* If a job has non-transactional side effects, those will not be rolled back by the failing transaction. For instance, if the "book concert tickets" service does not share the same transaction as Activiti, we might book multiple tickets if we retry the job.


===== What are exclusive jobs?

An exclusive job cannot be performed at the same time as another exclusive job from the same process instance. Consider the process shown above: if we declare the service tasks to be exclusive, the JobExecutor will make sure that the corresponding jobs are not executed concurrently. Instead, it will make sure that whenever it acquires an exclusive job from a certain process instance, it acquires all other exclusive jobs from the same process instance and delegates them to the same worker thread. This ensures sequential execution execution of the jobs.

How can I enable this feature? Since Activiti 5.9, exclusive jobs are the default configuration. All asynchronous continuations and timer events are thus exclusive by default. In addition, if you want a job to be non-exclusive, you can configure it as such using +activiti:exclusive="false"+. For example, the following servicetask would be asynchronous but non-exclusive.

[source,xml,linenums]
----
<serviceTask id="service" activiti:expression="${myService.performBooking(hotel, dates)}" activiti:async="true" activiti:exclusive="false" />
----


Is this a good solution? We had some people asking whether this was a good solution. Their concern was that this would to prevent you from "doing things" in parallel and would thus be a performance problem. Again, two things have to be taken into consideration:

* It can be turned off if you are an expert and know what you are doing (and have understood the section named "Why exclusive Jobs?"). Other than that, it is more intuitive for most users if things like asynchronous continuations and timers just work.
* It is actually not a performance issue. Performance is an issue under heavy load. Heavy load means that all worker threads of the job executor are busy all the time. With exclusive jobs, Activiti will simply distribute the load differently. Exclusive jobs means that jobs from a single process instance are performed by the same thread sequentially. But consider: you have more than one single process instance. And jobs from other process instances are delegated to other threads and executed concurrently. This means that with exclusive jobs Activiti will not execute jobs from the same process instance concurrently, but it will still execute multiple instances concurrently. From an overall throughput perspective this is desirable in most scenarios as it usually leads to individual instances being done more quickly. Furthermore, data that is required for executing subsequent jobs of the same process instance will already be in the cache of the executing cluster node. If the jobs do not have this node affinity, that data might need to be fetched from the database again.


[[security]]


=== Process Initiation Authorization

By default everyone is allowed to start a new process instance of deployed process definitions. The process initiation authorization functionality allows to define users and groups so that web clients can optionally restrict users to start a new process instance. NOTE that the authorization definition is NOT validated by the Activiti Engine in any way. This functionality is only meant for developers to ease the implementation of authorization rules in a web client. The syntax is similar to the syntax of user assignment for a user task. A user or group can be assigned as potential initiator of a process using <activiti:potentialStarter> tag. Here is an example:

[source,xml,linenums]
----
<process id="potentialStarter">
  <extensionElements>
    <activiti:potentialStarter>
       <resourceAssignmentExpression>
         <formalExpression>group2, group(group3), user(user3)</formalExpression>
       </resourceAssignmentExpression>
    </activiti:potentialStarter>
  </extensionElements>

  <startEvent id="theStart"/>
  ...
----

In the above xml excerpt user(user3) refers directly to user user3 and group(group3) to group group3. No indicator will default to a group type. It is also possible to use attributes of the <process> tag, namely <activiti:candidateStarterUsers> and <activiti:candidateStarterGroups>. Here is an example:

[source,xml,linenums]
----
<process id="potentialStarter" activiti:candidateStarterUsers="user1, user2"
                               activiti:candidateStarterGroups="group1">
      ...
----


It is possible to use both attributes simultaneously.


After the process initiation authorizations are defined, a developer can retrieve the authorization definition using the following methods.
This code retrieves the list of process definitions which can be initiated by the given user:

[source,java,linenums]
----
processDefinitions = repositoryService.createProcessDefinitionQuery().startableByUser("userxxx").list();
----

It's also possible to retrieve all identity links that are defined as potential starter for a specific process definition

[source,java,linenums]
----
identityLinks = repositoryService.getIdentityLinksForProcessDefinition("processDefinitionId");
----

The following example shows how to get list of users who can initiate the given process:

[source,java,linenums]
----
List<User> authorizedUsers =  identityService().createUserQuery().potentialStarter("processDefinitionId").list();
----


Exactly the same way, the list of groups that is configured as a potential starter to a given process definition can be retrieved:

[source,java,linenums]
----
List<Group> authorizedGroups =  identityService().createGroupQuery().potentialStarter("processDefinitionId").list();
----


[[dataobjects]]


=== Data objects

<<experimental,[EXPERIMENTAL]>>

BPMN provides the possibility to define data objects as part of a process or sub process element. According to the BPMN specification it's possible to include complex XML structures that might be imported from XSD definitions. As a first start to support data objects in Activiti the following XSD types are supported:

[source,xml,linenums]
----
<dataObject id="dObj1" name="StringTest" itemSubjectRef="xsd:string"/>
<dataObject id="dObj2" name="BooleanTest" itemSubjectRef="xsd:boolean"/>
<dataObject id="dObj3" name="DateTest" itemSubjectRef="xsd:datetime"/>
<dataObject id="dObj4" name="DoubleTest" itemSubjectRef="xsd:double"/>
<dataObject id="dObj5" name="IntegerTest" itemSubjectRef="xsd:int"/>
<dataObject id="dObj6" name="LongTest" itemSubjectRef="xsd:long"/>
----

The data object definitions will be automatically converted to process variables using the 'name' attribute value as the name for the new variable. In addition to the definition of the data object Activiti also provides an extension element to assign a default value to the variable. The following BPMN snippet provides an example:

[source,xml,linenums]
----
<process id="dataObjectScope" name="Data Object Scope" isExecutable="true">
  <dataObject id="dObj123" name="StringTest123" itemSubjectRef="xsd:string">
    <extensionElements>
      <activiti:value>Testing123</activiti:value>
    </extensionElements>
  </dataObject>
  ...
----
